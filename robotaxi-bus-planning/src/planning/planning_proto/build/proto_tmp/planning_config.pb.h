// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning_config.proto

#ifndef PROTOBUF_planning_5fconfig_2eproto__INCLUDED
#define PROTOBUF_planning_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dp_poly_path_config.pb.h"
#include "dp_st_speed_config.pb.h"
#include "qp_spline_path_config.pb.h"
#include "qp_st_speed_config.pb.h"
#include "poly_st_speed_config.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_planning_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPiecewiseJerkPathConfigImpl();
void InitDefaultsPiecewiseJerkPathConfig();
void InitDefaultsPiecewiseJerkPathWeightsImpl();
void InitDefaultsPiecewiseJerkPathWeights();
void InitDefaultsQuasiPotentialFieldPathConfigImpl();
void InitDefaultsQuasiPotentialFieldPathConfig();
void InitDefaultsQuasiPotentialFieldPathWeightsImpl();
void InitDefaultsQuasiPotentialFieldPathWeights();
void InitDefaultsPathBoundsDeciderConfigImpl();
void InitDefaultsPathBoundsDeciderConfig();
void InitDefaultsPlannerConfigImpl();
void InitDefaultsPlannerConfig();
void InitDefaultsPlanningConfigImpl();
void InitDefaultsPlanningConfig();
inline void InitDefaults() {
  InitDefaultsPiecewiseJerkPathConfig();
  InitDefaultsPiecewiseJerkPathWeights();
  InitDefaultsQuasiPotentialFieldPathConfig();
  InitDefaultsQuasiPotentialFieldPathWeights();
  InitDefaultsPathBoundsDeciderConfig();
  InitDefaultsPlannerConfig();
  InitDefaultsPlanningConfig();
}
}  // namespace protobuf_planning_5fconfig_2eproto
namespace acu {
namespace planning {
class PathBoundsDeciderConfig;
class PathBoundsDeciderConfigDefaultTypeInternal;
extern PathBoundsDeciderConfigDefaultTypeInternal _PathBoundsDeciderConfig_default_instance_;
class PiecewiseJerkPathConfig;
class PiecewiseJerkPathConfigDefaultTypeInternal;
extern PiecewiseJerkPathConfigDefaultTypeInternal _PiecewiseJerkPathConfig_default_instance_;
class PiecewiseJerkPathWeights;
class PiecewiseJerkPathWeightsDefaultTypeInternal;
extern PiecewiseJerkPathWeightsDefaultTypeInternal _PiecewiseJerkPathWeights_default_instance_;
class PlannerConfig;
class PlannerConfigDefaultTypeInternal;
extern PlannerConfigDefaultTypeInternal _PlannerConfig_default_instance_;
class PlanningConfig;
class PlanningConfigDefaultTypeInternal;
extern PlanningConfigDefaultTypeInternal _PlanningConfig_default_instance_;
class QuasiPotentialFieldPathConfig;
class QuasiPotentialFieldPathConfigDefaultTypeInternal;
extern QuasiPotentialFieldPathConfigDefaultTypeInternal _QuasiPotentialFieldPathConfig_default_instance_;
class QuasiPotentialFieldPathWeights;
class QuasiPotentialFieldPathWeightsDefaultTypeInternal;
extern QuasiPotentialFieldPathWeightsDefaultTypeInternal _QuasiPotentialFieldPathWeights_default_instance_;
}  // namespace planning
}  // namespace acu
namespace acu {
namespace planning {

enum PlanningConfig_PlannerType {
  PlanningConfig_PlannerType_PATH = 0,
  PlanningConfig_PlannerType_SPEED = 1
};
bool PlanningConfig_PlannerType_IsValid(int value);
const PlanningConfig_PlannerType PlanningConfig_PlannerType_PlannerType_MIN = PlanningConfig_PlannerType_PATH;
const PlanningConfig_PlannerType PlanningConfig_PlannerType_PlannerType_MAX = PlanningConfig_PlannerType_SPEED;
const int PlanningConfig_PlannerType_PlannerType_ARRAYSIZE = PlanningConfig_PlannerType_PlannerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlanningConfig_PlannerType_descriptor();
inline const ::std::string& PlanningConfig_PlannerType_Name(PlanningConfig_PlannerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlanningConfig_PlannerType_descriptor(), value);
}
inline bool PlanningConfig_PlannerType_Parse(
    const ::std::string& name, PlanningConfig_PlannerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlanningConfig_PlannerType>(
    PlanningConfig_PlannerType_descriptor(), name, value);
}
enum TaskType {
  DP_POLY_PATH_OPTIMIZER = 0,
  DP_ST_SPEED_OPTIMIZER = 1,
  QP_SPLINE_PATH_OPTIMIZER = 2,
  QP_SPLINE_ST_SPEED_OPTIMIZER = 3,
  TRAFFIC_DECIDER = 4,
  PATH_DECIDER = 5,
  SPEED_DECIDER = 6,
  POLY_ST_SPEED_OPTIMIZER = 7,
  PIECEWISE_JERK_PATH_OPTIMIZER = 8,
  PATH_BOUNDS_DECIDER = 9,
  QUASI_POTENTIAL_FIELD_PATH_OPTIMIZER = 10
};
bool TaskType_IsValid(int value);
const TaskType TaskType_MIN = DP_POLY_PATH_OPTIMIZER;
const TaskType TaskType_MAX = QUASI_POTENTIAL_FIELD_PATH_OPTIMIZER;
const int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskType_descriptor();
inline const ::std::string& TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskType_descriptor(), value);
}
inline bool TaskType_Parse(
    const ::std::string& name, TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
// ===================================================================

class PiecewiseJerkPathConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.PiecewiseJerkPathConfig) */ {
 public:
  PiecewiseJerkPathConfig();
  virtual ~PiecewiseJerkPathConfig();

  PiecewiseJerkPathConfig(const PiecewiseJerkPathConfig& from);

  inline PiecewiseJerkPathConfig& operator=(const PiecewiseJerkPathConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PiecewiseJerkPathConfig(PiecewiseJerkPathConfig&& from) noexcept
    : PiecewiseJerkPathConfig() {
    *this = ::std::move(from);
  }

  inline PiecewiseJerkPathConfig& operator=(PiecewiseJerkPathConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PiecewiseJerkPathConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PiecewiseJerkPathConfig* internal_default_instance() {
    return reinterpret_cast<const PiecewiseJerkPathConfig*>(
               &_PiecewiseJerkPathConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PiecewiseJerkPathConfig* other);
  friend void swap(PiecewiseJerkPathConfig& a, PiecewiseJerkPathConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PiecewiseJerkPathConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PiecewiseJerkPathConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PiecewiseJerkPathConfig& from);
  void MergeFrom(const PiecewiseJerkPathConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PiecewiseJerkPathConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.planning.PiecewiseJerkPathWeights default_path_config = 1;
  bool has_default_path_config() const;
  void clear_default_path_config();
  static const int kDefaultPathConfigFieldNumber = 1;
  const ::acu::planning::PiecewiseJerkPathWeights& default_path_config() const;
  ::acu::planning::PiecewiseJerkPathWeights* release_default_path_config();
  ::acu::planning::PiecewiseJerkPathWeights* mutable_default_path_config();
  void set_allocated_default_path_config(::acu::planning::PiecewiseJerkPathWeights* default_path_config);

  // optional .acu.planning.PiecewiseJerkPathWeights lane_change_path_config = 2;
  bool has_lane_change_path_config() const;
  void clear_lane_change_path_config();
  static const int kLaneChangePathConfigFieldNumber = 2;
  const ::acu::planning::PiecewiseJerkPathWeights& lane_change_path_config() const;
  ::acu::planning::PiecewiseJerkPathWeights* release_lane_change_path_config();
  ::acu::planning::PiecewiseJerkPathWeights* mutable_lane_change_path_config();
  void set_allocated_lane_change_path_config(::acu::planning::PiecewiseJerkPathWeights* lane_change_path_config);

  // optional .acu.planning.PiecewiseJerkPathWeights start_from_road_side_config = 3;
  bool has_start_from_road_side_config() const;
  void clear_start_from_road_side_config();
  static const int kStartFromRoadSideConfigFieldNumber = 3;
  const ::acu::planning::PiecewiseJerkPathWeights& start_from_road_side_config() const;
  ::acu::planning::PiecewiseJerkPathWeights* release_start_from_road_side_config();
  ::acu::planning::PiecewiseJerkPathWeights* mutable_start_from_road_side_config();
  void set_allocated_start_from_road_side_config(::acu::planning::PiecewiseJerkPathWeights* start_from_road_side_config);

  // @@protoc_insertion_point(class_scope:acu.planning.PiecewiseJerkPathConfig)
 private:
  void set_has_default_path_config();
  void clear_has_default_path_config();
  void set_has_lane_change_path_config();
  void clear_has_lane_change_path_config();
  void set_has_start_from_road_side_config();
  void clear_has_start_from_road_side_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::planning::PiecewiseJerkPathWeights* default_path_config_;
  ::acu::planning::PiecewiseJerkPathWeights* lane_change_path_config_;
  ::acu::planning::PiecewiseJerkPathWeights* start_from_road_side_config_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsPiecewiseJerkPathConfigImpl();
};
// -------------------------------------------------------------------

class PiecewiseJerkPathWeights : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.PiecewiseJerkPathWeights) */ {
 public:
  PiecewiseJerkPathWeights();
  virtual ~PiecewiseJerkPathWeights();

  PiecewiseJerkPathWeights(const PiecewiseJerkPathWeights& from);

  inline PiecewiseJerkPathWeights& operator=(const PiecewiseJerkPathWeights& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PiecewiseJerkPathWeights(PiecewiseJerkPathWeights&& from) noexcept
    : PiecewiseJerkPathWeights() {
    *this = ::std::move(from);
  }

  inline PiecewiseJerkPathWeights& operator=(PiecewiseJerkPathWeights&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PiecewiseJerkPathWeights& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PiecewiseJerkPathWeights* internal_default_instance() {
    return reinterpret_cast<const PiecewiseJerkPathWeights*>(
               &_PiecewiseJerkPathWeights_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PiecewiseJerkPathWeights* other);
  friend void swap(PiecewiseJerkPathWeights& a, PiecewiseJerkPathWeights& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PiecewiseJerkPathWeights* New() const PROTOBUF_FINAL { return New(NULL); }

  PiecewiseJerkPathWeights* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PiecewiseJerkPathWeights& from);
  void MergeFrom(const PiecewiseJerkPathWeights& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PiecewiseJerkPathWeights* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double dynamic_obstacle_weight = 6 [default = 0];
  bool has_dynamic_obstacle_weight() const;
  void clear_dynamic_obstacle_weight();
  static const int kDynamicObstacleWeightFieldNumber = 6;
  double dynamic_obstacle_weight() const;
  void set_dynamic_obstacle_weight(double value);

  // optional double dotted_line_weight = 7 [default = 0];
  bool has_dotted_line_weight() const;
  void clear_dotted_line_weight();
  static const int kDottedLineWeightFieldNumber = 7;
  double dotted_line_weight() const;
  void set_dotted_line_weight(double value);

  // optional double solid_line_weight = 8 [default = 0];
  bool has_solid_line_weight() const;
  void clear_solid_line_weight();
  static const int kSolidLineWeightFieldNumber = 8;
  double solid_line_weight() const;
  void set_solid_line_weight(double value);

  // optional double curb_weight = 9 [default = 0];
  bool has_curb_weight() const;
  void clear_curb_weight();
  static const int kCurbWeightFieldNumber = 9;
  double curb_weight() const;
  void set_curb_weight(double value);

  // optional double l_weight = 1 [default = 1];
  bool has_l_weight() const;
  void clear_l_weight();
  static const int kLWeightFieldNumber = 1;
  double l_weight() const;
  void set_l_weight(double value);

  // optional double dl_weight = 2 [default = 100];
  bool has_dl_weight() const;
  void clear_dl_weight();
  static const int kDlWeightFieldNumber = 2;
  double dl_weight() const;
  void set_dl_weight(double value);

  // optional double ddl_weight = 3 [default = 1000];
  bool has_ddl_weight() const;
  void clear_ddl_weight();
  static const int kDdlWeightFieldNumber = 3;
  double ddl_weight() const;
  void set_ddl_weight(double value);

  // optional double dddl_weight = 4 [default = 10000];
  bool has_dddl_weight() const;
  void clear_dddl_weight();
  static const int kDddlWeightFieldNumber = 4;
  double dddl_weight() const;
  void set_dddl_weight(double value);

  // optional double obstacle_weight = 5 [default = 50];
  bool has_obstacle_weight() const;
  void clear_obstacle_weight();
  static const int kObstacleWeightFieldNumber = 5;
  double obstacle_weight() const;
  void set_obstacle_weight(double value);

  // @@protoc_insertion_point(class_scope:acu.planning.PiecewiseJerkPathWeights)
 private:
  void set_has_l_weight();
  void clear_has_l_weight();
  void set_has_dl_weight();
  void clear_has_dl_weight();
  void set_has_ddl_weight();
  void clear_has_ddl_weight();
  void set_has_dddl_weight();
  void clear_has_dddl_weight();
  void set_has_obstacle_weight();
  void clear_has_obstacle_weight();
  void set_has_dynamic_obstacle_weight();
  void clear_has_dynamic_obstacle_weight();
  void set_has_dotted_line_weight();
  void clear_has_dotted_line_weight();
  void set_has_solid_line_weight();
  void clear_has_solid_line_weight();
  void set_has_curb_weight();
  void clear_has_curb_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double dynamic_obstacle_weight_;
  double dotted_line_weight_;
  double solid_line_weight_;
  double curb_weight_;
  double l_weight_;
  double dl_weight_;
  double ddl_weight_;
  double dddl_weight_;
  double obstacle_weight_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsPiecewiseJerkPathWeightsImpl();
};
// -------------------------------------------------------------------

class QuasiPotentialFieldPathConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.QuasiPotentialFieldPathConfig) */ {
 public:
  QuasiPotentialFieldPathConfig();
  virtual ~QuasiPotentialFieldPathConfig();

  QuasiPotentialFieldPathConfig(const QuasiPotentialFieldPathConfig& from);

  inline QuasiPotentialFieldPathConfig& operator=(const QuasiPotentialFieldPathConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuasiPotentialFieldPathConfig(QuasiPotentialFieldPathConfig&& from) noexcept
    : QuasiPotentialFieldPathConfig() {
    *this = ::std::move(from);
  }

  inline QuasiPotentialFieldPathConfig& operator=(QuasiPotentialFieldPathConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuasiPotentialFieldPathConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuasiPotentialFieldPathConfig* internal_default_instance() {
    return reinterpret_cast<const QuasiPotentialFieldPathConfig*>(
               &_QuasiPotentialFieldPathConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(QuasiPotentialFieldPathConfig* other);
  friend void swap(QuasiPotentialFieldPathConfig& a, QuasiPotentialFieldPathConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuasiPotentialFieldPathConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  QuasiPotentialFieldPathConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuasiPotentialFieldPathConfig& from);
  void MergeFrom(const QuasiPotentialFieldPathConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuasiPotentialFieldPathConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.planning.QuasiPotentialFieldPathWeights default_path_config = 1;
  bool has_default_path_config() const;
  void clear_default_path_config();
  static const int kDefaultPathConfigFieldNumber = 1;
  const ::acu::planning::QuasiPotentialFieldPathWeights& default_path_config() const;
  ::acu::planning::QuasiPotentialFieldPathWeights* release_default_path_config();
  ::acu::planning::QuasiPotentialFieldPathWeights* mutable_default_path_config();
  void set_allocated_default_path_config(::acu::planning::QuasiPotentialFieldPathWeights* default_path_config);

  // optional .acu.planning.QuasiPotentialFieldPathWeights start_from_road_side_config = 2;
  bool has_start_from_road_side_config() const;
  void clear_start_from_road_side_config();
  static const int kStartFromRoadSideConfigFieldNumber = 2;
  const ::acu::planning::QuasiPotentialFieldPathWeights& start_from_road_side_config() const;
  ::acu::planning::QuasiPotentialFieldPathWeights* release_start_from_road_side_config();
  ::acu::planning::QuasiPotentialFieldPathWeights* mutable_start_from_road_side_config();
  void set_allocated_start_from_road_side_config(::acu::planning::QuasiPotentialFieldPathWeights* start_from_road_side_config);

  // @@protoc_insertion_point(class_scope:acu.planning.QuasiPotentialFieldPathConfig)
 private:
  void set_has_default_path_config();
  void clear_has_default_path_config();
  void set_has_start_from_road_side_config();
  void clear_has_start_from_road_side_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::planning::QuasiPotentialFieldPathWeights* default_path_config_;
  ::acu::planning::QuasiPotentialFieldPathWeights* start_from_road_side_config_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsQuasiPotentialFieldPathConfigImpl();
};
// -------------------------------------------------------------------

class QuasiPotentialFieldPathWeights : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.QuasiPotentialFieldPathWeights) */ {
 public:
  QuasiPotentialFieldPathWeights();
  virtual ~QuasiPotentialFieldPathWeights();

  QuasiPotentialFieldPathWeights(const QuasiPotentialFieldPathWeights& from);

  inline QuasiPotentialFieldPathWeights& operator=(const QuasiPotentialFieldPathWeights& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuasiPotentialFieldPathWeights(QuasiPotentialFieldPathWeights&& from) noexcept
    : QuasiPotentialFieldPathWeights() {
    *this = ::std::move(from);
  }

  inline QuasiPotentialFieldPathWeights& operator=(QuasiPotentialFieldPathWeights&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuasiPotentialFieldPathWeights& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuasiPotentialFieldPathWeights* internal_default_instance() {
    return reinterpret_cast<const QuasiPotentialFieldPathWeights*>(
               &_QuasiPotentialFieldPathWeights_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(QuasiPotentialFieldPathWeights* other);
  friend void swap(QuasiPotentialFieldPathWeights& a, QuasiPotentialFieldPathWeights& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuasiPotentialFieldPathWeights* New() const PROTOBUF_FINAL { return New(NULL); }

  QuasiPotentialFieldPathWeights* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuasiPotentialFieldPathWeights& from);
  void MergeFrom(const QuasiPotentialFieldPathWeights& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuasiPotentialFieldPathWeights* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double l_weight = 1 [default = 1];
  bool has_l_weight() const;
  void clear_l_weight();
  static const int kLWeightFieldNumber = 1;
  double l_weight() const;
  void set_l_weight(double value);

  // optional double dl_weight = 2 [default = 100];
  bool has_dl_weight() const;
  void clear_dl_weight();
  static const int kDlWeightFieldNumber = 2;
  double dl_weight() const;
  void set_dl_weight(double value);

  // optional double ddl_weight = 3 [default = 1000];
  bool has_ddl_weight() const;
  void clear_ddl_weight();
  static const int kDdlWeightFieldNumber = 3;
  double ddl_weight() const;
  void set_ddl_weight(double value);

  // optional double dddl_weight = 4 [default = 10000];
  bool has_dddl_weight() const;
  void clear_dddl_weight();
  static const int kDddlWeightFieldNumber = 4;
  double dddl_weight() const;
  void set_dddl_weight(double value);

  // optional double dotted_line_weight = 5 [default = 5];
  bool has_dotted_line_weight() const;
  void clear_dotted_line_weight();
  static const int kDottedLineWeightFieldNumber = 5;
  double dotted_line_weight() const;
  void set_dotted_line_weight(double value);

  // optional double solid_line_weight = 6 [default = 10];
  bool has_solid_line_weight() const;
  void clear_solid_line_weight();
  static const int kSolidLineWeightFieldNumber = 6;
  double solid_line_weight() const;
  void set_solid_line_weight(double value);

  // optional double curb_weight = 7 [default = 20];
  bool has_curb_weight() const;
  void clear_curb_weight();
  static const int kCurbWeightFieldNumber = 7;
  double curb_weight() const;
  void set_curb_weight(double value);

  // optional double obstacle_weight = 8 [default = 20];
  bool has_obstacle_weight() const;
  void clear_obstacle_weight();
  static const int kObstacleWeightFieldNumber = 8;
  double obstacle_weight() const;
  void set_obstacle_weight(double value);

  // @@protoc_insertion_point(class_scope:acu.planning.QuasiPotentialFieldPathWeights)
 private:
  void set_has_l_weight();
  void clear_has_l_weight();
  void set_has_dl_weight();
  void clear_has_dl_weight();
  void set_has_ddl_weight();
  void clear_has_ddl_weight();
  void set_has_dddl_weight();
  void clear_has_dddl_weight();
  void set_has_dotted_line_weight();
  void clear_has_dotted_line_weight();
  void set_has_solid_line_weight();
  void clear_has_solid_line_weight();
  void set_has_curb_weight();
  void clear_has_curb_weight();
  void set_has_obstacle_weight();
  void clear_has_obstacle_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double l_weight_;
  double dl_weight_;
  double ddl_weight_;
  double dddl_weight_;
  double dotted_line_weight_;
  double solid_line_weight_;
  double curb_weight_;
  double obstacle_weight_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsQuasiPotentialFieldPathWeightsImpl();
};
// -------------------------------------------------------------------

class PathBoundsDeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.PathBoundsDeciderConfig) */ {
 public:
  PathBoundsDeciderConfig();
  virtual ~PathBoundsDeciderConfig();

  PathBoundsDeciderConfig(const PathBoundsDeciderConfig& from);

  inline PathBoundsDeciderConfig& operator=(const PathBoundsDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathBoundsDeciderConfig(PathBoundsDeciderConfig&& from) noexcept
    : PathBoundsDeciderConfig() {
    *this = ::std::move(from);
  }

  inline PathBoundsDeciderConfig& operator=(PathBoundsDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathBoundsDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathBoundsDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const PathBoundsDeciderConfig*>(
               &_PathBoundsDeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PathBoundsDeciderConfig* other);
  friend void swap(PathBoundsDeciderConfig& a, PathBoundsDeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathBoundsDeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PathBoundsDeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PathBoundsDeciderConfig& from);
  void MergeFrom(const PathBoundsDeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PathBoundsDeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_lane_borrowing = 1;
  bool has_is_lane_borrowing() const;
  void clear_is_lane_borrowing();
  static const int kIsLaneBorrowingFieldNumber = 1;
  bool is_lane_borrowing() const;
  void set_is_lane_borrowing(bool value);

  // optional bool is_pull_over = 2;
  bool has_is_pull_over() const;
  void clear_is_pull_over();
  static const int kIsPullOverFieldNumber = 2;
  bool is_pull_over() const;
  void set_is_pull_over(bool value);

  // optional double pull_over_destination_to_adc_buffer = 3 [default = 25];
  bool has_pull_over_destination_to_adc_buffer() const;
  void clear_pull_over_destination_to_adc_buffer();
  static const int kPullOverDestinationToAdcBufferFieldNumber = 3;
  double pull_over_destination_to_adc_buffer() const;
  void set_pull_over_destination_to_adc_buffer(double value);

  // optional double pull_over_destination_to_pathend_buffer = 4 [default = 10];
  bool has_pull_over_destination_to_pathend_buffer() const;
  void clear_pull_over_destination_to_pathend_buffer();
  static const int kPullOverDestinationToPathendBufferFieldNumber = 4;
  double pull_over_destination_to_pathend_buffer() const;
  void set_pull_over_destination_to_pathend_buffer(double value);

  // optional double pull_over_road_edge_buffer = 5 [default = 0.15];
  bool has_pull_over_road_edge_buffer() const;
  void clear_pull_over_road_edge_buffer();
  static const int kPullOverRoadEdgeBufferFieldNumber = 5;
  double pull_over_road_edge_buffer() const;
  void set_pull_over_road_edge_buffer(double value);

  // optional double pull_over_approach_lon_distance_adjust_factor = 6 [default = 1.5];
  bool has_pull_over_approach_lon_distance_adjust_factor() const;
  void clear_pull_over_approach_lon_distance_adjust_factor();
  static const int kPullOverApproachLonDistanceAdjustFactorFieldNumber = 6;
  double pull_over_approach_lon_distance_adjust_factor() const;
  void set_pull_over_approach_lon_distance_adjust_factor(double value);

  // @@protoc_insertion_point(class_scope:acu.planning.PathBoundsDeciderConfig)
 private:
  void set_has_is_lane_borrowing();
  void clear_has_is_lane_borrowing();
  void set_has_is_pull_over();
  void clear_has_is_pull_over();
  void set_has_pull_over_destination_to_adc_buffer();
  void clear_has_pull_over_destination_to_adc_buffer();
  void set_has_pull_over_destination_to_pathend_buffer();
  void clear_has_pull_over_destination_to_pathend_buffer();
  void set_has_pull_over_road_edge_buffer();
  void clear_has_pull_over_road_edge_buffer();
  void set_has_pull_over_approach_lon_distance_adjust_factor();
  void clear_has_pull_over_approach_lon_distance_adjust_factor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_lane_borrowing_;
  bool is_pull_over_;
  double pull_over_destination_to_adc_buffer_;
  double pull_over_destination_to_pathend_buffer_;
  double pull_over_road_edge_buffer_;
  double pull_over_approach_lon_distance_adjust_factor_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsPathBoundsDeciderConfigImpl();
};
// -------------------------------------------------------------------

class PlannerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.PlannerConfig) */ {
 public:
  PlannerConfig();
  virtual ~PlannerConfig();

  PlannerConfig(const PlannerConfig& from);

  inline PlannerConfig& operator=(const PlannerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerConfig(PlannerConfig&& from) noexcept
    : PlannerConfig() {
    *this = ::std::move(from);
  }

  inline PlannerConfig& operator=(PlannerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerConfig*>(
               &_PlannerConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PlannerConfig* other);
  friend void swap(PlannerConfig& a, PlannerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerConfig& from);
  void MergeFrom(const PlannerConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .acu.planning.TaskType task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  ::acu::planning::TaskType task(int index) const;
  void set_task(int index, ::acu::planning::TaskType value);
  void add_task(::acu::planning::TaskType value);
  const ::google::protobuf::RepeatedField<int>& task() const;
  ::google::protobuf::RepeatedField<int>* mutable_task();

  // optional .acu.planning.DpPolyPathConfig dp_poly_path_config = 2;
  bool has_dp_poly_path_config() const;
  void clear_dp_poly_path_config();
  static const int kDpPolyPathConfigFieldNumber = 2;
  const ::acu::planning::DpPolyPathConfig& dp_poly_path_config() const;
  ::acu::planning::DpPolyPathConfig* release_dp_poly_path_config();
  ::acu::planning::DpPolyPathConfig* mutable_dp_poly_path_config();
  void set_allocated_dp_poly_path_config(::acu::planning::DpPolyPathConfig* dp_poly_path_config);

  // optional .acu.planning.DpStSpeedConfig dp_st_speed_config = 3;
  bool has_dp_st_speed_config() const;
  void clear_dp_st_speed_config();
  static const int kDpStSpeedConfigFieldNumber = 3;
  const ::acu::planning::DpStSpeedConfig& dp_st_speed_config() const;
  ::acu::planning::DpStSpeedConfig* release_dp_st_speed_config();
  ::acu::planning::DpStSpeedConfig* mutable_dp_st_speed_config();
  void set_allocated_dp_st_speed_config(::acu::planning::DpStSpeedConfig* dp_st_speed_config);

  // optional .acu.planning.QpSplinePathConfig qp_spline_path_config = 4;
  bool has_qp_spline_path_config() const;
  void clear_qp_spline_path_config();
  static const int kQpSplinePathConfigFieldNumber = 4;
  const ::acu::planning::QpSplinePathConfig& qp_spline_path_config() const;
  ::acu::planning::QpSplinePathConfig* release_qp_spline_path_config();
  ::acu::planning::QpSplinePathConfig* mutable_qp_spline_path_config();
  void set_allocated_qp_spline_path_config(::acu::planning::QpSplinePathConfig* qp_spline_path_config);

  // optional .acu.planning.QpStSpeedConfig qp_st_speed_config = 5;
  bool has_qp_st_speed_config() const;
  void clear_qp_st_speed_config();
  static const int kQpStSpeedConfigFieldNumber = 5;
  const ::acu::planning::QpStSpeedConfig& qp_st_speed_config() const;
  ::acu::planning::QpStSpeedConfig* release_qp_st_speed_config();
  ::acu::planning::QpStSpeedConfig* mutable_qp_st_speed_config();
  void set_allocated_qp_st_speed_config(::acu::planning::QpStSpeedConfig* qp_st_speed_config);

  // optional .acu.planning.PolyStSpeedConfig poly_st_speed_config = 6;
  bool has_poly_st_speed_config() const;
  void clear_poly_st_speed_config();
  static const int kPolyStSpeedConfigFieldNumber = 6;
  const ::acu::planning::PolyStSpeedConfig& poly_st_speed_config() const;
  ::acu::planning::PolyStSpeedConfig* release_poly_st_speed_config();
  ::acu::planning::PolyStSpeedConfig* mutable_poly_st_speed_config();
  void set_allocated_poly_st_speed_config(::acu::planning::PolyStSpeedConfig* poly_st_speed_config);

  // optional .acu.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 7;
  bool has_piecewise_jerk_path_config() const;
  void clear_piecewise_jerk_path_config();
  static const int kPiecewiseJerkPathConfigFieldNumber = 7;
  const ::acu::planning::PiecewiseJerkPathConfig& piecewise_jerk_path_config() const;
  ::acu::planning::PiecewiseJerkPathConfig* release_piecewise_jerk_path_config();
  ::acu::planning::PiecewiseJerkPathConfig* mutable_piecewise_jerk_path_config();
  void set_allocated_piecewise_jerk_path_config(::acu::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config);

  // optional .acu.planning.PathBoundsDeciderConfig path_bounds_decider_config = 8;
  bool has_path_bounds_decider_config() const;
  void clear_path_bounds_decider_config();
  static const int kPathBoundsDeciderConfigFieldNumber = 8;
  const ::acu::planning::PathBoundsDeciderConfig& path_bounds_decider_config() const;
  ::acu::planning::PathBoundsDeciderConfig* release_path_bounds_decider_config();
  ::acu::planning::PathBoundsDeciderConfig* mutable_path_bounds_decider_config();
  void set_allocated_path_bounds_decider_config(::acu::planning::PathBoundsDeciderConfig* path_bounds_decider_config);

  // optional .acu.planning.QuasiPotentialFieldPathConfig quasi_potential_field_path_config = 9;
  bool has_quasi_potential_field_path_config() const;
  void clear_quasi_potential_field_path_config();
  static const int kQuasiPotentialFieldPathConfigFieldNumber = 9;
  const ::acu::planning::QuasiPotentialFieldPathConfig& quasi_potential_field_path_config() const;
  ::acu::planning::QuasiPotentialFieldPathConfig* release_quasi_potential_field_path_config();
  ::acu::planning::QuasiPotentialFieldPathConfig* mutable_quasi_potential_field_path_config();
  void set_allocated_quasi_potential_field_path_config(::acu::planning::QuasiPotentialFieldPathConfig* quasi_potential_field_path_config);

  // @@protoc_insertion_point(class_scope:acu.planning.PlannerConfig)
 private:
  void set_has_dp_poly_path_config();
  void clear_has_dp_poly_path_config();
  void set_has_dp_st_speed_config();
  void clear_has_dp_st_speed_config();
  void set_has_qp_spline_path_config();
  void clear_has_qp_spline_path_config();
  void set_has_qp_st_speed_config();
  void clear_has_qp_st_speed_config();
  void set_has_poly_st_speed_config();
  void clear_has_poly_st_speed_config();
  void set_has_piecewise_jerk_path_config();
  void clear_has_piecewise_jerk_path_config();
  void set_has_path_bounds_decider_config();
  void clear_has_path_bounds_decider_config();
  void set_has_quasi_potential_field_path_config();
  void clear_has_quasi_potential_field_path_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> task_;
  ::acu::planning::DpPolyPathConfig* dp_poly_path_config_;
  ::acu::planning::DpStSpeedConfig* dp_st_speed_config_;
  ::acu::planning::QpSplinePathConfig* qp_spline_path_config_;
  ::acu::planning::QpStSpeedConfig* qp_st_speed_config_;
  ::acu::planning::PolyStSpeedConfig* poly_st_speed_config_;
  ::acu::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config_;
  ::acu::planning::PathBoundsDeciderConfig* path_bounds_decider_config_;
  ::acu::planning::QuasiPotentialFieldPathConfig* quasi_potential_field_path_config_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsPlannerConfigImpl();
};
// -------------------------------------------------------------------

class PlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.PlanningConfig) */ {
 public:
  PlanningConfig();
  virtual ~PlanningConfig();

  PlanningConfig(const PlanningConfig& from);

  inline PlanningConfig& operator=(const PlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningConfig(PlanningConfig&& from) noexcept
    : PlanningConfig() {
    *this = ::std::move(from);
  }

  inline PlanningConfig& operator=(PlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningConfig* internal_default_instance() {
    return reinterpret_cast<const PlanningConfig*>(
               &_PlanningConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PlanningConfig* other);
  friend void swap(PlanningConfig& a, PlanningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningConfig& from);
  void MergeFrom(const PlanningConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PlanningConfig_PlannerType PlannerType;
  static const PlannerType PATH =
    PlanningConfig_PlannerType_PATH;
  static const PlannerType SPEED =
    PlanningConfig_PlannerType_SPEED;
  static inline bool PlannerType_IsValid(int value) {
    return PlanningConfig_PlannerType_IsValid(value);
  }
  static const PlannerType PlannerType_MIN =
    PlanningConfig_PlannerType_PlannerType_MIN;
  static const PlannerType PlannerType_MAX =
    PlanningConfig_PlannerType_PlannerType_MAX;
  static const int PlannerType_ARRAYSIZE =
    PlanningConfig_PlannerType_PlannerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlannerType_descriptor() {
    return PlanningConfig_PlannerType_descriptor();
  }
  static inline const ::std::string& PlannerType_Name(PlannerType value) {
    return PlanningConfig_PlannerType_Name(value);
  }
  static inline bool PlannerType_Parse(const ::std::string& name,
      PlannerType* value) {
    return PlanningConfig_PlannerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .acu.planning.PlannerConfig planner_config = 2;
  bool has_planner_config() const;
  void clear_planner_config();
  static const int kPlannerConfigFieldNumber = 2;
  const ::acu::planning::PlannerConfig& planner_config() const;
  ::acu::planning::PlannerConfig* release_planner_config();
  ::acu::planning::PlannerConfig* mutable_planner_config();
  void set_allocated_planner_config(::acu::planning::PlannerConfig* planner_config);

  // optional .acu.planning.PlanningConfig.PlannerType planner_type = 1 [default = PATH];
  bool has_planner_type() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::acu::planning::PlanningConfig_PlannerType planner_type() const;
  void set_planner_type(::acu::planning::PlanningConfig_PlannerType value);

  // @@protoc_insertion_point(class_scope:acu.planning.PlanningConfig)
 private:
  void set_has_planner_type();
  void clear_has_planner_type();
  void set_has_planner_config();
  void clear_has_planner_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::planning::PlannerConfig* planner_config_;
  int planner_type_;
  friend struct ::protobuf_planning_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planning_5fconfig_2eproto::InitDefaultsPlanningConfigImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PiecewiseJerkPathConfig

// optional .acu.planning.PiecewiseJerkPathWeights default_path_config = 1;
inline bool PiecewiseJerkPathConfig::has_default_path_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PiecewiseJerkPathConfig::set_has_default_path_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PiecewiseJerkPathConfig::clear_has_default_path_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PiecewiseJerkPathConfig::clear_default_path_config() {
  if (default_path_config_ != NULL) default_path_config_->Clear();
  clear_has_default_path_config();
}
inline const ::acu::planning::PiecewiseJerkPathWeights& PiecewiseJerkPathConfig::default_path_config() const {
  const ::acu::planning::PiecewiseJerkPathWeights* p = default_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathConfig.default_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PiecewiseJerkPathWeights*>(
      &::acu::planning::_PiecewiseJerkPathWeights_default_instance_);
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::release_default_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PiecewiseJerkPathConfig.default_path_config)
  clear_has_default_path_config();
  ::acu::planning::PiecewiseJerkPathWeights* temp = default_path_config_;
  default_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::mutable_default_path_config() {
  set_has_default_path_config();
  if (default_path_config_ == NULL) {
    default_path_config_ = new ::acu::planning::PiecewiseJerkPathWeights;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PiecewiseJerkPathConfig.default_path_config)
  return default_path_config_;
}
inline void PiecewiseJerkPathConfig::set_allocated_default_path_config(::acu::planning::PiecewiseJerkPathWeights* default_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete default_path_config_;
  }
  if (default_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      default_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_path_config, submessage_arena);
    }
    set_has_default_path_config();
  } else {
    clear_has_default_path_config();
  }
  default_path_config_ = default_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PiecewiseJerkPathConfig.default_path_config)
}

// optional .acu.planning.PiecewiseJerkPathWeights lane_change_path_config = 2;
inline bool PiecewiseJerkPathConfig::has_lane_change_path_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PiecewiseJerkPathConfig::set_has_lane_change_path_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PiecewiseJerkPathConfig::clear_has_lane_change_path_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PiecewiseJerkPathConfig::clear_lane_change_path_config() {
  if (lane_change_path_config_ != NULL) lane_change_path_config_->Clear();
  clear_has_lane_change_path_config();
}
inline const ::acu::planning::PiecewiseJerkPathWeights& PiecewiseJerkPathConfig::lane_change_path_config() const {
  const ::acu::planning::PiecewiseJerkPathWeights* p = lane_change_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathConfig.lane_change_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PiecewiseJerkPathWeights*>(
      &::acu::planning::_PiecewiseJerkPathWeights_default_instance_);
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::release_lane_change_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PiecewiseJerkPathConfig.lane_change_path_config)
  clear_has_lane_change_path_config();
  ::acu::planning::PiecewiseJerkPathWeights* temp = lane_change_path_config_;
  lane_change_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::mutable_lane_change_path_config() {
  set_has_lane_change_path_config();
  if (lane_change_path_config_ == NULL) {
    lane_change_path_config_ = new ::acu::planning::PiecewiseJerkPathWeights;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PiecewiseJerkPathConfig.lane_change_path_config)
  return lane_change_path_config_;
}
inline void PiecewiseJerkPathConfig::set_allocated_lane_change_path_config(::acu::planning::PiecewiseJerkPathWeights* lane_change_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_change_path_config_;
  }
  if (lane_change_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_change_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_change_path_config, submessage_arena);
    }
    set_has_lane_change_path_config();
  } else {
    clear_has_lane_change_path_config();
  }
  lane_change_path_config_ = lane_change_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PiecewiseJerkPathConfig.lane_change_path_config)
}

// optional .acu.planning.PiecewiseJerkPathWeights start_from_road_side_config = 3;
inline bool PiecewiseJerkPathConfig::has_start_from_road_side_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PiecewiseJerkPathConfig::set_has_start_from_road_side_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PiecewiseJerkPathConfig::clear_has_start_from_road_side_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PiecewiseJerkPathConfig::clear_start_from_road_side_config() {
  if (start_from_road_side_config_ != NULL) start_from_road_side_config_->Clear();
  clear_has_start_from_road_side_config();
}
inline const ::acu::planning::PiecewiseJerkPathWeights& PiecewiseJerkPathConfig::start_from_road_side_config() const {
  const ::acu::planning::PiecewiseJerkPathWeights* p = start_from_road_side_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathConfig.start_from_road_side_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PiecewiseJerkPathWeights*>(
      &::acu::planning::_PiecewiseJerkPathWeights_default_instance_);
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::release_start_from_road_side_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PiecewiseJerkPathConfig.start_from_road_side_config)
  clear_has_start_from_road_side_config();
  ::acu::planning::PiecewiseJerkPathWeights* temp = start_from_road_side_config_;
  start_from_road_side_config_ = NULL;
  return temp;
}
inline ::acu::planning::PiecewiseJerkPathWeights* PiecewiseJerkPathConfig::mutable_start_from_road_side_config() {
  set_has_start_from_road_side_config();
  if (start_from_road_side_config_ == NULL) {
    start_from_road_side_config_ = new ::acu::planning::PiecewiseJerkPathWeights;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PiecewiseJerkPathConfig.start_from_road_side_config)
  return start_from_road_side_config_;
}
inline void PiecewiseJerkPathConfig::set_allocated_start_from_road_side_config(::acu::planning::PiecewiseJerkPathWeights* start_from_road_side_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_from_road_side_config_;
  }
  if (start_from_road_side_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_from_road_side_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_from_road_side_config, submessage_arena);
    }
    set_has_start_from_road_side_config();
  } else {
    clear_has_start_from_road_side_config();
  }
  start_from_road_side_config_ = start_from_road_side_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PiecewiseJerkPathConfig.start_from_road_side_config)
}

// -------------------------------------------------------------------

// PiecewiseJerkPathWeights

// optional double l_weight = 1 [default = 1];
inline bool PiecewiseJerkPathWeights::has_l_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_l_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PiecewiseJerkPathWeights::clear_has_l_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PiecewiseJerkPathWeights::clear_l_weight() {
  l_weight_ = 1;
  clear_has_l_weight();
}
inline double PiecewiseJerkPathWeights::l_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.l_weight)
  return l_weight_;
}
inline void PiecewiseJerkPathWeights::set_l_weight(double value) {
  set_has_l_weight();
  l_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.l_weight)
}

// optional double dl_weight = 2 [default = 100];
inline bool PiecewiseJerkPathWeights::has_dl_weight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_dl_weight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PiecewiseJerkPathWeights::clear_has_dl_weight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PiecewiseJerkPathWeights::clear_dl_weight() {
  dl_weight_ = 100;
  clear_has_dl_weight();
}
inline double PiecewiseJerkPathWeights::dl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.dl_weight)
  return dl_weight_;
}
inline void PiecewiseJerkPathWeights::set_dl_weight(double value) {
  set_has_dl_weight();
  dl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.dl_weight)
}

// optional double ddl_weight = 3 [default = 1000];
inline bool PiecewiseJerkPathWeights::has_ddl_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_ddl_weight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PiecewiseJerkPathWeights::clear_has_ddl_weight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PiecewiseJerkPathWeights::clear_ddl_weight() {
  ddl_weight_ = 1000;
  clear_has_ddl_weight();
}
inline double PiecewiseJerkPathWeights::ddl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.ddl_weight)
  return ddl_weight_;
}
inline void PiecewiseJerkPathWeights::set_ddl_weight(double value) {
  set_has_ddl_weight();
  ddl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.ddl_weight)
}

// optional double dddl_weight = 4 [default = 10000];
inline bool PiecewiseJerkPathWeights::has_dddl_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_dddl_weight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PiecewiseJerkPathWeights::clear_has_dddl_weight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PiecewiseJerkPathWeights::clear_dddl_weight() {
  dddl_weight_ = 10000;
  clear_has_dddl_weight();
}
inline double PiecewiseJerkPathWeights::dddl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.dddl_weight)
  return dddl_weight_;
}
inline void PiecewiseJerkPathWeights::set_dddl_weight(double value) {
  set_has_dddl_weight();
  dddl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.dddl_weight)
}

// optional double obstacle_weight = 5 [default = 50];
inline bool PiecewiseJerkPathWeights::has_obstacle_weight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_obstacle_weight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PiecewiseJerkPathWeights::clear_has_obstacle_weight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PiecewiseJerkPathWeights::clear_obstacle_weight() {
  obstacle_weight_ = 50;
  clear_has_obstacle_weight();
}
inline double PiecewiseJerkPathWeights::obstacle_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.obstacle_weight)
  return obstacle_weight_;
}
inline void PiecewiseJerkPathWeights::set_obstacle_weight(double value) {
  set_has_obstacle_weight();
  obstacle_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.obstacle_weight)
}

// optional double dynamic_obstacle_weight = 6 [default = 0];
inline bool PiecewiseJerkPathWeights::has_dynamic_obstacle_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_dynamic_obstacle_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PiecewiseJerkPathWeights::clear_has_dynamic_obstacle_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PiecewiseJerkPathWeights::clear_dynamic_obstacle_weight() {
  dynamic_obstacle_weight_ = 0;
  clear_has_dynamic_obstacle_weight();
}
inline double PiecewiseJerkPathWeights::dynamic_obstacle_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.dynamic_obstacle_weight)
  return dynamic_obstacle_weight_;
}
inline void PiecewiseJerkPathWeights::set_dynamic_obstacle_weight(double value) {
  set_has_dynamic_obstacle_weight();
  dynamic_obstacle_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.dynamic_obstacle_weight)
}

// optional double dotted_line_weight = 7 [default = 0];
inline bool PiecewiseJerkPathWeights::has_dotted_line_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_dotted_line_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PiecewiseJerkPathWeights::clear_has_dotted_line_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PiecewiseJerkPathWeights::clear_dotted_line_weight() {
  dotted_line_weight_ = 0;
  clear_has_dotted_line_weight();
}
inline double PiecewiseJerkPathWeights::dotted_line_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.dotted_line_weight)
  return dotted_line_weight_;
}
inline void PiecewiseJerkPathWeights::set_dotted_line_weight(double value) {
  set_has_dotted_line_weight();
  dotted_line_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.dotted_line_weight)
}

// optional double solid_line_weight = 8 [default = 0];
inline bool PiecewiseJerkPathWeights::has_solid_line_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_solid_line_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PiecewiseJerkPathWeights::clear_has_solid_line_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PiecewiseJerkPathWeights::clear_solid_line_weight() {
  solid_line_weight_ = 0;
  clear_has_solid_line_weight();
}
inline double PiecewiseJerkPathWeights::solid_line_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.solid_line_weight)
  return solid_line_weight_;
}
inline void PiecewiseJerkPathWeights::set_solid_line_weight(double value) {
  set_has_solid_line_weight();
  solid_line_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.solid_line_weight)
}

// optional double curb_weight = 9 [default = 0];
inline bool PiecewiseJerkPathWeights::has_curb_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PiecewiseJerkPathWeights::set_has_curb_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PiecewiseJerkPathWeights::clear_has_curb_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PiecewiseJerkPathWeights::clear_curb_weight() {
  curb_weight_ = 0;
  clear_has_curb_weight();
}
inline double PiecewiseJerkPathWeights::curb_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.PiecewiseJerkPathWeights.curb_weight)
  return curb_weight_;
}
inline void PiecewiseJerkPathWeights::set_curb_weight(double value) {
  set_has_curb_weight();
  curb_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PiecewiseJerkPathWeights.curb_weight)
}

// -------------------------------------------------------------------

// QuasiPotentialFieldPathConfig

// optional .acu.planning.QuasiPotentialFieldPathWeights default_path_config = 1;
inline bool QuasiPotentialFieldPathConfig::has_default_path_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuasiPotentialFieldPathConfig::set_has_default_path_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuasiPotentialFieldPathConfig::clear_has_default_path_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuasiPotentialFieldPathConfig::clear_default_path_config() {
  if (default_path_config_ != NULL) default_path_config_->Clear();
  clear_has_default_path_config();
}
inline const ::acu::planning::QuasiPotentialFieldPathWeights& QuasiPotentialFieldPathConfig::default_path_config() const {
  const ::acu::planning::QuasiPotentialFieldPathWeights* p = default_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathConfig.default_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::QuasiPotentialFieldPathWeights*>(
      &::acu::planning::_QuasiPotentialFieldPathWeights_default_instance_);
}
inline ::acu::planning::QuasiPotentialFieldPathWeights* QuasiPotentialFieldPathConfig::release_default_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.QuasiPotentialFieldPathConfig.default_path_config)
  clear_has_default_path_config();
  ::acu::planning::QuasiPotentialFieldPathWeights* temp = default_path_config_;
  default_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::QuasiPotentialFieldPathWeights* QuasiPotentialFieldPathConfig::mutable_default_path_config() {
  set_has_default_path_config();
  if (default_path_config_ == NULL) {
    default_path_config_ = new ::acu::planning::QuasiPotentialFieldPathWeights;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.QuasiPotentialFieldPathConfig.default_path_config)
  return default_path_config_;
}
inline void QuasiPotentialFieldPathConfig::set_allocated_default_path_config(::acu::planning::QuasiPotentialFieldPathWeights* default_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete default_path_config_;
  }
  if (default_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      default_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_path_config, submessage_arena);
    }
    set_has_default_path_config();
  } else {
    clear_has_default_path_config();
  }
  default_path_config_ = default_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.QuasiPotentialFieldPathConfig.default_path_config)
}

// optional .acu.planning.QuasiPotentialFieldPathWeights start_from_road_side_config = 2;
inline bool QuasiPotentialFieldPathConfig::has_start_from_road_side_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuasiPotentialFieldPathConfig::set_has_start_from_road_side_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuasiPotentialFieldPathConfig::clear_has_start_from_road_side_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuasiPotentialFieldPathConfig::clear_start_from_road_side_config() {
  if (start_from_road_side_config_ != NULL) start_from_road_side_config_->Clear();
  clear_has_start_from_road_side_config();
}
inline const ::acu::planning::QuasiPotentialFieldPathWeights& QuasiPotentialFieldPathConfig::start_from_road_side_config() const {
  const ::acu::planning::QuasiPotentialFieldPathWeights* p = start_from_road_side_config_;
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathConfig.start_from_road_side_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::QuasiPotentialFieldPathWeights*>(
      &::acu::planning::_QuasiPotentialFieldPathWeights_default_instance_);
}
inline ::acu::planning::QuasiPotentialFieldPathWeights* QuasiPotentialFieldPathConfig::release_start_from_road_side_config() {
  // @@protoc_insertion_point(field_release:acu.planning.QuasiPotentialFieldPathConfig.start_from_road_side_config)
  clear_has_start_from_road_side_config();
  ::acu::planning::QuasiPotentialFieldPathWeights* temp = start_from_road_side_config_;
  start_from_road_side_config_ = NULL;
  return temp;
}
inline ::acu::planning::QuasiPotentialFieldPathWeights* QuasiPotentialFieldPathConfig::mutable_start_from_road_side_config() {
  set_has_start_from_road_side_config();
  if (start_from_road_side_config_ == NULL) {
    start_from_road_side_config_ = new ::acu::planning::QuasiPotentialFieldPathWeights;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.QuasiPotentialFieldPathConfig.start_from_road_side_config)
  return start_from_road_side_config_;
}
inline void QuasiPotentialFieldPathConfig::set_allocated_start_from_road_side_config(::acu::planning::QuasiPotentialFieldPathWeights* start_from_road_side_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_from_road_side_config_;
  }
  if (start_from_road_side_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_from_road_side_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_from_road_side_config, submessage_arena);
    }
    set_has_start_from_road_side_config();
  } else {
    clear_has_start_from_road_side_config();
  }
  start_from_road_side_config_ = start_from_road_side_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.QuasiPotentialFieldPathConfig.start_from_road_side_config)
}

// -------------------------------------------------------------------

// QuasiPotentialFieldPathWeights

// optional double l_weight = 1 [default = 1];
inline bool QuasiPotentialFieldPathWeights::has_l_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_l_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_l_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuasiPotentialFieldPathWeights::clear_l_weight() {
  l_weight_ = 1;
  clear_has_l_weight();
}
inline double QuasiPotentialFieldPathWeights::l_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.l_weight)
  return l_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_l_weight(double value) {
  set_has_l_weight();
  l_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.l_weight)
}

// optional double dl_weight = 2 [default = 100];
inline bool QuasiPotentialFieldPathWeights::has_dl_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_dl_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_dl_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuasiPotentialFieldPathWeights::clear_dl_weight() {
  dl_weight_ = 100;
  clear_has_dl_weight();
}
inline double QuasiPotentialFieldPathWeights::dl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.dl_weight)
  return dl_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_dl_weight(double value) {
  set_has_dl_weight();
  dl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.dl_weight)
}

// optional double ddl_weight = 3 [default = 1000];
inline bool QuasiPotentialFieldPathWeights::has_ddl_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_ddl_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_ddl_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuasiPotentialFieldPathWeights::clear_ddl_weight() {
  ddl_weight_ = 1000;
  clear_has_ddl_weight();
}
inline double QuasiPotentialFieldPathWeights::ddl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.ddl_weight)
  return ddl_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_ddl_weight(double value) {
  set_has_ddl_weight();
  ddl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.ddl_weight)
}

// optional double dddl_weight = 4 [default = 10000];
inline bool QuasiPotentialFieldPathWeights::has_dddl_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_dddl_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_dddl_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuasiPotentialFieldPathWeights::clear_dddl_weight() {
  dddl_weight_ = 10000;
  clear_has_dddl_weight();
}
inline double QuasiPotentialFieldPathWeights::dddl_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.dddl_weight)
  return dddl_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_dddl_weight(double value) {
  set_has_dddl_weight();
  dddl_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.dddl_weight)
}

// optional double dotted_line_weight = 5 [default = 5];
inline bool QuasiPotentialFieldPathWeights::has_dotted_line_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_dotted_line_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_dotted_line_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuasiPotentialFieldPathWeights::clear_dotted_line_weight() {
  dotted_line_weight_ = 5;
  clear_has_dotted_line_weight();
}
inline double QuasiPotentialFieldPathWeights::dotted_line_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.dotted_line_weight)
  return dotted_line_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_dotted_line_weight(double value) {
  set_has_dotted_line_weight();
  dotted_line_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.dotted_line_weight)
}

// optional double solid_line_weight = 6 [default = 10];
inline bool QuasiPotentialFieldPathWeights::has_solid_line_weight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_solid_line_weight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_solid_line_weight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QuasiPotentialFieldPathWeights::clear_solid_line_weight() {
  solid_line_weight_ = 10;
  clear_has_solid_line_weight();
}
inline double QuasiPotentialFieldPathWeights::solid_line_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.solid_line_weight)
  return solid_line_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_solid_line_weight(double value) {
  set_has_solid_line_weight();
  solid_line_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.solid_line_weight)
}

// optional double curb_weight = 7 [default = 20];
inline bool QuasiPotentialFieldPathWeights::has_curb_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_curb_weight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_curb_weight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QuasiPotentialFieldPathWeights::clear_curb_weight() {
  curb_weight_ = 20;
  clear_has_curb_weight();
}
inline double QuasiPotentialFieldPathWeights::curb_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.curb_weight)
  return curb_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_curb_weight(double value) {
  set_has_curb_weight();
  curb_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.curb_weight)
}

// optional double obstacle_weight = 8 [default = 20];
inline bool QuasiPotentialFieldPathWeights::has_obstacle_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QuasiPotentialFieldPathWeights::set_has_obstacle_weight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QuasiPotentialFieldPathWeights::clear_has_obstacle_weight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QuasiPotentialFieldPathWeights::clear_obstacle_weight() {
  obstacle_weight_ = 20;
  clear_has_obstacle_weight();
}
inline double QuasiPotentialFieldPathWeights::obstacle_weight() const {
  // @@protoc_insertion_point(field_get:acu.planning.QuasiPotentialFieldPathWeights.obstacle_weight)
  return obstacle_weight_;
}
inline void QuasiPotentialFieldPathWeights::set_obstacle_weight(double value) {
  set_has_obstacle_weight();
  obstacle_weight_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.QuasiPotentialFieldPathWeights.obstacle_weight)
}

// -------------------------------------------------------------------

// PathBoundsDeciderConfig

// optional bool is_lane_borrowing = 1;
inline bool PathBoundsDeciderConfig::has_is_lane_borrowing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_is_lane_borrowing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathBoundsDeciderConfig::clear_has_is_lane_borrowing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathBoundsDeciderConfig::clear_is_lane_borrowing() {
  is_lane_borrowing_ = false;
  clear_has_is_lane_borrowing();
}
inline bool PathBoundsDeciderConfig::is_lane_borrowing() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.is_lane_borrowing)
  return is_lane_borrowing_;
}
inline void PathBoundsDeciderConfig::set_is_lane_borrowing(bool value) {
  set_has_is_lane_borrowing();
  is_lane_borrowing_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.is_lane_borrowing)
}

// optional bool is_pull_over = 2;
inline bool PathBoundsDeciderConfig::has_is_pull_over() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_is_pull_over() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathBoundsDeciderConfig::clear_has_is_pull_over() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathBoundsDeciderConfig::clear_is_pull_over() {
  is_pull_over_ = false;
  clear_has_is_pull_over();
}
inline bool PathBoundsDeciderConfig::is_pull_over() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.is_pull_over)
  return is_pull_over_;
}
inline void PathBoundsDeciderConfig::set_is_pull_over(bool value) {
  set_has_is_pull_over();
  is_pull_over_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.is_pull_over)
}

// optional double pull_over_destination_to_adc_buffer = 3 [default = 25];
inline bool PathBoundsDeciderConfig::has_pull_over_destination_to_adc_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_pull_over_destination_to_adc_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathBoundsDeciderConfig::clear_has_pull_over_destination_to_adc_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathBoundsDeciderConfig::clear_pull_over_destination_to_adc_buffer() {
  pull_over_destination_to_adc_buffer_ = 25;
  clear_has_pull_over_destination_to_adc_buffer();
}
inline double PathBoundsDeciderConfig::pull_over_destination_to_adc_buffer() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.pull_over_destination_to_adc_buffer)
  return pull_over_destination_to_adc_buffer_;
}
inline void PathBoundsDeciderConfig::set_pull_over_destination_to_adc_buffer(double value) {
  set_has_pull_over_destination_to_adc_buffer();
  pull_over_destination_to_adc_buffer_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.pull_over_destination_to_adc_buffer)
}

// optional double pull_over_destination_to_pathend_buffer = 4 [default = 10];
inline bool PathBoundsDeciderConfig::has_pull_over_destination_to_pathend_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_pull_over_destination_to_pathend_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PathBoundsDeciderConfig::clear_has_pull_over_destination_to_pathend_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PathBoundsDeciderConfig::clear_pull_over_destination_to_pathend_buffer() {
  pull_over_destination_to_pathend_buffer_ = 10;
  clear_has_pull_over_destination_to_pathend_buffer();
}
inline double PathBoundsDeciderConfig::pull_over_destination_to_pathend_buffer() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.pull_over_destination_to_pathend_buffer)
  return pull_over_destination_to_pathend_buffer_;
}
inline void PathBoundsDeciderConfig::set_pull_over_destination_to_pathend_buffer(double value) {
  set_has_pull_over_destination_to_pathend_buffer();
  pull_over_destination_to_pathend_buffer_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.pull_over_destination_to_pathend_buffer)
}

// optional double pull_over_road_edge_buffer = 5 [default = 0.15];
inline bool PathBoundsDeciderConfig::has_pull_over_road_edge_buffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_pull_over_road_edge_buffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PathBoundsDeciderConfig::clear_has_pull_over_road_edge_buffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PathBoundsDeciderConfig::clear_pull_over_road_edge_buffer() {
  pull_over_road_edge_buffer_ = 0.15;
  clear_has_pull_over_road_edge_buffer();
}
inline double PathBoundsDeciderConfig::pull_over_road_edge_buffer() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.pull_over_road_edge_buffer)
  return pull_over_road_edge_buffer_;
}
inline void PathBoundsDeciderConfig::set_pull_over_road_edge_buffer(double value) {
  set_has_pull_over_road_edge_buffer();
  pull_over_road_edge_buffer_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.pull_over_road_edge_buffer)
}

// optional double pull_over_approach_lon_distance_adjust_factor = 6 [default = 1.5];
inline bool PathBoundsDeciderConfig::has_pull_over_approach_lon_distance_adjust_factor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PathBoundsDeciderConfig::set_has_pull_over_approach_lon_distance_adjust_factor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PathBoundsDeciderConfig::clear_has_pull_over_approach_lon_distance_adjust_factor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PathBoundsDeciderConfig::clear_pull_over_approach_lon_distance_adjust_factor() {
  pull_over_approach_lon_distance_adjust_factor_ = 1.5;
  clear_has_pull_over_approach_lon_distance_adjust_factor();
}
inline double PathBoundsDeciderConfig::pull_over_approach_lon_distance_adjust_factor() const {
  // @@protoc_insertion_point(field_get:acu.planning.PathBoundsDeciderConfig.pull_over_approach_lon_distance_adjust_factor)
  return pull_over_approach_lon_distance_adjust_factor_;
}
inline void PathBoundsDeciderConfig::set_pull_over_approach_lon_distance_adjust_factor(double value) {
  set_has_pull_over_approach_lon_distance_adjust_factor();
  pull_over_approach_lon_distance_adjust_factor_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PathBoundsDeciderConfig.pull_over_approach_lon_distance_adjust_factor)
}

// -------------------------------------------------------------------

// PlannerConfig

// repeated .acu.planning.TaskType task = 1;
inline int PlannerConfig::task_size() const {
  return task_.size();
}
inline void PlannerConfig::clear_task() {
  task_.Clear();
}
inline ::acu::planning::TaskType PlannerConfig::task(int index) const {
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.task)
  return static_cast< ::acu::planning::TaskType >(task_.Get(index));
}
inline void PlannerConfig::set_task(int index, ::acu::planning::TaskType value) {
  assert(::acu::planning::TaskType_IsValid(value));
  task_.Set(index, value);
  // @@protoc_insertion_point(field_set:acu.planning.PlannerConfig.task)
}
inline void PlannerConfig::add_task(::acu::planning::TaskType value) {
  assert(::acu::planning::TaskType_IsValid(value));
  task_.Add(value);
  // @@protoc_insertion_point(field_add:acu.planning.PlannerConfig.task)
}
inline const ::google::protobuf::RepeatedField<int>&
PlannerConfig::task() const {
  // @@protoc_insertion_point(field_list:acu.planning.PlannerConfig.task)
  return task_;
}
inline ::google::protobuf::RepeatedField<int>*
PlannerConfig::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:acu.planning.PlannerConfig.task)
  return &task_;
}

// optional .acu.planning.DpPolyPathConfig dp_poly_path_config = 2;
inline bool PlannerConfig::has_dp_poly_path_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerConfig::set_has_dp_poly_path_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerConfig::clear_has_dp_poly_path_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::acu::planning::DpPolyPathConfig& PlannerConfig::dp_poly_path_config() const {
  const ::acu::planning::DpPolyPathConfig* p = dp_poly_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.dp_poly_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::DpPolyPathConfig*>(
      &::acu::planning::_DpPolyPathConfig_default_instance_);
}
inline ::acu::planning::DpPolyPathConfig* PlannerConfig::release_dp_poly_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.dp_poly_path_config)
  clear_has_dp_poly_path_config();
  ::acu::planning::DpPolyPathConfig* temp = dp_poly_path_config_;
  dp_poly_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::DpPolyPathConfig* PlannerConfig::mutable_dp_poly_path_config() {
  set_has_dp_poly_path_config();
  if (dp_poly_path_config_ == NULL) {
    dp_poly_path_config_ = new ::acu::planning::DpPolyPathConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.dp_poly_path_config)
  return dp_poly_path_config_;
}
inline void PlannerConfig::set_allocated_dp_poly_path_config(::acu::planning::DpPolyPathConfig* dp_poly_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dp_poly_path_config_);
  }
  if (dp_poly_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dp_poly_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dp_poly_path_config, submessage_arena);
    }
    set_has_dp_poly_path_config();
  } else {
    clear_has_dp_poly_path_config();
  }
  dp_poly_path_config_ = dp_poly_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.dp_poly_path_config)
}

// optional .acu.planning.DpStSpeedConfig dp_st_speed_config = 3;
inline bool PlannerConfig::has_dp_st_speed_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerConfig::set_has_dp_st_speed_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerConfig::clear_has_dp_st_speed_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::acu::planning::DpStSpeedConfig& PlannerConfig::dp_st_speed_config() const {
  const ::acu::planning::DpStSpeedConfig* p = dp_st_speed_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.dp_st_speed_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::DpStSpeedConfig*>(
      &::acu::planning::_DpStSpeedConfig_default_instance_);
}
inline ::acu::planning::DpStSpeedConfig* PlannerConfig::release_dp_st_speed_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.dp_st_speed_config)
  clear_has_dp_st_speed_config();
  ::acu::planning::DpStSpeedConfig* temp = dp_st_speed_config_;
  dp_st_speed_config_ = NULL;
  return temp;
}
inline ::acu::planning::DpStSpeedConfig* PlannerConfig::mutable_dp_st_speed_config() {
  set_has_dp_st_speed_config();
  if (dp_st_speed_config_ == NULL) {
    dp_st_speed_config_ = new ::acu::planning::DpStSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.dp_st_speed_config)
  return dp_st_speed_config_;
}
inline void PlannerConfig::set_allocated_dp_st_speed_config(::acu::planning::DpStSpeedConfig* dp_st_speed_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dp_st_speed_config_);
  }
  if (dp_st_speed_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dp_st_speed_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dp_st_speed_config, submessage_arena);
    }
    set_has_dp_st_speed_config();
  } else {
    clear_has_dp_st_speed_config();
  }
  dp_st_speed_config_ = dp_st_speed_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.dp_st_speed_config)
}

// optional .acu.planning.QpSplinePathConfig qp_spline_path_config = 4;
inline bool PlannerConfig::has_qp_spline_path_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerConfig::set_has_qp_spline_path_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlannerConfig::clear_has_qp_spline_path_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::acu::planning::QpSplinePathConfig& PlannerConfig::qp_spline_path_config() const {
  const ::acu::planning::QpSplinePathConfig* p = qp_spline_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.qp_spline_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::QpSplinePathConfig*>(
      &::acu::planning::_QpSplinePathConfig_default_instance_);
}
inline ::acu::planning::QpSplinePathConfig* PlannerConfig::release_qp_spline_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.qp_spline_path_config)
  clear_has_qp_spline_path_config();
  ::acu::planning::QpSplinePathConfig* temp = qp_spline_path_config_;
  qp_spline_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::QpSplinePathConfig* PlannerConfig::mutable_qp_spline_path_config() {
  set_has_qp_spline_path_config();
  if (qp_spline_path_config_ == NULL) {
    qp_spline_path_config_ = new ::acu::planning::QpSplinePathConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.qp_spline_path_config)
  return qp_spline_path_config_;
}
inline void PlannerConfig::set_allocated_qp_spline_path_config(::acu::planning::QpSplinePathConfig* qp_spline_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(qp_spline_path_config_);
  }
  if (qp_spline_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      qp_spline_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, qp_spline_path_config, submessage_arena);
    }
    set_has_qp_spline_path_config();
  } else {
    clear_has_qp_spline_path_config();
  }
  qp_spline_path_config_ = qp_spline_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.qp_spline_path_config)
}

// optional .acu.planning.QpStSpeedConfig qp_st_speed_config = 5;
inline bool PlannerConfig::has_qp_st_speed_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlannerConfig::set_has_qp_st_speed_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlannerConfig::clear_has_qp_st_speed_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::acu::planning::QpStSpeedConfig& PlannerConfig::qp_st_speed_config() const {
  const ::acu::planning::QpStSpeedConfig* p = qp_st_speed_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.qp_st_speed_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::QpStSpeedConfig*>(
      &::acu::planning::_QpStSpeedConfig_default_instance_);
}
inline ::acu::planning::QpStSpeedConfig* PlannerConfig::release_qp_st_speed_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.qp_st_speed_config)
  clear_has_qp_st_speed_config();
  ::acu::planning::QpStSpeedConfig* temp = qp_st_speed_config_;
  qp_st_speed_config_ = NULL;
  return temp;
}
inline ::acu::planning::QpStSpeedConfig* PlannerConfig::mutable_qp_st_speed_config() {
  set_has_qp_st_speed_config();
  if (qp_st_speed_config_ == NULL) {
    qp_st_speed_config_ = new ::acu::planning::QpStSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.qp_st_speed_config)
  return qp_st_speed_config_;
}
inline void PlannerConfig::set_allocated_qp_st_speed_config(::acu::planning::QpStSpeedConfig* qp_st_speed_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(qp_st_speed_config_);
  }
  if (qp_st_speed_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      qp_st_speed_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, qp_st_speed_config, submessage_arena);
    }
    set_has_qp_st_speed_config();
  } else {
    clear_has_qp_st_speed_config();
  }
  qp_st_speed_config_ = qp_st_speed_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.qp_st_speed_config)
}

// optional .acu.planning.PolyStSpeedConfig poly_st_speed_config = 6;
inline bool PlannerConfig::has_poly_st_speed_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlannerConfig::set_has_poly_st_speed_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlannerConfig::clear_has_poly_st_speed_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::acu::planning::PolyStSpeedConfig& PlannerConfig::poly_st_speed_config() const {
  const ::acu::planning::PolyStSpeedConfig* p = poly_st_speed_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.poly_st_speed_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PolyStSpeedConfig*>(
      &::acu::planning::_PolyStSpeedConfig_default_instance_);
}
inline ::acu::planning::PolyStSpeedConfig* PlannerConfig::release_poly_st_speed_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.poly_st_speed_config)
  clear_has_poly_st_speed_config();
  ::acu::planning::PolyStSpeedConfig* temp = poly_st_speed_config_;
  poly_st_speed_config_ = NULL;
  return temp;
}
inline ::acu::planning::PolyStSpeedConfig* PlannerConfig::mutable_poly_st_speed_config() {
  set_has_poly_st_speed_config();
  if (poly_st_speed_config_ == NULL) {
    poly_st_speed_config_ = new ::acu::planning::PolyStSpeedConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.poly_st_speed_config)
  return poly_st_speed_config_;
}
inline void PlannerConfig::set_allocated_poly_st_speed_config(::acu::planning::PolyStSpeedConfig* poly_st_speed_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(poly_st_speed_config_);
  }
  if (poly_st_speed_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      poly_st_speed_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, poly_st_speed_config, submessage_arena);
    }
    set_has_poly_st_speed_config();
  } else {
    clear_has_poly_st_speed_config();
  }
  poly_st_speed_config_ = poly_st_speed_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.poly_st_speed_config)
}

// optional .acu.planning.PiecewiseJerkPathConfig piecewise_jerk_path_config = 7;
inline bool PlannerConfig::has_piecewise_jerk_path_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlannerConfig::set_has_piecewise_jerk_path_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlannerConfig::clear_has_piecewise_jerk_path_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlannerConfig::clear_piecewise_jerk_path_config() {
  if (piecewise_jerk_path_config_ != NULL) piecewise_jerk_path_config_->Clear();
  clear_has_piecewise_jerk_path_config();
}
inline const ::acu::planning::PiecewiseJerkPathConfig& PlannerConfig::piecewise_jerk_path_config() const {
  const ::acu::planning::PiecewiseJerkPathConfig* p = piecewise_jerk_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.piecewise_jerk_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PiecewiseJerkPathConfig*>(
      &::acu::planning::_PiecewiseJerkPathConfig_default_instance_);
}
inline ::acu::planning::PiecewiseJerkPathConfig* PlannerConfig::release_piecewise_jerk_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.piecewise_jerk_path_config)
  clear_has_piecewise_jerk_path_config();
  ::acu::planning::PiecewiseJerkPathConfig* temp = piecewise_jerk_path_config_;
  piecewise_jerk_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::PiecewiseJerkPathConfig* PlannerConfig::mutable_piecewise_jerk_path_config() {
  set_has_piecewise_jerk_path_config();
  if (piecewise_jerk_path_config_ == NULL) {
    piecewise_jerk_path_config_ = new ::acu::planning::PiecewiseJerkPathConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.piecewise_jerk_path_config)
  return piecewise_jerk_path_config_;
}
inline void PlannerConfig::set_allocated_piecewise_jerk_path_config(::acu::planning::PiecewiseJerkPathConfig* piecewise_jerk_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete piecewise_jerk_path_config_;
  }
  if (piecewise_jerk_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      piecewise_jerk_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, piecewise_jerk_path_config, submessage_arena);
    }
    set_has_piecewise_jerk_path_config();
  } else {
    clear_has_piecewise_jerk_path_config();
  }
  piecewise_jerk_path_config_ = piecewise_jerk_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.piecewise_jerk_path_config)
}

// optional .acu.planning.PathBoundsDeciderConfig path_bounds_decider_config = 8;
inline bool PlannerConfig::has_path_bounds_decider_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlannerConfig::set_has_path_bounds_decider_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlannerConfig::clear_has_path_bounds_decider_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlannerConfig::clear_path_bounds_decider_config() {
  if (path_bounds_decider_config_ != NULL) path_bounds_decider_config_->Clear();
  clear_has_path_bounds_decider_config();
}
inline const ::acu::planning::PathBoundsDeciderConfig& PlannerConfig::path_bounds_decider_config() const {
  const ::acu::planning::PathBoundsDeciderConfig* p = path_bounds_decider_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.path_bounds_decider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PathBoundsDeciderConfig*>(
      &::acu::planning::_PathBoundsDeciderConfig_default_instance_);
}
inline ::acu::planning::PathBoundsDeciderConfig* PlannerConfig::release_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.path_bounds_decider_config)
  clear_has_path_bounds_decider_config();
  ::acu::planning::PathBoundsDeciderConfig* temp = path_bounds_decider_config_;
  path_bounds_decider_config_ = NULL;
  return temp;
}
inline ::acu::planning::PathBoundsDeciderConfig* PlannerConfig::mutable_path_bounds_decider_config() {
  set_has_path_bounds_decider_config();
  if (path_bounds_decider_config_ == NULL) {
    path_bounds_decider_config_ = new ::acu::planning::PathBoundsDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.path_bounds_decider_config)
  return path_bounds_decider_config_;
}
inline void PlannerConfig::set_allocated_path_bounds_decider_config(::acu::planning::PathBoundsDeciderConfig* path_bounds_decider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_bounds_decider_config_;
  }
  if (path_bounds_decider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path_bounds_decider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path_bounds_decider_config, submessage_arena);
    }
    set_has_path_bounds_decider_config();
  } else {
    clear_has_path_bounds_decider_config();
  }
  path_bounds_decider_config_ = path_bounds_decider_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.path_bounds_decider_config)
}

// optional .acu.planning.QuasiPotentialFieldPathConfig quasi_potential_field_path_config = 9;
inline bool PlannerConfig::has_quasi_potential_field_path_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlannerConfig::set_has_quasi_potential_field_path_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlannerConfig::clear_has_quasi_potential_field_path_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlannerConfig::clear_quasi_potential_field_path_config() {
  if (quasi_potential_field_path_config_ != NULL) quasi_potential_field_path_config_->Clear();
  clear_has_quasi_potential_field_path_config();
}
inline const ::acu::planning::QuasiPotentialFieldPathConfig& PlannerConfig::quasi_potential_field_path_config() const {
  const ::acu::planning::QuasiPotentialFieldPathConfig* p = quasi_potential_field_path_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlannerConfig.quasi_potential_field_path_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::QuasiPotentialFieldPathConfig*>(
      &::acu::planning::_QuasiPotentialFieldPathConfig_default_instance_);
}
inline ::acu::planning::QuasiPotentialFieldPathConfig* PlannerConfig::release_quasi_potential_field_path_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlannerConfig.quasi_potential_field_path_config)
  clear_has_quasi_potential_field_path_config();
  ::acu::planning::QuasiPotentialFieldPathConfig* temp = quasi_potential_field_path_config_;
  quasi_potential_field_path_config_ = NULL;
  return temp;
}
inline ::acu::planning::QuasiPotentialFieldPathConfig* PlannerConfig::mutable_quasi_potential_field_path_config() {
  set_has_quasi_potential_field_path_config();
  if (quasi_potential_field_path_config_ == NULL) {
    quasi_potential_field_path_config_ = new ::acu::planning::QuasiPotentialFieldPathConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlannerConfig.quasi_potential_field_path_config)
  return quasi_potential_field_path_config_;
}
inline void PlannerConfig::set_allocated_quasi_potential_field_path_config(::acu::planning::QuasiPotentialFieldPathConfig* quasi_potential_field_path_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quasi_potential_field_path_config_;
  }
  if (quasi_potential_field_path_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quasi_potential_field_path_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quasi_potential_field_path_config, submessage_arena);
    }
    set_has_quasi_potential_field_path_config();
  } else {
    clear_has_quasi_potential_field_path_config();
  }
  quasi_potential_field_path_config_ = quasi_potential_field_path_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlannerConfig.quasi_potential_field_path_config)
}

// -------------------------------------------------------------------

// PlanningConfig

// optional .acu.planning.PlanningConfig.PlannerType planner_type = 1 [default = PATH];
inline bool PlanningConfig::has_planner_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningConfig::set_has_planner_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningConfig::clear_has_planner_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningConfig::clear_planner_type() {
  planner_type_ = 0;
  clear_has_planner_type();
}
inline ::acu::planning::PlanningConfig_PlannerType PlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_get:acu.planning.PlanningConfig.planner_type)
  return static_cast< ::acu::planning::PlanningConfig_PlannerType >(planner_type_);
}
inline void PlanningConfig::set_planner_type(::acu::planning::PlanningConfig_PlannerType value) {
  assert(::acu::planning::PlanningConfig_PlannerType_IsValid(value));
  set_has_planner_type();
  planner_type_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.PlanningConfig.planner_type)
}

// optional .acu.planning.PlannerConfig planner_config = 2;
inline bool PlanningConfig::has_planner_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningConfig::set_has_planner_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningConfig::clear_has_planner_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningConfig::clear_planner_config() {
  if (planner_config_ != NULL) planner_config_->Clear();
  clear_has_planner_config();
}
inline const ::acu::planning::PlannerConfig& PlanningConfig::planner_config() const {
  const ::acu::planning::PlannerConfig* p = planner_config_;
  // @@protoc_insertion_point(field_get:acu.planning.PlanningConfig.planner_config)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::PlannerConfig*>(
      &::acu::planning::_PlannerConfig_default_instance_);
}
inline ::acu::planning::PlannerConfig* PlanningConfig::release_planner_config() {
  // @@protoc_insertion_point(field_release:acu.planning.PlanningConfig.planner_config)
  clear_has_planner_config();
  ::acu::planning::PlannerConfig* temp = planner_config_;
  planner_config_ = NULL;
  return temp;
}
inline ::acu::planning::PlannerConfig* PlanningConfig::mutable_planner_config() {
  set_has_planner_config();
  if (planner_config_ == NULL) {
    planner_config_ = new ::acu::planning::PlannerConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.PlanningConfig.planner_config)
  return planner_config_;
}
inline void PlanningConfig::set_allocated_planner_config(::acu::planning::PlannerConfig* planner_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planner_config_;
  }
  if (planner_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planner_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planner_config, submessage_arena);
    }
    set_has_planner_config();
  } else {
    clear_has_planner_config();
  }
  planner_config_ = planner_config;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.PlanningConfig.planner_config)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace acu

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::acu::planning::PlanningConfig_PlannerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::planning::PlanningConfig_PlannerType>() {
  return ::acu::planning::PlanningConfig_PlannerType_descriptor();
}
template <> struct is_proto_enum< ::acu::planning::TaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::planning::TaskType>() {
  return ::acu::planning::TaskType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planning_5fconfig_2eproto__INCLUDED
