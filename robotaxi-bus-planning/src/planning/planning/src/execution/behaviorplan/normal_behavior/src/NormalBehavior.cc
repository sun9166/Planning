/*
 * this file was generated by NunniFSMGen
 */


#include "src/execution/behaviorplan/normal_behavior/include/NormalBehavior.h"
#include "src/algorithm/interface/force_avoid/include/force_avoid.h"
#include "src/algorithm/interface/forward_avoid/include/forward_avoid.h"
#include "src/algorithm/interface/back_avoid/include/back_avoid.h"
#include "common/common_define/error_code_define.h"
#include "common/base/log/include/log.h"
namespace acu{
namespace planning{



NormalBehavior::NormalBehavior() {}


NormalBehavior::NormalBehavior( void *o ) {}


NormalBehavior::~NormalBehavior() {}


//0 success  1 busy  -1 error 2 idle
eCheckAlgthmResult NormalBehavior::CheckThreadResult(eComputeThreadType type_detect) {
    auto thread_pool = ThreadPool::Instance();
    eThreadStatus thread_state = thread_pool->CheckThreadState(ePlanningThread::COMPUTE_THREAD_ID);
    DataPool* DP = DataPool::Instance();

    if (DP->GetMainDataPtr()->compute_thread_type.type != type_detect &&
        thread_state == eThreadStatus::BUSY) {
        AINFO << "CheckOtherThreadResult BUSY " << DP->GetMainDataPtr()->compute_thread_type.str_type;
        return eCheckAlgthmResult::ERROR;
    }
    if (DP->GetMainDataPtr()->compute_thread_type.type == type_detect &&
        thread_state == eThreadStatus::BUSY) {
        AINFO << "CheckCurrentThreadResult BUSY " << DP->GetMainDataPtr()->compute_thread_type.str_type;
        return eCheckAlgthmResult::BUSY;
    }
    if (DP->GetMainDataPtr()->compute_thread_type.type != type_detect &&
        thread_state == eThreadStatus::WAITING) {
        DP->GetMainDataPtr()->compute_thread_type.Reset();
        // thread_pool->ResetThreadStatus(ePlanningThread::COMPUTE_THREAD_ID);
        return eCheckAlgthmResult::IDLE;
    }
    if (DP->GetMainDataPtr()->compute_thread_type.type == type_detect &&
        thread_state == eThreadStatus::WAITING) {
        AINFO << "CheckThreadResult success " << DP->GetMainDataPtr()->compute_thread_type.str_type;
        DP->GetMainDataPtr()->compute_thread_type.Reset();
        // thread_pool->ResetThreadStatus(ePlanningThread::COMPUTE_THREAD_ID);
        return eCheckAlgthmResult::SUCCESS;
    }
    if (thread_state == eThreadStatus::BUSY) {
        AINFO << "CheckThreadResult  BUSY  " << DP->GetMainDataPtr()->compute_thread_type.str_type;
        return eCheckAlgthmResult::ERROR;
    }
    return eCheckAlgthmResult::IDLE;
}

bool NormalBehavior::RunDwaInThread() {
    auto thread_pool = ThreadPool::Instance();
    if (thread_pool == nullptr) return false;
    //prepare env
    DataPool* DP = DataPool::Instance();
    DP->GetMainDataPtr()->compute_thread_type.SetPlannerDwaAvoid();
    DP->BakComputeThreadData();
    const auto work = [&]() {
        DataPool* DP = DataPool::Instance();
        DwaConfig dwa_config;
        dwa_config.car_model = DP->GetSwapComputeDateRef().car_model;
        dwa_config.risk_mode_enable = false; //DP->GetSwapComputeDateRef().car_status.risk_mode_enable;
        dwa_config.is_final_adjust = DP->GetSwapComputeDateRef().is_final_adjust;
        std::shared_ptr<DwaPlanner> dwa_avoid_ptr =  std::make_shared<DwaPlanner>();
        dwa_avoid_ptr->SetDwaConfig(dwa_config);
        int result = dwa_avoid_ptr->GenerateDwaPath(
                       DP->GetSwapComputeDateRef().localization_data,
                       DP->GetSwapComputeDateRef().paths,
                       DP->GetSwapComputeDateRef().cognition_info.unstruct_env_info,
                       DP->GetSwapComputeDateRef().result_path);
      return result;
    };
    if (thread_pool->AddThreadWork(ePlanningThread::COMPUTE_THREAD_ID, work ) == -1) {
      AERROR << "add work failed ";
    }
    return true;
}

bool NormalBehavior::RunAstarInThread() {
    auto thread_pool = ThreadPool::Instance();
    if (thread_pool == nullptr) return false;
    //prepare env
    DataPool* DP = DataPool::Instance();
    DP->GetMainDataPtr()->compute_thread_type.SetPlannerAstarAvoid();
    DP->BakComputeThreadData();
    const auto work = [&]() {
        AERROR << "RunAstarInThread";
        DataPool* DP = DataPool::Instance();
        // set basic config
        AstarAvoidConfig astar_avoid_config;
        astar_avoid_config.car_model = DP->GetSwapComputeDateRef().car_model;
        astar_avoid_config.is_final_adjust = DP->GetSwapComputeDateRef().is_final_adjust;
        bool emergency_flag = DP->GetSwapComputeDateRef().cognition_info.unstruct_env_info.semantic_info.IsEmergencyTimeUp();
        if (emergency_flag) {
            astar_avoid_config.use_ultra = true;
        } else {
            astar_avoid_config.use_ultra = true;
        }
        // set alogorithm
        DP->GetSwapComputeDateRef().ASTAR_message.Reset();
        DP->GetSwapComputeDateRef().astar_avoid_ptr = std::make_shared<acu::astar_interface::AstarAvoid>();
        DP->GetSwapComputeDateRef().astar_avoid_ptr->SetAstarAvoidConfig(astar_avoid_config);
        int result = DP->GetSwapComputeDateRef().astar_avoid_ptr->GenerateAstarPath(
                             DP->GetSwapComputeDateRef().localization_data,
                             DP->GetSwapComputeDateRef().paths,
                             DP->GetSwapComputeDateRef().cognition_info.unstruct_env_info,
                             DP->GetSwapComputeDateRef().result_path);
        AERROR << "ASTAR RESULT:" << result;
        return result;
    };
    if (thread_pool->AddThreadWork(ePlanningThread::COMPUTE_THREAD_ID, work ) == -1) {
      AERROR << "add work failed ";
    }
    return true;
}

//0 success  1 busy  -1 error -2 other
eComputeResult NormalBehavior::CheckDwaAvoidInThread(PathData &new_path, DebugPlanningMsg &debug_msg) {
    DataPool* DP = DataPool::Instance();
    auto thread_pool = ThreadPool::Instance();
    eCheckAlgthmResult result = CheckThreadResult(eComputeThreadType::PLANNER_DWA_AVOID);
    int ret = -1;
    if (result == eCheckAlgthmResult::IDLE) {
        RunDwaInThread();
        // RunAstarInThread();
        return eComputeResult::BUSY;
    }
    if (result == eCheckAlgthmResult::ERROR) {
        // CT->InformThreadStop();
        return eComputeResult::OTHER;
    }
    if (result == eCheckAlgthmResult::SUCCESS) {
        debug_msg.DWA_message = DP->GetSwapComputeDateRef().DWA_message;
        ret = thread_pool->GetWorkReturnValue(ePlanningThread::COMPUTE_THREAD_ID);
        thread_pool->ResetThreadStatus(ePlanningThread::COMPUTE_THREAD_ID);
        if (ret == -1) {  //fail
            AERROR << "dwa fault";
            return eComputeResult::ERROR;
        } else {
            new_path = DP->GetSwapComputeDateRef().result_path;
            new_path.is_new = true;
            return eComputeResult::SUCCESS;
        }
    }
    return eComputeResult::BUSY;
}

//0 success  1 busy  -1 error -2 other
eComputeResult NormalBehavior::CheckAstarAvoidInThread(PathData &new_path, DebugPlanningMsg &debug_msg) {
    DataPool* DP = DataPool::Instance();
    auto thread_pool = ThreadPool::Instance();
    eCheckAlgthmResult result = CheckThreadResult(eComputeThreadType::PLANNER_ASTAR_AVOID);
    int ret = -1;
    if (result == eCheckAlgthmResult::IDLE) {
        // RunDwaInThread();
        RunAstarInThread();
        return eComputeResult::BUSY;
    }
    if (result == eCheckAlgthmResult::ERROR) {
        // CT->InformThreadStop();
        return eComputeResult::OTHER;
    }
    if (result == eCheckAlgthmResult::SUCCESS) {
        debug_msg.ASTAR_message = DP->GetSwapComputeDateRef().ASTAR_message;
        ret = thread_pool->GetWorkReturnValue(ePlanningThread::COMPUTE_THREAD_ID);
        thread_pool->ResetThreadStatus(ePlanningThread::COMPUTE_THREAD_ID);
        if (ret == -1) {  //fail
            AERROR << "astar fault";
            return eComputeResult::ERROR;
        } else {
            new_path = DP->GetSwapComputeDateRef().result_path;
            new_path.is_new = true;
            return eComputeResult::SUCCESS;
        }
    }
    return eComputeResult::BUSY;
}

bool NormalBehavior::IdleFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] IdleFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetIdle();
    behavior_fsm_param->debug_planning_msg.SetIdleFunc();
    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    if (behavior_fsm_param == nullptr) {
        AERROR << "behavior_fsm_param is nullptr";
        return false;
    }
    AINFO << "make DummyAlgorithm";
    if (behavior_fsm_param->algorithm_ptr == nullptr) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }
    behavior_fsm_param->speedplan_info.pathplannerGo = -1; //idle
    return true;
}


bool NormalBehavior::ForwardFollowingFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] ForwardFollowingFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetForwardFollowing();
    behavior_fsm_param->debug_planning_msg.SetForwardFollowingFunc();
    
    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_dwa.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_dwa_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->semantic_info.ResetFrontCollision();
    behavior_fsm_param->speedplan_info.pathplannerGo = 1; //ForwardFollowing

    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;
    behavior_fsm_param->debug_planning_msg.SetForwardFollowingFunc(
        "path_size:" + std::to_string(behavior_fsm_param->result_path.path.size()));
    if (behavior_fsm_param->algorithm_ptr == nullptr) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }
    return true;
}


bool NormalBehavior::NarrowTurnFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] NarrowTurnFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetNarrowTurn();
    behavior_fsm_param->debug_planning_msg.SetNarrowTurnFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_dwa.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_dwa_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->semantic_info.ResetFrontCollision();
    behavior_fsm_param->speedplan_info.pathplannerGo = 6; //NarrowTurn

    // todo
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;

    return true;
}


bool NormalBehavior::ForceAvoidFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] ForceAvoidFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetForceAvoid();
    behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_dwa.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_dwa_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->semantic_info.ResetFrontCollision();
    behavior_fsm_param->speedplan_info.pathplannerGo = 7; //ForceAvoid

    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::FORCE_AVOID ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<ForceAvoid>();
        AINFO << "make new_ForceAvoid ";
    }
    
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;
    int behavior_algorithm_result = -1;
    if (behavior_fsm_param->algorithm_ptr->IsInitOver() == false) {
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->InitAlgorithm();
        if (behavior_fsm_param->algorithm_ptr->IsNewPath() == true) {
            AINFO << "behavior_fsm_param->culculate_path " << behavior_fsm_param->calculate_path.path.size();
            behavior_fsm_param->algorithm_ptr->GetResult(behavior_fsm_param->calculate_path);
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("get path");
        }
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecutFailed();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("path error");
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetBusyStatus();
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecuting();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("path is generating");
        } else {
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecuting();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("path is generate over");
        }
    } else {
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->CheckAlgorithmState();
        behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            behavior_fsm_param->algorithm_ptr->is_init_over_ = false;
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecutFailed();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("ExecuteFailed");
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecuting();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("Executing...");
        } else {
            behavior_fsm_param->algorithm_ptr->is_init_over_ = false;
            behavior_fsm_param->behavior_fsm_info.force_avoid_status.SetExecutSuccess();
            behavior_fsm_param->debug_planning_msg.SetForceAvoidFunc("Execute ok");
        }
    }
    return true;
}


bool NormalBehavior::SlowDownFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] SlowDownFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetSlowDown();
    behavior_fsm_param->debug_planning_msg.SetSlowDownFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->speedplan_info.pathplannerGo = 3; //SlowDOwn

    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;
    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::DUMMY ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }

    auto thread_pool = ThreadPool::Instance();
    eThreadStatus thread_state = thread_pool->CheckThreadState(ePlanningThread::COMPUTE_THREAD_ID);
    if (thread_state != eThreadStatus::BUSY) {
        behavior_fsm_param->behavior_fsm_info.time_for_dwa.NewTimes();
    }
    if (behavior_fsm_param->behavior_fsm_info.IsNeedCallDwa()) {
        eComputeResult result = CheckDwaAvoidInThread(behavior_fsm_param->calculate_path, behavior_fsm_param->debug_planning_msg);
        if (result == eComputeResult::ERROR) {
            behavior_fsm_param->debug_planning_msg.SetSlowDownFunc("dwa failed");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutFailed();
            AERROR << "DWA FAILED";
        } else if (result == eComputeResult::SUCCESS) {
            behavior_fsm_param->debug_planning_msg.SetSlowDownFunc("dwa success");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutSuccess();
            behavior_fsm_param->semantic_info.ResetResultCollision();
            behavior_fsm_param->algorithm_ptr = std::make_shared<ForwardAvoid>();
            AINFO << "MAKE new ForwardAvoid";
            behavior_fsm_param->algorithm_ptr->is_init_over_ = true;
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
        } else if (result == eComputeResult::BUSY) {
            behavior_fsm_param->debug_planning_msg.SetSlowDownFunc("dwa busy");
            AWARN << "DWA BUSY";
        }
    }
    return true;
}


bool NormalBehavior::BackStayStillFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] BackStayStillFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetBackStayStill();
    behavior_fsm_param->debug_planning_msg.SetBackStayStillFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->speedplan_info.pathplannerGo = -3; //BackStayStill
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;

    if (behavior_fsm_param->behavior_fsm_info.back_stay_still_times.current_times >
        behavior_fsm_param->behavior_config.back_stay_still_failed_times_setting) {
        AERROR << "self is being blocked";
        behavior_fsm_param->exception_analyse_result.AddNodeFault(
            "self is being blocked",
            0,
            DFPLANNING_PLANNING_SOFTWARE_8_ERROR,
            0);
    }

    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::DUMMY ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }
    behavior_fsm_param->debug_planning_msg.SetBackStayStillFunc(
        "BackStayStill path_size:" + std::to_string(behavior_fsm_param->result_path.path.size()) +
        ", time_for_hybrid_atar:" + behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.ToString());
    AINFO << "BackStayStill path_size:" << behavior_fsm_param->result_path.path.size()
          << ", time_for_hybrid_atar:" << behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.ToString();

    auto thread_pool = ThreadPool::Instance();
    eThreadStatus thread_state = thread_pool->CheckThreadState(ePlanningThread::COMPUTE_THREAD_ID);
    if (thread_state != eThreadStatus::BUSY) {
        behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.NewTimes();
    }
    if (behavior_fsm_param->behavior_fsm_info.IsNeedCallHybridAstar()) {
        eComputeResult result = CheckAstarAvoidInThread(behavior_fsm_param->calculate_path, behavior_fsm_param->debug_planning_msg);
        if (result == eComputeResult::ERROR) {
            behavior_fsm_param->debug_planning_msg.SetBackStayStillFunc("Astar failed");
            behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.Reset();
            behavior_fsm_param->behavior_fsm_info.astar_result_status.SetExecutFailed();
            AERROR << "ASTAR FAILED";
        } else if (result == eComputeResult::SUCCESS) {
            behavior_fsm_param->debug_planning_msg.SetBackStayStillFunc("Astar success");
            behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.Reset();
            behavior_fsm_param->behavior_fsm_info.astar_result_status.SetExecutSuccess();
            behavior_fsm_param->semantic_info.ResetResultCollision();
            behavior_fsm_param->algorithm_ptr = std::make_shared<BackAvoid>();
            AINFO << "MAKE new BackAvoid";
            behavior_fsm_param->algorithm_ptr->is_init_over_ = true;
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
        } else if (result == eComputeResult::BUSY) {
            behavior_fsm_param->debug_planning_msg.SetBackStayStillFunc("Astar busy");
            AWARN << "ASTAR BUSY";
        }
    }
    return true;
}


bool NormalBehavior::ForwardStayStillFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] ForwardStayStillFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetForwardStayStill();
    behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc();

     behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.NewTimes();
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->speedplan_info.pathplannerGo = -2; //ForwardStayStill
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;

    behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc(
        "time:" + behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.ToString() +
        ", dwainfo " + behavior_fsm_param->behavior_fsm_info.time_for_dwa.ToString());

    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::DUMMY ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }

    AWARN << "trying   dwa......";
    auto thread_pool = ThreadPool::Instance();
    eThreadStatus thread_state = thread_pool->CheckThreadState(ePlanningThread::COMPUTE_THREAD_ID);
    if (thread_state != eThreadStatus::BUSY) {
        behavior_fsm_param->behavior_fsm_info.time_for_dwa.NewTimes();
    }
    if (behavior_fsm_param->behavior_fsm_info.IsNeedCallDwa()) {
        AWARN << "STARTING   dwa......";
        behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc("trying dwa...");
        eComputeResult result = CheckDwaAvoidInThread(behavior_fsm_param->calculate_path, behavior_fsm_param->debug_planning_msg);
        if (result == eComputeResult::ERROR) {
            behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc("dwa failed");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutFailed();
            AERROR << "DWA FAILED";
        } else if (result == eComputeResult::SUCCESS) {
            behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc("dwa success");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutSuccess();
            behavior_fsm_param->semantic_info.ResetResultCollision();
            behavior_fsm_param->algorithm_ptr = std::make_shared<ForwardAvoid>();
            AINFO << "MAKE new ForwardAvoid";
            behavior_fsm_param->algorithm_ptr->is_init_over_ = true;
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
        } else if (result == eComputeResult::BUSY) {
            behavior_fsm_param->debug_planning_msg.SetForwardStayStillFunc("dwa busy");
            AWARN << "DWA BUSY";
        }
    }
    return true;
}


bool NormalBehavior::ForwardAvoidFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] ForwardAvoidFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetForwardAvoid();
    behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_dwa.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_dwa_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->semantic_info.ResetFrontCollision();
    behavior_fsm_param->speedplan_info.pathplannerGo = 4; //ForwardAvoid
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;

    AINFO << "type " << behavior_fsm_param->algorithm_ptr->algorithm_type_.type_str;
    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::FORWARD_AVOID ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<ForwardAvoid>();
    }

    int behavior_algorithm_result = -1;
    if (behavior_fsm_param->algorithm_ptr->IsInitOver() == false) {
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->InitAlgorithm();
        AINFO << "ForwardAvoidFunc GenerateDwaPath";
        if (behavior_fsm_param->algorithm_ptr->IsNewPath() == true) {
            AWARN << "forward_avoid_status  get result";
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("get result");
            behavior_fsm_param->algorithm_ptr->GetResult(behavior_fsm_param->calculate_path);
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
            behavior_fsm_param->semantic_info.ResetResultCollision();
        }
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("generate path error");
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecutFailed();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("generate path busy");
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetBusyStatus();
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecuting();
        } else {
            AWARN << "forward_avoid_status   OK";
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("generate path success");
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecuting();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
        }
    } else {
        AINFO << "ForwardAvoidFunc following";
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->CheckAlgorithmState();
        behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("follow path error");
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecutFailed();
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecuting();
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("following path");
        } else {
            behavior_fsm_param->algorithm_ptr->is_init_over_ = false;
            behavior_fsm_param->behavior_fsm_info.forward_avoid_status.SetExecutSuccess();
            behavior_fsm_param->debug_planning_msg.SetForwardAvoidFunc("following success");
        }
    }
    return true;
}


bool NormalBehavior::BackFollowingFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] BackFollowingFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetBackFollowing();
    behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc();

    if (behavior_fsm_param->behavior_fsm_info.is_calculating_back_dis == false) {
        behavior_fsm_param->behavior_fsm_info.is_calculating_back_dis = true;
        behavior_fsm_param->behavior_fsm_info.last_xg = behavior_fsm_param->localization_data.xg;
        behavior_fsm_param->behavior_fsm_info.last_yg = behavior_fsm_param->localization_data.yg;
    }
    behavior_fsm_param->behavior_fsm_info.back_distance += 
        std::hypot(behavior_fsm_param->behavior_fsm_info.last_xg - behavior_fsm_param->localization_data.xg,
                   behavior_fsm_param->behavior_fsm_info.last_yg - behavior_fsm_param->localization_data.yg);
    behavior_fsm_param->behavior_fsm_info.last_xg = behavior_fsm_param->localization_data.xg;
    behavior_fsm_param->behavior_fsm_info.last_yg = behavior_fsm_param->localization_data.yg;

    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->speedplan_info.pathplannerGo = 2; //BackFollowing
    behavior_fsm_param->behavior_fsm_info.back_following_times.NewTimes();
    behavior_fsm_param->result_path = behavior_fsm_param->paths.back_local_path;

    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::DUMMY ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<DummyAlgorithm>();
    }

    behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc(
        "path size " + std::to_string(behavior_fsm_param->result_path.path.size()) +
        ", dwa info, " + behavior_fsm_param->behavior_fsm_info.time_for_dwa.ToString());
    AINFO << "BackFollowing path size " +
          std::to_string(behavior_fsm_param->result_path.path.size() ) + ", dwa info, " +
          behavior_fsm_param->behavior_fsm_info.time_for_dwa.ToString();

    AWARN << "trying   dwa......";
    auto thread_pool = ThreadPool::Instance();
    eThreadStatus thread_state = thread_pool->CheckThreadState(ePlanningThread::COMPUTE_THREAD_ID);
    if (thread_state != eThreadStatus::BUSY) {
        behavior_fsm_param->behavior_fsm_info.time_for_dwa.NewTimes();
    }
    if (behavior_fsm_param->behavior_fsm_info.IsNeedCallDwa()) {
        AWARN << "STARTING   dwa......";
        behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc("trying dwa...");
        eComputeResult result = CheckDwaAvoidInThread(behavior_fsm_param->calculate_path, behavior_fsm_param->debug_planning_msg);
        if (result == eComputeResult::ERROR) {
            behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc("dwa failed");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutFailed();
            AERROR << "DWA FAILED";
        } else if (result == eComputeResult::SUCCESS) {
            behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc("dwa success");
            behavior_fsm_param->behavior_fsm_info.time_for_dwa.Reset();
            behavior_fsm_param->behavior_fsm_info.dwa_result_status.SetExecutSuccess();
            behavior_fsm_param->semantic_info.ResetResultCollision();
            behavior_fsm_param->algorithm_ptr = std::make_shared<ForwardAvoid>();
            AINFO << "MAKE new ForwardAvoid";
            behavior_fsm_param->algorithm_ptr->is_init_over_ = true;
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
        } else if (result == eComputeResult::BUSY) {
            behavior_fsm_param->debug_planning_msg.SetBackFollowingFunc("dwa busy");
            AWARN << "dwa busy";
        }
    }
    return true;
}


bool NormalBehavior::BackAvoidFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] BackAvoidFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetBackAvoid();
    behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc();

    behavior_fsm_param->behavior_fsm_info.ResetCalculateBackDis();
    behavior_fsm_param->behavior_fsm_info.forward_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.forward_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_stay_still_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_stay_still_times_setting);
    behavior_fsm_param->behavior_fsm_info.back_following_times.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.back_following_times_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_dwa.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_dwa_setting);
    behavior_fsm_param->behavior_fsm_info.time_for_hybrid_atar.SetStatisticsTimes(
        behavior_fsm_param->behavior_config.time_for_ha_setting);
    behavior_fsm_param->speedplan_info.pathplannerGo = 5; //BackAvoid
    behavior_fsm_param->result_path = behavior_fsm_param->paths.front_local_path;

    if (behavior_fsm_param->algorithm_ptr == nullptr ||
            behavior_fsm_param->algorithm_ptr->algorithm_type_.type != eAlgorithmType::BACK_AVOID ) {
        behavior_fsm_param->algorithm_ptr = std::make_shared<BackAvoid>();
    }

    int behavior_algorithm_result = -1;
    if (behavior_fsm_param->algorithm_ptr->IsInitOver() == false) {
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->InitAlgorithm();
        if (behavior_fsm_param->algorithm_ptr->IsNewPath() == true) {
            behavior_fsm_param->algorithm_ptr->GetResult(behavior_fsm_param->calculate_path);
            behavior_fsm_param->calculate_path.is_new = true;
            behavior_fsm_param->algorithm_ptr->ResetNewPath();
            AINFO << "BackAvoid get path";
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("get path");
        }
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecutFailed();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("generate path error");
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            AINFO << "BackAvoid generat path busy";
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetBusyStatus();
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecuting();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("generate path busy");
        } else {
            AINFO << "BackAvoid generat path success";
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecuting();
            behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("generate path success");
        }
    } else {
        AINFO << "BackAvoid CheckAlgorithmState";
        behavior_algorithm_result = behavior_fsm_param->algorithm_ptr->CheckAlgorithmState();
        behavior_fsm_param->behavior_fsm_info.behavior_busy_status.SetNormalStatus();
        if (behavior_algorithm_result == PATHPLAN_ERROR) {
            AERROR <<  behavior_fsm_param->behavior_fsm_info.behavior_status.status_str << "  error";
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecutFailed();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("following path error");
        } else if (behavior_algorithm_result == PATHPLAN_BUSY_STATUS) {
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecuting();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("following path busy");
        } else {
            behavior_fsm_param->algorithm_ptr->is_init_over_ = false;
            behavior_fsm_param->behavior_fsm_info.back_avoid_status.SetExecutSuccess();
            behavior_fsm_param->debug_planning_msg.SetBackAvoidFunc("following path success");
        }
    }
    return true;
}


bool NormalBehavior::BehaviorErrorFunc( void * o ) throw (BehaviorLogicError) {
    // add your code hereafter...
    AINFO << "[behavior fsm state] BehaviorErrorFunc";
    BehaviorFSMParam *behavior_fsm_param = (BehaviorFSMParam*)o;
    behavior_fsm_param->behavior_fsm_info.behavior_status.SetBehaviorError();
    behavior_fsm_param->debug_planning_msg.SetBehaviorErrorFunc();
    return true;
}


}
}

