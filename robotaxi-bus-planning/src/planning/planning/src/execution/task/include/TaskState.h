/*
 * this file was generated by NunniFSMGen - do not edit!
 */


#ifndef TaskState_H
#define TaskState_H


#include "src/execution/task/include/TaskLogicError.h"
namespace acu{
namespace planning{



class TaskFSM;


class TaskState
{


    protected:
        TaskState() {}


    public:
        virtual ~TaskState() {}


    virtual void TaskIsNew( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskExecutable( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskUnexecutable( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskExecuteOver( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskExecuteFault( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskOver( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskAborted( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskSuspended( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void TaskContinued( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void SyetemException( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void SyetemNormal( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void BtnEmergencyPressed( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void RemoteCtrlConnected( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
    virtual void EndTaskHandleOver( TaskFSM *ctx, void * o ) throw (TaskLogicError) = 0;
};


class TaskIdleTaskState : public TaskState
{
    private:
        static TaskIdleTaskState *m_instance;


    private:
        TaskIdleTaskState();
        virtual ~TaskIdleTaskState();


    public:
        static TaskIdleTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskAnalyseTaskState : public TaskState
{
    private:
        static TaskAnalyseTaskState *m_instance;


    private:
        TaskAnalyseTaskState();
        virtual ~TaskAnalyseTaskState();


    public:
        static TaskAnalyseTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskExecuteTaskState : public TaskState
{
    private:
        static TaskExecuteTaskState *m_instance;


    private:
        TaskExecuteTaskState();
        virtual ~TaskExecuteTaskState();


    public:
        static TaskExecuteTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskSuspendTaskState : public TaskState
{
    private:
        static TaskSuspendTaskState *m_instance;


    private:
        TaskSuspendTaskState();
        virtual ~TaskSuspendTaskState();


    public:
        static TaskSuspendTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskExceptionalTaskState : public TaskState
{
    private:
        static TaskExceptionalTaskState *m_instance;


    private:
        TaskExceptionalTaskState();
        virtual ~TaskExceptionalTaskState();


    public:
        static TaskExceptionalTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskEmergencyBtnHandleState : public TaskState
{
    private:
        static TaskEmergencyBtnHandleState *m_instance;


    private:
        TaskEmergencyBtnHandleState();
        virtual ~TaskEmergencyBtnHandleState();


    public:
        static TaskEmergencyBtnHandleState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskRemoteControlState : public TaskState
{
    private:
        static TaskRemoteControlState *m_instance;


    private:
        TaskRemoteControlState();
        virtual ~TaskRemoteControlState();


    public:
        static TaskRemoteControlState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


class TaskEndTaskState : public TaskState
{
    private:
        static TaskEndTaskState *m_instance;


    private:
        TaskEndTaskState();
        virtual ~TaskEndTaskState();


    public:
        static TaskEndTaskState* instance();


    virtual void TaskIsNew( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskUnexecutable( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskExecuteFault( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskAborted( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskSuspended( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void TaskContinued( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemException( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void SyetemNormal( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyPressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void BtnEmergencyUnpressed( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlConnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void RemoteCtrlUnconnected( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
    virtual void EndTaskHandleOver( TaskFSM *ctx,  void * o ) throw (TaskLogicError);
};


}
}

#endif
