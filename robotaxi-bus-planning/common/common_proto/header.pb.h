// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: header.proto

#ifndef PROTOBUF_header_2eproto__INCLUDED
#define PROTOBUF_header_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "error_code.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_header_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsTimeStatusImpl();
void InitDefaultsTimeStatus();
void InitDefaultsTimeStatisticsImpl();
void InitDefaultsTimeStatistics();
void InitDefaultsFaultVecImpl();
void InitDefaultsFaultVec();
void InitDefaultsClockImpl();
void InitDefaultsClock();
void InitDefaultsTimeImpl();
void InitDefaultsTime();
inline void InitDefaults() {
  InitDefaultsHeader();
  InitDefaultsTimeStatus();
  InitDefaultsTimeStatistics();
  InitDefaultsFaultVec();
  InitDefaultsClock();
  InitDefaultsTime();
}
}  // namespace protobuf_header_2eproto
namespace acu {
namespace common {
class Clock;
class ClockDefaultTypeInternal;
extern ClockDefaultTypeInternal _Clock_default_instance_;
class FaultVec;
class FaultVecDefaultTypeInternal;
extern FaultVecDefaultTypeInternal _FaultVec_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class TimeStatistics;
class TimeStatisticsDefaultTypeInternal;
extern TimeStatisticsDefaultTypeInternal _TimeStatistics_default_instance_;
class TimeStatus;
class TimeStatusDefaultTypeInternal;
extern TimeStatusDefaultTypeInternal _TimeStatus_default_instance_;
}  // namespace common
}  // namespace acu
namespace acu {
namespace common {

enum eAction {
  DEFAULT_VALUE_EACTION = 0,
  BRAKE = 1,
  START = 2,
  STOP = 3,
  YIELD = 4,
  PARKING = 5,
  TURN = 6,
  OBSTACLE_AVOID = 7,
  LANE_CHANGE = 8,
  GIVE_WAY = 9,
  RE_MISSION_PLAN = 10,
  LANE_FOLLOWING = 11,
  CROSS = 12
};
bool eAction_IsValid(int value);
const eAction eAction_MIN = DEFAULT_VALUE_EACTION;
const eAction eAction_MAX = CROSS;
const int eAction_ARRAYSIZE = eAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* eAction_descriptor();
inline const ::std::string& eAction_Name(eAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    eAction_descriptor(), value);
}
inline bool eAction_Parse(
    const ::std::string& name, eAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eAction>(
    eAction_descriptor(), name, value);
}
enum eDirection {
  DEFAULT_VALUE = 0,
  LEFT = 1,
  RIGHT = 2,
  FORWARD = 3,
  BACKWARD = 4
};
bool eDirection_IsValid(int value);
const eDirection eDirection_MIN = DEFAULT_VALUE;
const eDirection eDirection_MAX = BACKWARD;
const int eDirection_ARRAYSIZE = eDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* eDirection_descriptor();
inline const ::std::string& eDirection_Name(eDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    eDirection_descriptor(), value);
}
inline bool eDirection_Parse(
    const ::std::string& name, eDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<eDirection>(
    eDirection_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string module_name = 2;
  bool has_module_name() const;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 2;
  const ::std::string& module_name() const;
  void set_module_name(const ::std::string& value);
  #if LANG_CXX11
  void set_module_name(::std::string&& value);
  #endif
  void set_module_name(const char* value);
  void set_module_name(const char* value, size_t size);
  ::std::string* mutable_module_name();
  ::std::string* release_module_name();
  void set_allocated_module_name(::std::string* module_name);

  // optional string version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional uint32 sequence_num = 3;
  bool has_sequence_num() const;
  void clear_sequence_num();
  static const int kSequenceNumFieldNumber = 3;
  ::google::protobuf::uint32 sequence_num() const;
  void set_sequence_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:acu.common.Header)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_module_name();
  void clear_has_module_name();
  void set_has_sequence_num();
  void clear_has_sequence_num();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr module_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  double timestamp_sec_;
  ::google::protobuf::uint32 sequence_num_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class TimeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.TimeStatus) */ {
 public:
  TimeStatus();
  virtual ~TimeStatus();

  TimeStatus(const TimeStatus& from);

  inline TimeStatus& operator=(const TimeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeStatus(TimeStatus&& from) noexcept
    : TimeStatus() {
    *this = ::std::move(from);
  }

  inline TimeStatus& operator=(TimeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeStatus* internal_default_instance() {
    return reinterpret_cast<const TimeStatus*>(
               &_TimeStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TimeStatus* other);
  friend void swap(TimeStatus& a, TimeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeStatus& from);
  void MergeFrom(const TimeStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string source_node_name = 2;
  bool has_source_node_name() const;
  void clear_source_node_name();
  static const int kSourceNodeNameFieldNumber = 2;
  const ::std::string& source_node_name() const;
  void set_source_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_source_node_name(::std::string&& value);
  #endif
  void set_source_node_name(const char* value);
  void set_source_node_name(const char* value, size_t size);
  ::std::string* mutable_source_node_name();
  ::std::string* release_source_node_name();
  void set_allocated_source_node_name(::std::string* source_node_name);

  // optional string destination_node_name = 3;
  bool has_destination_node_name() const;
  void clear_destination_node_name();
  static const int kDestinationNodeNameFieldNumber = 3;
  const ::std::string& destination_node_name() const;
  void set_destination_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_destination_node_name(::std::string&& value);
  #endif
  void set_destination_node_name(const char* value);
  void set_destination_node_name(const char* value, size_t size);
  ::std::string* mutable_destination_node_name();
  ::std::string* release_destination_node_name();
  void set_allocated_destination_node_name(::std::string* destination_node_name);

  // optional double dtime = 1;
  bool has_dtime() const;
  void clear_dtime();
  static const int kDtimeFieldNumber = 1;
  double dtime() const;
  void set_dtime(double value);

  // @@protoc_insertion_point(class_scope:acu.common.TimeStatus)
 private:
  void set_has_dtime();
  void clear_has_dtime();
  void set_has_source_node_name();
  void clear_has_source_node_name();
  void set_has_destination_node_name();
  void clear_has_destination_node_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_node_name_;
  ::google::protobuf::internal::ArenaStringPtr destination_node_name_;
  double dtime_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsTimeStatusImpl();
};
// -------------------------------------------------------------------

class TimeStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.TimeStatistics) */ {
 public:
  TimeStatistics();
  virtual ~TimeStatistics();

  TimeStatistics(const TimeStatistics& from);

  inline TimeStatistics& operator=(const TimeStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeStatistics(TimeStatistics&& from) noexcept
    : TimeStatistics() {
    *this = ::std::move(from);
  }

  inline TimeStatistics& operator=(TimeStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeStatistics* internal_default_instance() {
    return reinterpret_cast<const TimeStatistics*>(
               &_TimeStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TimeStatistics* other);
  friend void swap(TimeStatistics& a, TimeStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeStatistics& from);
  void MergeFrom(const TimeStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeStatistics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .acu.common.TimeStatus dev_time_status_msg = 1;
  int dev_time_status_msg_size() const;
  void clear_dev_time_status_msg();
  static const int kDevTimeStatusMsgFieldNumber = 1;
  const ::acu::common::TimeStatus& dev_time_status_msg(int index) const;
  ::acu::common::TimeStatus* mutable_dev_time_status_msg(int index);
  ::acu::common::TimeStatus* add_dev_time_status_msg();
  ::google::protobuf::RepeatedPtrField< ::acu::common::TimeStatus >*
      mutable_dev_time_status_msg();
  const ::google::protobuf::RepeatedPtrField< ::acu::common::TimeStatus >&
      dev_time_status_msg() const;

  // optional double sending_timestamp = 2;
  bool has_sending_timestamp() const;
  void clear_sending_timestamp();
  static const int kSendingTimestampFieldNumber = 2;
  double sending_timestamp() const;
  void set_sending_timestamp(double value);

  // @@protoc_insertion_point(class_scope:acu.common.TimeStatistics)
 private:
  void set_has_sending_timestamp();
  void clear_has_sending_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::acu::common::TimeStatus > dev_time_status_msg_;
  double sending_timestamp_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsTimeStatisticsImpl();
};
// -------------------------------------------------------------------

class FaultVec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.FaultVec) */ {
 public:
  FaultVec();
  virtual ~FaultVec();

  FaultVec(const FaultVec& from);

  inline FaultVec& operator=(const FaultVec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaultVec(FaultVec&& from) noexcept
    : FaultVec() {
    *this = ::std::move(from);
  }

  inline FaultVec& operator=(FaultVec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultVec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaultVec* internal_default_instance() {
    return reinterpret_cast<const FaultVec*>(
               &_FaultVec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FaultVec* other);
  friend void swap(FaultVec& a, FaultVec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaultVec* New() const PROTOBUF_FINAL { return New(NULL); }

  FaultVec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaultVec& from);
  void MergeFrom(const FaultVec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaultVec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .acu.common.FaultInfo info_vec = 1;
  int info_vec_size() const;
  void clear_info_vec();
  static const int kInfoVecFieldNumber = 1;
  const ::acu::common::FaultInfo& info_vec(int index) const;
  ::acu::common::FaultInfo* mutable_info_vec(int index);
  ::acu::common::FaultInfo* add_info_vec();
  ::google::protobuf::RepeatedPtrField< ::acu::common::FaultInfo >*
      mutable_info_vec();
  const ::google::protobuf::RepeatedPtrField< ::acu::common::FaultInfo >&
      info_vec() const;

  // optional int32 module_fault_level = 2;
  bool has_module_fault_level() const;
  void clear_module_fault_level();
  static const int kModuleFaultLevelFieldNumber = 2;
  ::google::protobuf::int32 module_fault_level() const;
  void set_module_fault_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:acu.common.FaultVec)
 private:
  void set_has_module_fault_level();
  void clear_has_module_fault_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::acu::common::FaultInfo > info_vec_;
  ::google::protobuf::int32 module_fault_level_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsFaultVecImpl();
};
// -------------------------------------------------------------------

class Clock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Clock) */ {
 public:
  Clock();
  virtual ~Clock();

  Clock(const Clock& from);

  inline Clock& operator=(const Clock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Clock(Clock&& from) noexcept
    : Clock() {
    *this = ::std::move(from);
  }

  inline Clock& operator=(Clock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Clock* internal_default_instance() {
    return reinterpret_cast<const Clock*>(
               &_Clock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Clock* other);
  friend void swap(Clock& a, Clock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Clock* New() const PROTOBUF_FINAL { return New(NULL); }

  Clock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Clock& from);
  void MergeFrom(const Clock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 day = 1;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 1;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // optional int32 hour = 2;
  bool has_hour() const;
  void clear_hour();
  static const int kHourFieldNumber = 2;
  ::google::protobuf::int32 hour() const;
  void set_hour(::google::protobuf::int32 value);

  // optional int32 minute = 3;
  bool has_minute() const;
  void clear_minute();
  static const int kMinuteFieldNumber = 3;
  ::google::protobuf::int32 minute() const;
  void set_minute(::google::protobuf::int32 value);

  // optional int32 second = 4;
  bool has_second() const;
  void clear_second();
  static const int kSecondFieldNumber = 4;
  ::google::protobuf::int32 second() const;
  void set_second(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:acu.common.Clock)
 private:
  void set_has_day();
  void clear_has_day();
  void set_has_hour();
  void clear_has_hour();
  void set_has_minute();
  void clear_has_minute();
  void set_has_second();
  void clear_has_second();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsClockImpl();
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(Time&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Time* other);
  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const PROTOBUF_FINAL { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.Clock absolute_time = 3;
  bool has_absolute_time() const;
  void clear_absolute_time();
  static const int kAbsoluteTimeFieldNumber = 3;
  const ::acu::common::Clock& absolute_time() const;
  ::acu::common::Clock* release_absolute_time();
  ::acu::common::Clock* mutable_absolute_time();
  void set_allocated_absolute_time(::acu::common::Clock* absolute_time);

  // optional bool time_enable = 1;
  bool has_time_enable() const;
  void clear_time_enable();
  static const int kTimeEnableFieldNumber = 1;
  bool time_enable() const;
  void set_time_enable(bool value);

  // optional int32 relative_time = 2;
  bool has_relative_time() const;
  void clear_relative_time();
  static const int kRelativeTimeFieldNumber = 2;
  ::google::protobuf::int32 relative_time() const;
  void set_relative_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:acu.common.Time)
 private:
  void set_has_time_enable();
  void clear_has_time_enable();
  void set_has_relative_time();
  void clear_has_relative_time();
  void set_has_absolute_time();
  void clear_has_absolute_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::Clock* absolute_time_;
  bool time_enable_;
  ::google::protobuf::int32 relative_time_;
  friend struct ::protobuf_header_2eproto::TableStruct;
  friend void ::protobuf_header_2eproto::InitDefaultsTimeImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// optional double timestamp_sec = 1;
inline bool Header::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double Header::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:acu.common.Header.timestamp_sec)
  return timestamp_sec_;
}
inline void Header::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Header.timestamp_sec)
}

// optional string module_name = 2;
inline bool Header::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_module_name() {
  module_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_module_name();
}
inline const ::std::string& Header::module_name() const {
  // @@protoc_insertion_point(field_get:acu.common.Header.module_name)
  return module_name_.GetNoArena();
}
inline void Header::set_module_name(const ::std::string& value) {
  set_has_module_name();
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acu.common.Header.module_name)
}
#if LANG_CXX11
inline void Header::set_module_name(::std::string&& value) {
  set_has_module_name();
  module_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acu.common.Header.module_name)
}
#endif
inline void Header::set_module_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_module_name();
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acu.common.Header.module_name)
}
inline void Header::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acu.common.Header.module_name)
}
inline ::std::string* Header::mutable_module_name() {
  set_has_module_name();
  // @@protoc_insertion_point(field_mutable:acu.common.Header.module_name)
  return module_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_module_name() {
  // @@protoc_insertion_point(field_release:acu.common.Header.module_name)
  clear_has_module_name();
  return module_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_module_name(::std::string* module_name) {
  if (module_name != NULL) {
    set_has_module_name();
  } else {
    clear_has_module_name();
  }
  module_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_name);
  // @@protoc_insertion_point(field_set_allocated:acu.common.Header.module_name)
}

// optional uint32 sequence_num = 3;
inline bool Header::has_sequence_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_sequence_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_sequence_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_sequence_num() {
  sequence_num_ = 0u;
  clear_has_sequence_num();
}
inline ::google::protobuf::uint32 Header::sequence_num() const {
  // @@protoc_insertion_point(field_get:acu.common.Header.sequence_num)
  return sequence_num_;
}
inline void Header::set_sequence_num(::google::protobuf::uint32 value) {
  set_has_sequence_num();
  sequence_num_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Header.sequence_num)
}

// optional string version = 4;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:acu.common.Header.version)
  return version_.GetNoArena();
}
inline void Header::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acu.common.Header.version)
}
#if LANG_CXX11
inline void Header::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acu.common.Header.version)
}
#endif
inline void Header::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acu.common.Header.version)
}
inline void Header::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acu.common.Header.version)
}
inline ::std::string* Header::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:acu.common.Header.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_version() {
  // @@protoc_insertion_point(field_release:acu.common.Header.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:acu.common.Header.version)
}

// -------------------------------------------------------------------

// TimeStatus

// optional double dtime = 1;
inline bool TimeStatus::has_dtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeStatus::set_has_dtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeStatus::clear_has_dtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeStatus::clear_dtime() {
  dtime_ = 0;
  clear_has_dtime();
}
inline double TimeStatus::dtime() const {
  // @@protoc_insertion_point(field_get:acu.common.TimeStatus.dtime)
  return dtime_;
}
inline void TimeStatus::set_dtime(double value) {
  set_has_dtime();
  dtime_ = value;
  // @@protoc_insertion_point(field_set:acu.common.TimeStatus.dtime)
}

// optional string source_node_name = 2;
inline bool TimeStatus::has_source_node_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeStatus::set_has_source_node_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeStatus::clear_has_source_node_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeStatus::clear_source_node_name() {
  source_node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_node_name();
}
inline const ::std::string& TimeStatus::source_node_name() const {
  // @@protoc_insertion_point(field_get:acu.common.TimeStatus.source_node_name)
  return source_node_name_.GetNoArena();
}
inline void TimeStatus::set_source_node_name(const ::std::string& value) {
  set_has_source_node_name();
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acu.common.TimeStatus.source_node_name)
}
#if LANG_CXX11
inline void TimeStatus::set_source_node_name(::std::string&& value) {
  set_has_source_node_name();
  source_node_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acu.common.TimeStatus.source_node_name)
}
#endif
inline void TimeStatus::set_source_node_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_node_name();
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acu.common.TimeStatus.source_node_name)
}
inline void TimeStatus::set_source_node_name(const char* value, size_t size) {
  set_has_source_node_name();
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acu.common.TimeStatus.source_node_name)
}
inline ::std::string* TimeStatus::mutable_source_node_name() {
  set_has_source_node_name();
  // @@protoc_insertion_point(field_mutable:acu.common.TimeStatus.source_node_name)
  return source_node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TimeStatus::release_source_node_name() {
  // @@protoc_insertion_point(field_release:acu.common.TimeStatus.source_node_name)
  clear_has_source_node_name();
  return source_node_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimeStatus::set_allocated_source_node_name(::std::string* source_node_name) {
  if (source_node_name != NULL) {
    set_has_source_node_name();
  } else {
    clear_has_source_node_name();
  }
  source_node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_node_name);
  // @@protoc_insertion_point(field_set_allocated:acu.common.TimeStatus.source_node_name)
}

// optional string destination_node_name = 3;
inline bool TimeStatus::has_destination_node_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeStatus::set_has_destination_node_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeStatus::clear_has_destination_node_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeStatus::clear_destination_node_name() {
  destination_node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_node_name();
}
inline const ::std::string& TimeStatus::destination_node_name() const {
  // @@protoc_insertion_point(field_get:acu.common.TimeStatus.destination_node_name)
  return destination_node_name_.GetNoArena();
}
inline void TimeStatus::set_destination_node_name(const ::std::string& value) {
  set_has_destination_node_name();
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:acu.common.TimeStatus.destination_node_name)
}
#if LANG_CXX11
inline void TimeStatus::set_destination_node_name(::std::string&& value) {
  set_has_destination_node_name();
  destination_node_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:acu.common.TimeStatus.destination_node_name)
}
#endif
inline void TimeStatus::set_destination_node_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination_node_name();
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:acu.common.TimeStatus.destination_node_name)
}
inline void TimeStatus::set_destination_node_name(const char* value, size_t size) {
  set_has_destination_node_name();
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:acu.common.TimeStatus.destination_node_name)
}
inline ::std::string* TimeStatus::mutable_destination_node_name() {
  set_has_destination_node_name();
  // @@protoc_insertion_point(field_mutable:acu.common.TimeStatus.destination_node_name)
  return destination_node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TimeStatus::release_destination_node_name() {
  // @@protoc_insertion_point(field_release:acu.common.TimeStatus.destination_node_name)
  clear_has_destination_node_name();
  return destination_node_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimeStatus::set_allocated_destination_node_name(::std::string* destination_node_name) {
  if (destination_node_name != NULL) {
    set_has_destination_node_name();
  } else {
    clear_has_destination_node_name();
  }
  destination_node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_node_name);
  // @@protoc_insertion_point(field_set_allocated:acu.common.TimeStatus.destination_node_name)
}

// -------------------------------------------------------------------

// TimeStatistics

// repeated .acu.common.TimeStatus dev_time_status_msg = 1;
inline int TimeStatistics::dev_time_status_msg_size() const {
  return dev_time_status_msg_.size();
}
inline void TimeStatistics::clear_dev_time_status_msg() {
  dev_time_status_msg_.Clear();
}
inline const ::acu::common::TimeStatus& TimeStatistics::dev_time_status_msg(int index) const {
  // @@protoc_insertion_point(field_get:acu.common.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Get(index);
}
inline ::acu::common::TimeStatus* TimeStatistics::mutable_dev_time_status_msg(int index) {
  // @@protoc_insertion_point(field_mutable:acu.common.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Mutable(index);
}
inline ::acu::common::TimeStatus* TimeStatistics::add_dev_time_status_msg() {
  // @@protoc_insertion_point(field_add:acu.common.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::acu::common::TimeStatus >*
TimeStatistics::mutable_dev_time_status_msg() {
  // @@protoc_insertion_point(field_mutable_list:acu.common.TimeStatistics.dev_time_status_msg)
  return &dev_time_status_msg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::acu::common::TimeStatus >&
TimeStatistics::dev_time_status_msg() const {
  // @@protoc_insertion_point(field_list:acu.common.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_;
}

// optional double sending_timestamp = 2;
inline bool TimeStatistics::has_sending_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeStatistics::set_has_sending_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeStatistics::clear_has_sending_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeStatistics::clear_sending_timestamp() {
  sending_timestamp_ = 0;
  clear_has_sending_timestamp();
}
inline double TimeStatistics::sending_timestamp() const {
  // @@protoc_insertion_point(field_get:acu.common.TimeStatistics.sending_timestamp)
  return sending_timestamp_;
}
inline void TimeStatistics::set_sending_timestamp(double value) {
  set_has_sending_timestamp();
  sending_timestamp_ = value;
  // @@protoc_insertion_point(field_set:acu.common.TimeStatistics.sending_timestamp)
}

// -------------------------------------------------------------------

// FaultVec

// repeated .acu.common.FaultInfo info_vec = 1;
inline int FaultVec::info_vec_size() const {
  return info_vec_.size();
}
inline const ::acu::common::FaultInfo& FaultVec::info_vec(int index) const {
  // @@protoc_insertion_point(field_get:acu.common.FaultVec.info_vec)
  return info_vec_.Get(index);
}
inline ::acu::common::FaultInfo* FaultVec::mutable_info_vec(int index) {
  // @@protoc_insertion_point(field_mutable:acu.common.FaultVec.info_vec)
  return info_vec_.Mutable(index);
}
inline ::acu::common::FaultInfo* FaultVec::add_info_vec() {
  // @@protoc_insertion_point(field_add:acu.common.FaultVec.info_vec)
  return info_vec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::acu::common::FaultInfo >*
FaultVec::mutable_info_vec() {
  // @@protoc_insertion_point(field_mutable_list:acu.common.FaultVec.info_vec)
  return &info_vec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::acu::common::FaultInfo >&
FaultVec::info_vec() const {
  // @@protoc_insertion_point(field_list:acu.common.FaultVec.info_vec)
  return info_vec_;
}

// optional int32 module_fault_level = 2;
inline bool FaultVec::has_module_fault_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaultVec::set_has_module_fault_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaultVec::clear_has_module_fault_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaultVec::clear_module_fault_level() {
  module_fault_level_ = 0;
  clear_has_module_fault_level();
}
inline ::google::protobuf::int32 FaultVec::module_fault_level() const {
  // @@protoc_insertion_point(field_get:acu.common.FaultVec.module_fault_level)
  return module_fault_level_;
}
inline void FaultVec::set_module_fault_level(::google::protobuf::int32 value) {
  set_has_module_fault_level();
  module_fault_level_ = value;
  // @@protoc_insertion_point(field_set:acu.common.FaultVec.module_fault_level)
}

// -------------------------------------------------------------------

// Clock

// optional int32 day = 1;
inline bool Clock::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clock::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clock::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clock::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 Clock::day() const {
  // @@protoc_insertion_point(field_get:acu.common.Clock.day)
  return day_;
}
inline void Clock::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Clock.day)
}

// optional int32 hour = 2;
inline bool Clock::has_hour() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clock::set_has_hour() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clock::clear_has_hour() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clock::clear_hour() {
  hour_ = 0;
  clear_has_hour();
}
inline ::google::protobuf::int32 Clock::hour() const {
  // @@protoc_insertion_point(field_get:acu.common.Clock.hour)
  return hour_;
}
inline void Clock::set_hour(::google::protobuf::int32 value) {
  set_has_hour();
  hour_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Clock.hour)
}

// optional int32 minute = 3;
inline bool Clock::has_minute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Clock::set_has_minute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Clock::clear_has_minute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Clock::clear_minute() {
  minute_ = 0;
  clear_has_minute();
}
inline ::google::protobuf::int32 Clock::minute() const {
  // @@protoc_insertion_point(field_get:acu.common.Clock.minute)
  return minute_;
}
inline void Clock::set_minute(::google::protobuf::int32 value) {
  set_has_minute();
  minute_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Clock.minute)
}

// optional int32 second = 4;
inline bool Clock::has_second() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Clock::set_has_second() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Clock::clear_has_second() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Clock::clear_second() {
  second_ = 0;
  clear_has_second();
}
inline ::google::protobuf::int32 Clock::second() const {
  // @@protoc_insertion_point(field_get:acu.common.Clock.second)
  return second_;
}
inline void Clock::set_second(::google::protobuf::int32 value) {
  set_has_second();
  second_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Clock.second)
}

// -------------------------------------------------------------------

// Time

// optional bool time_enable = 1;
inline bool Time::has_time_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_time_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_time_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_time_enable() {
  time_enable_ = false;
  clear_has_time_enable();
}
inline bool Time::time_enable() const {
  // @@protoc_insertion_point(field_get:acu.common.Time.time_enable)
  return time_enable_;
}
inline void Time::set_time_enable(bool value) {
  set_has_time_enable();
  time_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Time.time_enable)
}

// optional int32 relative_time = 2;
inline bool Time::has_relative_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_relative_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_relative_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_relative_time() {
  relative_time_ = 0;
  clear_has_relative_time();
}
inline ::google::protobuf::int32 Time::relative_time() const {
  // @@protoc_insertion_point(field_get:acu.common.Time.relative_time)
  return relative_time_;
}
inline void Time::set_relative_time(::google::protobuf::int32 value) {
  set_has_relative_time();
  relative_time_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Time.relative_time)
}

// optional .acu.common.Clock absolute_time = 3;
inline bool Time::has_absolute_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_absolute_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_absolute_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_absolute_time() {
  if (absolute_time_ != NULL) absolute_time_->Clear();
  clear_has_absolute_time();
}
inline const ::acu::common::Clock& Time::absolute_time() const {
  const ::acu::common::Clock* p = absolute_time_;
  // @@protoc_insertion_point(field_get:acu.common.Time.absolute_time)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Clock*>(
      &::acu::common::_Clock_default_instance_);
}
inline ::acu::common::Clock* Time::release_absolute_time() {
  // @@protoc_insertion_point(field_release:acu.common.Time.absolute_time)
  clear_has_absolute_time();
  ::acu::common::Clock* temp = absolute_time_;
  absolute_time_ = NULL;
  return temp;
}
inline ::acu::common::Clock* Time::mutable_absolute_time() {
  set_has_absolute_time();
  if (absolute_time_ == NULL) {
    absolute_time_ = new ::acu::common::Clock;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Time.absolute_time)
  return absolute_time_;
}
inline void Time::set_allocated_absolute_time(::acu::common::Clock* absolute_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete absolute_time_;
  }
  if (absolute_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      absolute_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, absolute_time, submessage_arena);
    }
    set_has_absolute_time();
  } else {
    clear_has_absolute_time();
  }
  absolute_time_ = absolute_time;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Time.absolute_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace acu

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::acu::common::eAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::common::eAction>() {
  return ::acu::common::eAction_descriptor();
}
template <> struct is_proto_enum< ::acu::common::eDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::common::eDirection>() {
  return ::acu::common::eDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_header_2eproto__INCLUDED
