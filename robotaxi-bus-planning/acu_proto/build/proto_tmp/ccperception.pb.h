// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ccperception.proto

#ifndef PROTOBUF_ccperception_2eproto__INCLUDED
#define PROTOBUF_ccperception_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "perception_types.pb.h"
#include "perception.pb.h"
#include "lidar_perception.pb.h"
#include "vehicle_info.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_ccperception_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPointXYZIImpl();
void InitDefaultsPointXYZI();
void InitDefaultsSingleLidarDataImpl();
void InitDefaultsSingleLidarData();
void InitDefaultsRawLidarFrameImpl();
void InitDefaultsRawLidarFrame();
void InitDefaultsCCPerceptionFrameImpl();
void InitDefaultsCCPerceptionFrame();
inline void InitDefaults() {
  InitDefaultsPointXYZI();
  InitDefaultsSingleLidarData();
  InitDefaultsRawLidarFrame();
  InitDefaultsCCPerceptionFrame();
}
}  // namespace protobuf_ccperception_2eproto
namespace calmcar {
namespace perception {
class CCPerceptionFrame;
class CCPerceptionFrameDefaultTypeInternal;
extern CCPerceptionFrameDefaultTypeInternal _CCPerceptionFrame_default_instance_;
class PointXYZI;
class PointXYZIDefaultTypeInternal;
extern PointXYZIDefaultTypeInternal _PointXYZI_default_instance_;
class RawLidarFrame;
class RawLidarFrameDefaultTypeInternal;
extern RawLidarFrameDefaultTypeInternal _RawLidarFrame_default_instance_;
class SingleLidarData;
class SingleLidarDataDefaultTypeInternal;
extern SingleLidarDataDefaultTypeInternal _SingleLidarData_default_instance_;
}  // namespace perception
}  // namespace calmcar
namespace calmcar {
namespace perception {

// ===================================================================

class PointXYZI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.PointXYZI) */ {
 public:
  PointXYZI();
  virtual ~PointXYZI();

  PointXYZI(const PointXYZI& from);

  inline PointXYZI& operator=(const PointXYZI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointXYZI(PointXYZI&& from) noexcept
    : PointXYZI() {
    *this = ::std::move(from);
  }

  inline PointXYZI& operator=(PointXYZI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointXYZI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointXYZI* internal_default_instance() {
    return reinterpret_cast<const PointXYZI*>(
               &_PointXYZI_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PointXYZI* other);
  friend void swap(PointXYZI& a, PointXYZI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointXYZI* New() const PROTOBUF_FINAL { return New(NULL); }

  PointXYZI* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointXYZI& from);
  void MergeFrom(const PointXYZI& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointXYZI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // int32 i = 4;
  void clear_i();
  static const int kIFieldNumber = 4;
  ::google::protobuf::int32 i() const;
  void set_i(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.PointXYZI)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  ::google::protobuf::int32 i_;
  mutable int _cached_size_;
  friend struct ::protobuf_ccperception_2eproto::TableStruct;
  friend void ::protobuf_ccperception_2eproto::InitDefaultsPointXYZIImpl();
};
// -------------------------------------------------------------------

class SingleLidarData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.SingleLidarData) */ {
 public:
  SingleLidarData();
  virtual ~SingleLidarData();

  SingleLidarData(const SingleLidarData& from);

  inline SingleLidarData& operator=(const SingleLidarData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SingleLidarData(SingleLidarData&& from) noexcept
    : SingleLidarData() {
    *this = ::std::move(from);
  }

  inline SingleLidarData& operator=(SingleLidarData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleLidarData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleLidarData* internal_default_instance() {
    return reinterpret_cast<const SingleLidarData*>(
               &_SingleLidarData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SingleLidarData* other);
  friend void swap(SingleLidarData& a, SingleLidarData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SingleLidarData* New() const PROTOBUF_FINAL { return New(NULL); }

  SingleLidarData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SingleLidarData& from);
  void MergeFrom(const SingleLidarData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SingleLidarData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.PointXYZI points = 4;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 4;
  const ::calmcar::perception::PointXYZI& points(int index) const;
  ::calmcar::perception::PointXYZI* mutable_points(int index);
  ::calmcar::perception::PointXYZI* add_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::PointXYZI >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::PointXYZI >&
      points() const;

  // repeated bytes scan_msg = 5;
  int scan_msg_size() const;
  void clear_scan_msg();
  static const int kScanMsgFieldNumber = 5;
  const ::std::string& scan_msg(int index) const;
  ::std::string* mutable_scan_msg(int index);
  void set_scan_msg(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_scan_msg(int index, ::std::string&& value);
  #endif
  void set_scan_msg(int index, const char* value);
  void set_scan_msg(int index, const void* value, size_t size);
  ::std::string* add_scan_msg();
  void add_scan_msg(const ::std::string& value);
  #if LANG_CXX11
  void add_scan_msg(::std::string&& value);
  #endif
  void add_scan_msg(const char* value);
  void add_scan_msg(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_msg() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_msg();

  // string lidar_sensor_name = 3;
  void clear_lidar_sensor_name();
  static const int kLidarSensorNameFieldNumber = 3;
  const ::std::string& lidar_sensor_name() const;
  void set_lidar_sensor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_lidar_sensor_name(::std::string&& value);
  #endif
  void set_lidar_sensor_name(const char* value);
  void set_lidar_sensor_name(const char* value, size_t size);
  ::std::string* mutable_lidar_sensor_name();
  ::std::string* release_lidar_sensor_name();
  void set_allocated_lidar_sensor_name(::std::string* lidar_sensor_name);

  // bytes difop_msg = 6;
  void clear_difop_msg();
  static const int kDifopMsgFieldNumber = 6;
  const ::std::string& difop_msg() const;
  void set_difop_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_difop_msg(::std::string&& value);
  #endif
  void set_difop_msg(const char* value);
  void set_difop_msg(const void* value, size_t size);
  ::std::string* mutable_difop_msg();
  ::std::string* release_difop_msg();
  void set_allocated_difop_msg(::std::string* difop_msg);

  // string lidar_sensor_type = 13;
  void clear_lidar_sensor_type();
  static const int kLidarSensorTypeFieldNumber = 13;
  const ::std::string& lidar_sensor_type() const;
  void set_lidar_sensor_type(const ::std::string& value);
  #if LANG_CXX11
  void set_lidar_sensor_type(::std::string&& value);
  #endif
  void set_lidar_sensor_type(const char* value);
  void set_lidar_sensor_type(const char* value, size_t size);
  ::std::string* mutable_lidar_sensor_type();
  ::std::string* release_lidar_sensor_type();
  void set_allocated_lidar_sensor_type(::std::string* lidar_sensor_type);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 lidar_sensor_id = 2;
  void clear_lidar_sensor_id();
  static const int kLidarSensorIdFieldNumber = 2;
  ::google::protobuf::int32 lidar_sensor_id() const;
  void set_lidar_sensor_id(::google::protobuf::int32 value);

  // float offset_x = 7;
  void clear_offset_x();
  static const int kOffsetXFieldNumber = 7;
  float offset_x() const;
  void set_offset_x(float value);

  // float offset_y = 8;
  void clear_offset_y();
  static const int kOffsetYFieldNumber = 8;
  float offset_y() const;
  void set_offset_y(float value);

  // float offset_z = 9;
  void clear_offset_z();
  static const int kOffsetZFieldNumber = 9;
  float offset_z() const;
  void set_offset_z(float value);

  // float yaw = 10;
  void clear_yaw();
  static const int kYawFieldNumber = 10;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 11;
  void clear_roll();
  static const int kRollFieldNumber = 11;
  float roll() const;
  void set_roll(float value);

  // float pitch = 12;
  void clear_pitch();
  static const int kPitchFieldNumber = 12;
  float pitch() const;
  void set_pitch(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.SingleLidarData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::PointXYZI > points_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_msg_;
  ::google::protobuf::internal::ArenaStringPtr lidar_sensor_name_;
  ::google::protobuf::internal::ArenaStringPtr difop_msg_;
  ::google::protobuf::internal::ArenaStringPtr lidar_sensor_type_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 lidar_sensor_id_;
  float offset_x_;
  float offset_y_;
  float offset_z_;
  float yaw_;
  float roll_;
  float pitch_;
  mutable int _cached_size_;
  friend struct ::protobuf_ccperception_2eproto::TableStruct;
  friend void ::protobuf_ccperception_2eproto::InitDefaultsSingleLidarDataImpl();
};
// -------------------------------------------------------------------

class RawLidarFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.RawLidarFrame) */ {
 public:
  RawLidarFrame();
  virtual ~RawLidarFrame();

  RawLidarFrame(const RawLidarFrame& from);

  inline RawLidarFrame& operator=(const RawLidarFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawLidarFrame(RawLidarFrame&& from) noexcept
    : RawLidarFrame() {
    *this = ::std::move(from);
  }

  inline RawLidarFrame& operator=(RawLidarFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawLidarFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawLidarFrame* internal_default_instance() {
    return reinterpret_cast<const RawLidarFrame*>(
               &_RawLidarFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RawLidarFrame* other);
  friend void swap(RawLidarFrame& a, RawLidarFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawLidarFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  RawLidarFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RawLidarFrame& from);
  void MergeFrom(const RawLidarFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RawLidarFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.SingleLidarData single_lidar_data = 3;
  int single_lidar_data_size() const;
  void clear_single_lidar_data();
  static const int kSingleLidarDataFieldNumber = 3;
  const ::calmcar::perception::SingleLidarData& single_lidar_data(int index) const;
  ::calmcar::perception::SingleLidarData* mutable_single_lidar_data(int index);
  ::calmcar::perception::SingleLidarData* add_single_lidar_data();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::SingleLidarData >*
      mutable_single_lidar_data();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::SingleLidarData >&
      single_lidar_data() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 frame_index = 2;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 2;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.RawLidarFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::SingleLidarData > single_lidar_data_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 frame_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_ccperception_2eproto::TableStruct;
  friend void ::protobuf_ccperception_2eproto::InitDefaultsRawLidarFrameImpl();
};
// -------------------------------------------------------------------

class CCPerceptionFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.CCPerceptionFrame) */ {
 public:
  CCPerceptionFrame();
  virtual ~CCPerceptionFrame();

  CCPerceptionFrame(const CCPerceptionFrame& from);

  inline CCPerceptionFrame& operator=(const CCPerceptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CCPerceptionFrame(CCPerceptionFrame&& from) noexcept
    : CCPerceptionFrame() {
    *this = ::std::move(from);
  }

  inline CCPerceptionFrame& operator=(CCPerceptionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CCPerceptionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CCPerceptionFrame* internal_default_instance() {
    return reinterpret_cast<const CCPerceptionFrame*>(
               &_CCPerceptionFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CCPerceptionFrame* other);
  friend void swap(CCPerceptionFrame& a, CCPerceptionFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CCPerceptionFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  CCPerceptionFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CCPerceptionFrame& from);
  void MergeFrom(const CCPerceptionFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CCPerceptionFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.PerceptionFrame vision_perception = 5;
  bool has_vision_perception() const;
  void clear_vision_perception();
  static const int kVisionPerceptionFieldNumber = 5;
  const ::calmcar::perception::PerceptionFrame& vision_perception() const;
  ::calmcar::perception::PerceptionFrame* release_vision_perception();
  ::calmcar::perception::PerceptionFrame* mutable_vision_perception();
  void set_allocated_vision_perception(::calmcar::perception::PerceptionFrame* vision_perception);

  // .calmcar.perception.LidarPerceptionFrame lidar_perception = 7;
  bool has_lidar_perception() const;
  void clear_lidar_perception();
  static const int kLidarPerceptionFieldNumber = 7;
  const ::calmcar::perception::LidarPerceptionFrame& lidar_perception() const;
  ::calmcar::perception::LidarPerceptionFrame* release_lidar_perception();
  ::calmcar::perception::LidarPerceptionFrame* mutable_lidar_perception();
  void set_allocated_lidar_perception(::calmcar::perception::LidarPerceptionFrame* lidar_perception);

  // .calmcar.perception.PerceptionFrame fusion_perception = 9;
  bool has_fusion_perception() const;
  void clear_fusion_perception();
  static const int kFusionPerceptionFieldNumber = 9;
  const ::calmcar::perception::PerceptionFrame& fusion_perception() const;
  ::calmcar::perception::PerceptionFrame* release_fusion_perception();
  ::calmcar::perception::PerceptionFrame* mutable_fusion_perception();
  void set_allocated_fusion_perception(::calmcar::perception::PerceptionFrame* fusion_perception);

  // .calmcar.perception.RawLidarFrame raw_lidar_frame = 21;
  bool has_raw_lidar_frame() const;
  void clear_raw_lidar_frame();
  static const int kRawLidarFrameFieldNumber = 21;
  const ::calmcar::perception::RawLidarFrame& raw_lidar_frame() const;
  ::calmcar::perception::RawLidarFrame* release_raw_lidar_frame();
  ::calmcar::perception::RawLidarFrame* mutable_raw_lidar_frame();
  void set_allocated_raw_lidar_frame(::calmcar::perception::RawLidarFrame* raw_lidar_frame);

  // .vehicle_info.proto_msg.VehicleInfo vehicle_info = 22;
  bool has_vehicle_info() const;
  void clear_vehicle_info();
  static const int kVehicleInfoFieldNumber = 22;
  const ::vehicle_info::proto_msg::VehicleInfo& vehicle_info() const;
  ::vehicle_info::proto_msg::VehicleInfo* release_vehicle_info();
  ::vehicle_info::proto_msg::VehicleInfo* mutable_vehicle_info();
  void set_allocated_vehicle_info(::vehicle_info::proto_msg::VehicleInfo* vehicle_info);

  // uint64 sync_timestamp = 1;
  void clear_sync_timestamp();
  static const int kSyncTimestampFieldNumber = 1;
  ::google::protobuf::uint64 sync_timestamp() const;
  void set_sync_timestamp(::google::protobuf::uint64 value);

  // uint64 camera_timestamp = 2;
  void clear_camera_timestamp();
  static const int kCameraTimestampFieldNumber = 2;
  ::google::protobuf::uint64 camera_timestamp() const;
  void set_camera_timestamp(::google::protobuf::uint64 value);

  // uint64 lidar_timestamp = 3;
  void clear_lidar_timestamp();
  static const int kLidarTimestampFieldNumber = 3;
  ::google::protobuf::uint64 lidar_timestamp() const;
  void set_lidar_timestamp(::google::protobuf::uint64 value);

  // bool enable_camera_output = 4;
  void clear_enable_camera_output();
  static const int kEnableCameraOutputFieldNumber = 4;
  bool enable_camera_output() const;
  void set_enable_camera_output(bool value);

  // bool enable_lidar_output = 6;
  void clear_enable_lidar_output();
  static const int kEnableLidarOutputFieldNumber = 6;
  bool enable_lidar_output() const;
  void set_enable_lidar_output(bool value);

  // bool enable_fusion_output = 8;
  void clear_enable_fusion_output();
  static const int kEnableFusionOutputFieldNumber = 8;
  bool enable_fusion_output() const;
  void set_enable_fusion_output(bool value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.CCPerceptionFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::PerceptionFrame* vision_perception_;
  ::calmcar::perception::LidarPerceptionFrame* lidar_perception_;
  ::calmcar::perception::PerceptionFrame* fusion_perception_;
  ::calmcar::perception::RawLidarFrame* raw_lidar_frame_;
  ::vehicle_info::proto_msg::VehicleInfo* vehicle_info_;
  ::google::protobuf::uint64 sync_timestamp_;
  ::google::protobuf::uint64 camera_timestamp_;
  ::google::protobuf::uint64 lidar_timestamp_;
  bool enable_camera_output_;
  bool enable_lidar_output_;
  bool enable_fusion_output_;
  mutable int _cached_size_;
  friend struct ::protobuf_ccperception_2eproto::TableStruct;
  friend void ::protobuf_ccperception_2eproto::InitDefaultsCCPerceptionFrameImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PointXYZI

// float x = 1;
inline void PointXYZI::clear_x() {
  x_ = 0;
}
inline float PointXYZI::x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PointXYZI.x)
  return x_;
}
inline void PointXYZI::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PointXYZI.x)
}

// float y = 2;
inline void PointXYZI::clear_y() {
  y_ = 0;
}
inline float PointXYZI::y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PointXYZI.y)
  return y_;
}
inline void PointXYZI::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PointXYZI.y)
}

// float z = 3;
inline void PointXYZI::clear_z() {
  z_ = 0;
}
inline float PointXYZI::z() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PointXYZI.z)
  return z_;
}
inline void PointXYZI::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PointXYZI.z)
}

// int32 i = 4;
inline void PointXYZI::clear_i() {
  i_ = 0;
}
inline ::google::protobuf::int32 PointXYZI::i() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PointXYZI.i)
  return i_;
}
inline void PointXYZI::set_i(::google::protobuf::int32 value) {
  
  i_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PointXYZI.i)
}

// -------------------------------------------------------------------

// SingleLidarData

// int64 timestamp = 1;
inline void SingleLidarData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SingleLidarData::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.timestamp)
  return timestamp_;
}
inline void SingleLidarData::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.timestamp)
}

// int32 lidar_sensor_id = 2;
inline void SingleLidarData::clear_lidar_sensor_id() {
  lidar_sensor_id_ = 0;
}
inline ::google::protobuf::int32 SingleLidarData::lidar_sensor_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.lidar_sensor_id)
  return lidar_sensor_id_;
}
inline void SingleLidarData::set_lidar_sensor_id(::google::protobuf::int32 value) {
  
  lidar_sensor_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.lidar_sensor_id)
}

// string lidar_sensor_name = 3;
inline void SingleLidarData::clear_lidar_sensor_name() {
  lidar_sensor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SingleLidarData::lidar_sensor_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.lidar_sensor_name)
  return lidar_sensor_name_.GetNoArena();
}
inline void SingleLidarData::set_lidar_sensor_name(const ::std::string& value) {
  
  lidar_sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.lidar_sensor_name)
}
#if LANG_CXX11
inline void SingleLidarData::set_lidar_sensor_name(::std::string&& value) {
  
  lidar_sensor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.SingleLidarData.lidar_sensor_name)
}
#endif
inline void SingleLidarData::set_lidar_sensor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lidar_sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.SingleLidarData.lidar_sensor_name)
}
inline void SingleLidarData::set_lidar_sensor_name(const char* value, size_t size) {
  
  lidar_sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.SingleLidarData.lidar_sensor_name)
}
inline ::std::string* SingleLidarData::mutable_lidar_sensor_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.SingleLidarData.lidar_sensor_name)
  return lidar_sensor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SingleLidarData::release_lidar_sensor_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.SingleLidarData.lidar_sensor_name)
  
  return lidar_sensor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SingleLidarData::set_allocated_lidar_sensor_name(::std::string* lidar_sensor_name) {
  if (lidar_sensor_name != NULL) {
    
  } else {
    
  }
  lidar_sensor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lidar_sensor_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.SingleLidarData.lidar_sensor_name)
}

// repeated .calmcar.perception.PointXYZI points = 4;
inline int SingleLidarData::points_size() const {
  return points_.size();
}
inline void SingleLidarData::clear_points() {
  points_.Clear();
}
inline const ::calmcar::perception::PointXYZI& SingleLidarData::points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.points)
  return points_.Get(index);
}
inline ::calmcar::perception::PointXYZI* SingleLidarData::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.SingleLidarData.points)
  return points_.Mutable(index);
}
inline ::calmcar::perception::PointXYZI* SingleLidarData::add_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.SingleLidarData.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::PointXYZI >*
SingleLidarData::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.SingleLidarData.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::PointXYZI >&
SingleLidarData::points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.SingleLidarData.points)
  return points_;
}

// repeated bytes scan_msg = 5;
inline int SingleLidarData::scan_msg_size() const {
  return scan_msg_.size();
}
inline void SingleLidarData::clear_scan_msg() {
  scan_msg_.Clear();
}
inline const ::std::string& SingleLidarData::scan_msg(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.scan_msg)
  return scan_msg_.Get(index);
}
inline ::std::string* SingleLidarData::mutable_scan_msg(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.SingleLidarData.scan_msg)
  return scan_msg_.Mutable(index);
}
inline void SingleLidarData::set_scan_msg(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.scan_msg)
  scan_msg_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SingleLidarData::set_scan_msg(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.scan_msg)
  scan_msg_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SingleLidarData::set_scan_msg(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scan_msg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:calmcar.perception.SingleLidarData.scan_msg)
}
inline void SingleLidarData::set_scan_msg(int index, const void* value, size_t size) {
  scan_msg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.SingleLidarData.scan_msg)
}
inline ::std::string* SingleLidarData::add_scan_msg() {
  // @@protoc_insertion_point(field_add_mutable:calmcar.perception.SingleLidarData.scan_msg)
  return scan_msg_.Add();
}
inline void SingleLidarData::add_scan_msg(const ::std::string& value) {
  scan_msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:calmcar.perception.SingleLidarData.scan_msg)
}
#if LANG_CXX11
inline void SingleLidarData::add_scan_msg(::std::string&& value) {
  scan_msg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:calmcar.perception.SingleLidarData.scan_msg)
}
#endif
inline void SingleLidarData::add_scan_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scan_msg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:calmcar.perception.SingleLidarData.scan_msg)
}
inline void SingleLidarData::add_scan_msg(const void* value, size_t size) {
  scan_msg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:calmcar.perception.SingleLidarData.scan_msg)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SingleLidarData::scan_msg() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.SingleLidarData.scan_msg)
  return scan_msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SingleLidarData::mutable_scan_msg() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.SingleLidarData.scan_msg)
  return &scan_msg_;
}

// bytes difop_msg = 6;
inline void SingleLidarData::clear_difop_msg() {
  difop_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SingleLidarData::difop_msg() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.difop_msg)
  return difop_msg_.GetNoArena();
}
inline void SingleLidarData::set_difop_msg(const ::std::string& value) {
  
  difop_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.difop_msg)
}
#if LANG_CXX11
inline void SingleLidarData::set_difop_msg(::std::string&& value) {
  
  difop_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.SingleLidarData.difop_msg)
}
#endif
inline void SingleLidarData::set_difop_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  difop_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.SingleLidarData.difop_msg)
}
inline void SingleLidarData::set_difop_msg(const void* value, size_t size) {
  
  difop_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.SingleLidarData.difop_msg)
}
inline ::std::string* SingleLidarData::mutable_difop_msg() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.SingleLidarData.difop_msg)
  return difop_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SingleLidarData::release_difop_msg() {
  // @@protoc_insertion_point(field_release:calmcar.perception.SingleLidarData.difop_msg)
  
  return difop_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SingleLidarData::set_allocated_difop_msg(::std::string* difop_msg) {
  if (difop_msg != NULL) {
    
  } else {
    
  }
  difop_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), difop_msg);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.SingleLidarData.difop_msg)
}

// float offset_x = 7;
inline void SingleLidarData::clear_offset_x() {
  offset_x_ = 0;
}
inline float SingleLidarData::offset_x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.offset_x)
  return offset_x_;
}
inline void SingleLidarData::set_offset_x(float value) {
  
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.offset_x)
}

// float offset_y = 8;
inline void SingleLidarData::clear_offset_y() {
  offset_y_ = 0;
}
inline float SingleLidarData::offset_y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.offset_y)
  return offset_y_;
}
inline void SingleLidarData::set_offset_y(float value) {
  
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.offset_y)
}

// float offset_z = 9;
inline void SingleLidarData::clear_offset_z() {
  offset_z_ = 0;
}
inline float SingleLidarData::offset_z() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.offset_z)
  return offset_z_;
}
inline void SingleLidarData::set_offset_z(float value) {
  
  offset_z_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.offset_z)
}

// float yaw = 10;
inline void SingleLidarData::clear_yaw() {
  yaw_ = 0;
}
inline float SingleLidarData::yaw() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.yaw)
  return yaw_;
}
inline void SingleLidarData::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.yaw)
}

// float roll = 11;
inline void SingleLidarData::clear_roll() {
  roll_ = 0;
}
inline float SingleLidarData::roll() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.roll)
  return roll_;
}
inline void SingleLidarData::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.roll)
}

// float pitch = 12;
inline void SingleLidarData::clear_pitch() {
  pitch_ = 0;
}
inline float SingleLidarData::pitch() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.pitch)
  return pitch_;
}
inline void SingleLidarData::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.pitch)
}

// string lidar_sensor_type = 13;
inline void SingleLidarData::clear_lidar_sensor_type() {
  lidar_sensor_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SingleLidarData::lidar_sensor_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.SingleLidarData.lidar_sensor_type)
  return lidar_sensor_type_.GetNoArena();
}
inline void SingleLidarData::set_lidar_sensor_type(const ::std::string& value) {
  
  lidar_sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.SingleLidarData.lidar_sensor_type)
}
#if LANG_CXX11
inline void SingleLidarData::set_lidar_sensor_type(::std::string&& value) {
  
  lidar_sensor_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.SingleLidarData.lidar_sensor_type)
}
#endif
inline void SingleLidarData::set_lidar_sensor_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lidar_sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.SingleLidarData.lidar_sensor_type)
}
inline void SingleLidarData::set_lidar_sensor_type(const char* value, size_t size) {
  
  lidar_sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.SingleLidarData.lidar_sensor_type)
}
inline ::std::string* SingleLidarData::mutable_lidar_sensor_type() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.SingleLidarData.lidar_sensor_type)
  return lidar_sensor_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SingleLidarData::release_lidar_sensor_type() {
  // @@protoc_insertion_point(field_release:calmcar.perception.SingleLidarData.lidar_sensor_type)
  
  return lidar_sensor_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SingleLidarData::set_allocated_lidar_sensor_type(::std::string* lidar_sensor_type) {
  if (lidar_sensor_type != NULL) {
    
  } else {
    
  }
  lidar_sensor_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lidar_sensor_type);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.SingleLidarData.lidar_sensor_type)
}

// -------------------------------------------------------------------

// RawLidarFrame

// int64 timestamp = 1;
inline void RawLidarFrame::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RawLidarFrame::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RawLidarFrame.timestamp)
  return timestamp_;
}
inline void RawLidarFrame::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RawLidarFrame.timestamp)
}

// int64 frame_index = 2;
inline void RawLidarFrame::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RawLidarFrame::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RawLidarFrame.frame_index)
  return frame_index_;
}
inline void RawLidarFrame::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RawLidarFrame.frame_index)
}

// repeated .calmcar.perception.SingleLidarData single_lidar_data = 3;
inline int RawLidarFrame::single_lidar_data_size() const {
  return single_lidar_data_.size();
}
inline void RawLidarFrame::clear_single_lidar_data() {
  single_lidar_data_.Clear();
}
inline const ::calmcar::perception::SingleLidarData& RawLidarFrame::single_lidar_data(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RawLidarFrame.single_lidar_data)
  return single_lidar_data_.Get(index);
}
inline ::calmcar::perception::SingleLidarData* RawLidarFrame::mutable_single_lidar_data(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.RawLidarFrame.single_lidar_data)
  return single_lidar_data_.Mutable(index);
}
inline ::calmcar::perception::SingleLidarData* RawLidarFrame::add_single_lidar_data() {
  // @@protoc_insertion_point(field_add:calmcar.perception.RawLidarFrame.single_lidar_data)
  return single_lidar_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::SingleLidarData >*
RawLidarFrame::mutable_single_lidar_data() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.RawLidarFrame.single_lidar_data)
  return &single_lidar_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::SingleLidarData >&
RawLidarFrame::single_lidar_data() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.RawLidarFrame.single_lidar_data)
  return single_lidar_data_;
}

// -------------------------------------------------------------------

// CCPerceptionFrame

// uint64 sync_timestamp = 1;
inline void CCPerceptionFrame::clear_sync_timestamp() {
  sync_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CCPerceptionFrame::sync_timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.sync_timestamp)
  return sync_timestamp_;
}
inline void CCPerceptionFrame::set_sync_timestamp(::google::protobuf::uint64 value) {
  
  sync_timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.sync_timestamp)
}

// uint64 camera_timestamp = 2;
inline void CCPerceptionFrame::clear_camera_timestamp() {
  camera_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CCPerceptionFrame::camera_timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.camera_timestamp)
  return camera_timestamp_;
}
inline void CCPerceptionFrame::set_camera_timestamp(::google::protobuf::uint64 value) {
  
  camera_timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.camera_timestamp)
}

// uint64 lidar_timestamp = 3;
inline void CCPerceptionFrame::clear_lidar_timestamp() {
  lidar_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CCPerceptionFrame::lidar_timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.lidar_timestamp)
  return lidar_timestamp_;
}
inline void CCPerceptionFrame::set_lidar_timestamp(::google::protobuf::uint64 value) {
  
  lidar_timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.lidar_timestamp)
}

// bool enable_camera_output = 4;
inline void CCPerceptionFrame::clear_enable_camera_output() {
  enable_camera_output_ = false;
}
inline bool CCPerceptionFrame::enable_camera_output() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.enable_camera_output)
  return enable_camera_output_;
}
inline void CCPerceptionFrame::set_enable_camera_output(bool value) {
  
  enable_camera_output_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.enable_camera_output)
}

// .calmcar.perception.PerceptionFrame vision_perception = 5;
inline bool CCPerceptionFrame::has_vision_perception() const {
  return this != internal_default_instance() && vision_perception_ != NULL;
}
inline const ::calmcar::perception::PerceptionFrame& CCPerceptionFrame::vision_perception() const {
  const ::calmcar::perception::PerceptionFrame* p = vision_perception_;
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.vision_perception)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::PerceptionFrame*>(
      &::calmcar::perception::_PerceptionFrame_default_instance_);
}
inline ::calmcar::perception::PerceptionFrame* CCPerceptionFrame::release_vision_perception() {
  // @@protoc_insertion_point(field_release:calmcar.perception.CCPerceptionFrame.vision_perception)
  
  ::calmcar::perception::PerceptionFrame* temp = vision_perception_;
  vision_perception_ = NULL;
  return temp;
}
inline ::calmcar::perception::PerceptionFrame* CCPerceptionFrame::mutable_vision_perception() {
  
  if (vision_perception_ == NULL) {
    vision_perception_ = new ::calmcar::perception::PerceptionFrame;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.CCPerceptionFrame.vision_perception)
  return vision_perception_;
}
inline void CCPerceptionFrame::set_allocated_vision_perception(::calmcar::perception::PerceptionFrame* vision_perception) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vision_perception_);
  }
  if (vision_perception) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vision_perception = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vision_perception, submessage_arena);
    }
    
  } else {
    
  }
  vision_perception_ = vision_perception;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.CCPerceptionFrame.vision_perception)
}

// bool enable_lidar_output = 6;
inline void CCPerceptionFrame::clear_enable_lidar_output() {
  enable_lidar_output_ = false;
}
inline bool CCPerceptionFrame::enable_lidar_output() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.enable_lidar_output)
  return enable_lidar_output_;
}
inline void CCPerceptionFrame::set_enable_lidar_output(bool value) {
  
  enable_lidar_output_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.enable_lidar_output)
}

// .calmcar.perception.LidarPerceptionFrame lidar_perception = 7;
inline bool CCPerceptionFrame::has_lidar_perception() const {
  return this != internal_default_instance() && lidar_perception_ != NULL;
}
inline const ::calmcar::perception::LidarPerceptionFrame& CCPerceptionFrame::lidar_perception() const {
  const ::calmcar::perception::LidarPerceptionFrame* p = lidar_perception_;
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.lidar_perception)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::LidarPerceptionFrame*>(
      &::calmcar::perception::_LidarPerceptionFrame_default_instance_);
}
inline ::calmcar::perception::LidarPerceptionFrame* CCPerceptionFrame::release_lidar_perception() {
  // @@protoc_insertion_point(field_release:calmcar.perception.CCPerceptionFrame.lidar_perception)
  
  ::calmcar::perception::LidarPerceptionFrame* temp = lidar_perception_;
  lidar_perception_ = NULL;
  return temp;
}
inline ::calmcar::perception::LidarPerceptionFrame* CCPerceptionFrame::mutable_lidar_perception() {
  
  if (lidar_perception_ == NULL) {
    lidar_perception_ = new ::calmcar::perception::LidarPerceptionFrame;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.CCPerceptionFrame.lidar_perception)
  return lidar_perception_;
}
inline void CCPerceptionFrame::set_allocated_lidar_perception(::calmcar::perception::LidarPerceptionFrame* lidar_perception) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lidar_perception_);
  }
  if (lidar_perception) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lidar_perception = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lidar_perception, submessage_arena);
    }
    
  } else {
    
  }
  lidar_perception_ = lidar_perception;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.CCPerceptionFrame.lidar_perception)
}

// bool enable_fusion_output = 8;
inline void CCPerceptionFrame::clear_enable_fusion_output() {
  enable_fusion_output_ = false;
}
inline bool CCPerceptionFrame::enable_fusion_output() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.enable_fusion_output)
  return enable_fusion_output_;
}
inline void CCPerceptionFrame::set_enable_fusion_output(bool value) {
  
  enable_fusion_output_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.CCPerceptionFrame.enable_fusion_output)
}

// .calmcar.perception.PerceptionFrame fusion_perception = 9;
inline bool CCPerceptionFrame::has_fusion_perception() const {
  return this != internal_default_instance() && fusion_perception_ != NULL;
}
inline const ::calmcar::perception::PerceptionFrame& CCPerceptionFrame::fusion_perception() const {
  const ::calmcar::perception::PerceptionFrame* p = fusion_perception_;
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.fusion_perception)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::PerceptionFrame*>(
      &::calmcar::perception::_PerceptionFrame_default_instance_);
}
inline ::calmcar::perception::PerceptionFrame* CCPerceptionFrame::release_fusion_perception() {
  // @@protoc_insertion_point(field_release:calmcar.perception.CCPerceptionFrame.fusion_perception)
  
  ::calmcar::perception::PerceptionFrame* temp = fusion_perception_;
  fusion_perception_ = NULL;
  return temp;
}
inline ::calmcar::perception::PerceptionFrame* CCPerceptionFrame::mutable_fusion_perception() {
  
  if (fusion_perception_ == NULL) {
    fusion_perception_ = new ::calmcar::perception::PerceptionFrame;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.CCPerceptionFrame.fusion_perception)
  return fusion_perception_;
}
inline void CCPerceptionFrame::set_allocated_fusion_perception(::calmcar::perception::PerceptionFrame* fusion_perception) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(fusion_perception_);
  }
  if (fusion_perception) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fusion_perception = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fusion_perception, submessage_arena);
    }
    
  } else {
    
  }
  fusion_perception_ = fusion_perception;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.CCPerceptionFrame.fusion_perception)
}

// .calmcar.perception.RawLidarFrame raw_lidar_frame = 21;
inline bool CCPerceptionFrame::has_raw_lidar_frame() const {
  return this != internal_default_instance() && raw_lidar_frame_ != NULL;
}
inline void CCPerceptionFrame::clear_raw_lidar_frame() {
  if (GetArenaNoVirtual() == NULL && raw_lidar_frame_ != NULL) {
    delete raw_lidar_frame_;
  }
  raw_lidar_frame_ = NULL;
}
inline const ::calmcar::perception::RawLidarFrame& CCPerceptionFrame::raw_lidar_frame() const {
  const ::calmcar::perception::RawLidarFrame* p = raw_lidar_frame_;
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.raw_lidar_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::RawLidarFrame*>(
      &::calmcar::perception::_RawLidarFrame_default_instance_);
}
inline ::calmcar::perception::RawLidarFrame* CCPerceptionFrame::release_raw_lidar_frame() {
  // @@protoc_insertion_point(field_release:calmcar.perception.CCPerceptionFrame.raw_lidar_frame)
  
  ::calmcar::perception::RawLidarFrame* temp = raw_lidar_frame_;
  raw_lidar_frame_ = NULL;
  return temp;
}
inline ::calmcar::perception::RawLidarFrame* CCPerceptionFrame::mutable_raw_lidar_frame() {
  
  if (raw_lidar_frame_ == NULL) {
    raw_lidar_frame_ = new ::calmcar::perception::RawLidarFrame;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.CCPerceptionFrame.raw_lidar_frame)
  return raw_lidar_frame_;
}
inline void CCPerceptionFrame::set_allocated_raw_lidar_frame(::calmcar::perception::RawLidarFrame* raw_lidar_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete raw_lidar_frame_;
  }
  if (raw_lidar_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      raw_lidar_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_lidar_frame, submessage_arena);
    }
    
  } else {
    
  }
  raw_lidar_frame_ = raw_lidar_frame;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.CCPerceptionFrame.raw_lidar_frame)
}

// .vehicle_info.proto_msg.VehicleInfo vehicle_info = 22;
inline bool CCPerceptionFrame::has_vehicle_info() const {
  return this != internal_default_instance() && vehicle_info_ != NULL;
}
inline const ::vehicle_info::proto_msg::VehicleInfo& CCPerceptionFrame::vehicle_info() const {
  const ::vehicle_info::proto_msg::VehicleInfo* p = vehicle_info_;
  // @@protoc_insertion_point(field_get:calmcar.perception.CCPerceptionFrame.vehicle_info)
  return p != NULL ? *p : *reinterpret_cast<const ::vehicle_info::proto_msg::VehicleInfo*>(
      &::vehicle_info::proto_msg::_VehicleInfo_default_instance_);
}
inline ::vehicle_info::proto_msg::VehicleInfo* CCPerceptionFrame::release_vehicle_info() {
  // @@protoc_insertion_point(field_release:calmcar.perception.CCPerceptionFrame.vehicle_info)
  
  ::vehicle_info::proto_msg::VehicleInfo* temp = vehicle_info_;
  vehicle_info_ = NULL;
  return temp;
}
inline ::vehicle_info::proto_msg::VehicleInfo* CCPerceptionFrame::mutable_vehicle_info() {
  
  if (vehicle_info_ == NULL) {
    vehicle_info_ = new ::vehicle_info::proto_msg::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.CCPerceptionFrame.vehicle_info)
  return vehicle_info_;
}
inline void CCPerceptionFrame::set_allocated_vehicle_info(::vehicle_info::proto_msg::VehicleInfo* vehicle_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vehicle_info_);
  }
  if (vehicle_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_info, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_info_ = vehicle_info;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.CCPerceptionFrame.vehicle_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace calmcar

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ccperception_2eproto__INCLUDED
