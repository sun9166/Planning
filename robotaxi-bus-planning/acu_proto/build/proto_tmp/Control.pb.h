// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Control.proto

#ifndef PROTOBUF_Control_2eproto__INCLUDED
#define PROTOBUF_Control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Control_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTimeStatusImpl();
void InitDefaultsTimeStatus();
void InitDefaultsTimeStatisticsImpl();
void InitDefaultsTimeStatistics();
void InitDefaultsFaultInfoImpl();
void InitDefaultsFaultInfo();
void InitDefaultsFaultVecImpl();
void InitDefaultsFaultVec();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsVehicleInfoImpl();
void InitDefaultsVehicleInfo();
void InitDefaultsControlFeedbackImpl();
void InitDefaultsControlFeedback();
void InitDefaultsLatcontrolImpl();
void InitDefaultsLatcontrol();
void InitDefaultsLoncontrolImpl();
void InitDefaultsLoncontrol();
void InitDefaultsSystemControlImpl();
void InitDefaultsSystemControl();
inline void InitDefaults() {
  InitDefaultsTimeStatus();
  InitDefaultsTimeStatistics();
  InitDefaultsFaultInfo();
  InitDefaultsFaultVec();
  InitDefaultsHeader();
  InitDefaultsVehicleInfo();
  InitDefaultsControlFeedback();
  InitDefaultsLatcontrol();
  InitDefaultsLoncontrol();
  InitDefaultsSystemControl();
}
}  // namespace protobuf_Control_2eproto
namespace Control {
namespace proto {
class ControlFeedback;
class ControlFeedbackDefaultTypeInternal;
extern ControlFeedbackDefaultTypeInternal _ControlFeedback_default_instance_;
class FaultInfo;
class FaultInfoDefaultTypeInternal;
extern FaultInfoDefaultTypeInternal _FaultInfo_default_instance_;
class FaultVec;
class FaultVecDefaultTypeInternal;
extern FaultVecDefaultTypeInternal _FaultVec_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Latcontrol;
class LatcontrolDefaultTypeInternal;
extern LatcontrolDefaultTypeInternal _Latcontrol_default_instance_;
class Loncontrol;
class LoncontrolDefaultTypeInternal;
extern LoncontrolDefaultTypeInternal _Loncontrol_default_instance_;
class SystemControl;
class SystemControlDefaultTypeInternal;
extern SystemControlDefaultTypeInternal _SystemControl_default_instance_;
class TimeStatistics;
class TimeStatisticsDefaultTypeInternal;
extern TimeStatisticsDefaultTypeInternal _TimeStatistics_default_instance_;
class TimeStatus;
class TimeStatusDefaultTypeInternal;
extern TimeStatusDefaultTypeInternal _TimeStatus_default_instance_;
class VehicleInfo;
class VehicleInfoDefaultTypeInternal;
extern VehicleInfoDefaultTypeInternal _VehicleInfo_default_instance_;
}  // namespace proto
}  // namespace Control
namespace Control {
namespace proto {

// ===================================================================

class TimeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.TimeStatus) */ {
 public:
  TimeStatus();
  virtual ~TimeStatus();

  TimeStatus(const TimeStatus& from);

  inline TimeStatus& operator=(const TimeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeStatus(TimeStatus&& from) noexcept
    : TimeStatus() {
    *this = ::std::move(from);
  }

  inline TimeStatus& operator=(TimeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeStatus* internal_default_instance() {
    return reinterpret_cast<const TimeStatus*>(
               &_TimeStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TimeStatus* other);
  friend void swap(TimeStatus& a, TimeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeStatus& from);
  void MergeFrom(const TimeStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string source_node_name = 2;
  void clear_source_node_name();
  static const int kSourceNodeNameFieldNumber = 2;
  const ::std::string& source_node_name() const;
  void set_source_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_source_node_name(::std::string&& value);
  #endif
  void set_source_node_name(const char* value);
  void set_source_node_name(const char* value, size_t size);
  ::std::string* mutable_source_node_name();
  ::std::string* release_source_node_name();
  void set_allocated_source_node_name(::std::string* source_node_name);

  // string destination_node_name = 3;
  void clear_destination_node_name();
  static const int kDestinationNodeNameFieldNumber = 3;
  const ::std::string& destination_node_name() const;
  void set_destination_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_destination_node_name(::std::string&& value);
  #endif
  void set_destination_node_name(const char* value);
  void set_destination_node_name(const char* value, size_t size);
  ::std::string* mutable_destination_node_name();
  ::std::string* release_destination_node_name();
  void set_allocated_destination_node_name(::std::string* destination_node_name);

  // double dtime = 1;
  void clear_dtime();
  static const int kDtimeFieldNumber = 1;
  double dtime() const;
  void set_dtime(double value);

  // @@protoc_insertion_point(class_scope:Control.proto.TimeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_node_name_;
  ::google::protobuf::internal::ArenaStringPtr destination_node_name_;
  double dtime_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsTimeStatusImpl();
};
// -------------------------------------------------------------------

class TimeStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.TimeStatistics) */ {
 public:
  TimeStatistics();
  virtual ~TimeStatistics();

  TimeStatistics(const TimeStatistics& from);

  inline TimeStatistics& operator=(const TimeStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeStatistics(TimeStatistics&& from) noexcept
    : TimeStatistics() {
    *this = ::std::move(from);
  }

  inline TimeStatistics& operator=(TimeStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeStatistics* internal_default_instance() {
    return reinterpret_cast<const TimeStatistics*>(
               &_TimeStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TimeStatistics* other);
  friend void swap(TimeStatistics& a, TimeStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeStatistics& from);
  void MergeFrom(const TimeStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeStatistics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Control.proto.TimeStatus dev_time_status_msg = 1;
  int dev_time_status_msg_size() const;
  void clear_dev_time_status_msg();
  static const int kDevTimeStatusMsgFieldNumber = 1;
  const ::Control::proto::TimeStatus& dev_time_status_msg(int index) const;
  ::Control::proto::TimeStatus* mutable_dev_time_status_msg(int index);
  ::Control::proto::TimeStatus* add_dev_time_status_msg();
  ::google::protobuf::RepeatedPtrField< ::Control::proto::TimeStatus >*
      mutable_dev_time_status_msg();
  const ::google::protobuf::RepeatedPtrField< ::Control::proto::TimeStatus >&
      dev_time_status_msg() const;

  // double sending_timestamp = 2;
  void clear_sending_timestamp();
  static const int kSendingTimestampFieldNumber = 2;
  double sending_timestamp() const;
  void set_sending_timestamp(double value);

  // @@protoc_insertion_point(class_scope:Control.proto.TimeStatistics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Control::proto::TimeStatus > dev_time_status_msg_;
  double sending_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsTimeStatisticsImpl();
};
// -------------------------------------------------------------------

class FaultInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.FaultInfo) */ {
 public:
  FaultInfo();
  virtual ~FaultInfo();

  FaultInfo(const FaultInfo& from);

  inline FaultInfo& operator=(const FaultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaultInfo(FaultInfo&& from) noexcept
    : FaultInfo() {
    *this = ::std::move(from);
  }

  inline FaultInfo& operator=(FaultInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaultInfo* internal_default_instance() {
    return reinterpret_cast<const FaultInfo*>(
               &_FaultInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FaultInfo* other);
  friend void swap(FaultInfo& a, FaultInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaultInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  FaultInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaultInfo& from);
  void MergeFrom(const FaultInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaultInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string module_name = 2;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 2;
  const ::std::string& module_name() const;
  void set_module_name(const ::std::string& value);
  #if LANG_CXX11
  void set_module_name(::std::string&& value);
  #endif
  void set_module_name(const char* value);
  void set_module_name(const char* value, size_t size);
  ::std::string* mutable_module_name();
  ::std::string* release_module_name();
  void set_allocated_module_name(::std::string* module_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string msg = 5;
  void clear_msg();
  static const int kMsgFieldNumber = 5;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // double timestamp_sec = 1;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // int32 error_code = 4;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // int32 fault_level = 6;
  void clear_fault_level();
  static const int kFaultLevelFieldNumber = 6;
  ::google::protobuf::int32 fault_level() const;
  void set_fault_level(::google::protobuf::int32 value);

  // int32 fault_type = 7;
  void clear_fault_type();
  static const int kFaultTypeFieldNumber = 7;
  ::google::protobuf::int32 fault_type() const;
  void set_fault_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.FaultInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr module_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  double timestamp_sec_;
  ::google::protobuf::int32 error_code_;
  ::google::protobuf::int32 fault_level_;
  ::google::protobuf::int32 fault_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsFaultInfoImpl();
};
// -------------------------------------------------------------------

class FaultVec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.FaultVec) */ {
 public:
  FaultVec();
  virtual ~FaultVec();

  FaultVec(const FaultVec& from);

  inline FaultVec& operator=(const FaultVec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaultVec(FaultVec&& from) noexcept
    : FaultVec() {
    *this = ::std::move(from);
  }

  inline FaultVec& operator=(FaultVec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultVec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaultVec* internal_default_instance() {
    return reinterpret_cast<const FaultVec*>(
               &_FaultVec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FaultVec* other);
  friend void swap(FaultVec& a, FaultVec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaultVec* New() const PROTOBUF_FINAL { return New(NULL); }

  FaultVec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaultVec& from);
  void MergeFrom(const FaultVec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaultVec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Control.proto.FaultInfo info_vec = 1;
  int info_vec_size() const;
  void clear_info_vec();
  static const int kInfoVecFieldNumber = 1;
  const ::Control::proto::FaultInfo& info_vec(int index) const;
  ::Control::proto::FaultInfo* mutable_info_vec(int index);
  ::Control::proto::FaultInfo* add_info_vec();
  ::google::protobuf::RepeatedPtrField< ::Control::proto::FaultInfo >*
      mutable_info_vec();
  const ::google::protobuf::RepeatedPtrField< ::Control::proto::FaultInfo >&
      info_vec() const;

  // int32 module_fault_level = 2;
  void clear_module_fault_level();
  static const int kModuleFaultLevelFieldNumber = 2;
  ::google::protobuf::int32 module_fault_level() const;
  void set_module_fault_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.FaultVec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Control::proto::FaultInfo > info_vec_;
  ::google::protobuf::int32 module_fault_level_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsFaultVecImpl();
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string module_name = 3;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  const ::std::string& module_name() const;
  void set_module_name(const ::std::string& value);
  #if LANG_CXX11
  void set_module_name(::std::string&& value);
  #endif
  void set_module_name(const char* value);
  void set_module_name(const char* value, size_t size);
  ::std::string* mutable_module_name();
  ::std::string* release_module_name();
  void set_allocated_module_name(::std::string* module_name);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .Control.proto.FaultVec fault_vec = 5;
  bool has_fault_vec() const;
  void clear_fault_vec();
  static const int kFaultVecFieldNumber = 5;
  const ::Control::proto::FaultVec& fault_vec() const;
  ::Control::proto::FaultVec* release_fault_vec();
  ::Control::proto::FaultVec* mutable_fault_vec();
  void set_allocated_fault_vec(::Control::proto::FaultVec* fault_vec);

  // .Control.proto.TimeStatistics time_statistics = 6;
  bool has_time_statistics() const;
  void clear_time_statistics();
  static const int kTimeStatisticsFieldNumber = 6;
  const ::Control::proto::TimeStatistics& time_statistics() const;
  ::Control::proto::TimeStatistics* release_time_statistics();
  ::Control::proto::TimeStatistics* mutable_time_statistics();
  void set_allocated_time_statistics(::Control::proto::TimeStatistics* time_statistics);

  // double time_stamp = 2;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  double time_stamp() const;
  void set_time_stamp(double value);

  // int32 sequence_num = 1;
  void clear_sequence_num();
  static const int kSequenceNumFieldNumber = 1;
  ::google::protobuf::int32 sequence_num() const;
  void set_sequence_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr module_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::Control::proto::FaultVec* fault_vec_;
  ::Control::proto::TimeStatistics* time_statistics_;
  double time_stamp_;
  ::google::protobuf::int32 sequence_num_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class VehicleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.VehicleInfo) */ {
 public:
  VehicleInfo();
  virtual ~VehicleInfo();

  VehicleInfo(const VehicleInfo& from);

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleInfo(VehicleInfo&& from) noexcept
    : VehicleInfo() {
    *this = ::std::move(from);
  }

  inline VehicleInfo& operator=(VehicleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleInfo*>(
               &_VehicleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(VehicleInfo* other);
  friend void swap(VehicleInfo& a, VehicleInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleInfo& from);
  void MergeFrom(const VehicleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float steerangle = 1;
  void clear_steerangle();
  static const int kSteerangleFieldNumber = 1;
  float steerangle() const;
  void set_steerangle(float value);

  // float speed = 2;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  float speed() const;
  void set_speed(float value);

  // float vehicle_accel = 3;
  void clear_vehicle_accel();
  static const int kVehicleAccelFieldNumber = 3;
  float vehicle_accel() const;
  void set_vehicle_accel(float value);

  // float brake_pressure = 4;
  void clear_brake_pressure();
  static const int kBrakePressureFieldNumber = 4;
  float brake_pressure() const;
  void set_brake_pressure(float value);

  // int32 shift_position = 5;
  void clear_shift_position();
  static const int kShiftPositionFieldNumber = 5;
  ::google::protobuf::int32 shift_position() const;
  void set_shift_position(::google::protobuf::int32 value);

  // int32 epb_status = 6;
  void clear_epb_status();
  static const int kEpbStatusFieldNumber = 6;
  ::google::protobuf::int32 epb_status() const;
  void set_epb_status(::google::protobuf::int32 value);

  // int32 current_drive_mode = 7;
  void clear_current_drive_mode();
  static const int kCurrentDriveModeFieldNumber = 7;
  ::google::protobuf::int32 current_drive_mode() const;
  void set_current_drive_mode(::google::protobuf::int32 value);

  // int32 sys_state = 8;
  void clear_sys_state();
  static const int kSysStateFieldNumber = 8;
  ::google::protobuf::int32 sys_state() const;
  void set_sys_state(::google::protobuf::int32 value);

  // int32 on_accpedal = 9;
  void clear_on_accpedal();
  static const int kOnAccpedalFieldNumber = 9;
  ::google::protobuf::int32 on_accpedal() const;
  void set_on_accpedal(::google::protobuf::int32 value);

  // int32 brake_state = 10;
  void clear_brake_state();
  static const int kBrakeStateFieldNumber = 10;
  ::google::protobuf::int32 brake_state() const;
  void set_brake_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.VehicleInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float steerangle_;
  float speed_;
  float vehicle_accel_;
  float brake_pressure_;
  ::google::protobuf::int32 shift_position_;
  ::google::protobuf::int32 epb_status_;
  ::google::protobuf::int32 current_drive_mode_;
  ::google::protobuf::int32 sys_state_;
  ::google::protobuf::int32 on_accpedal_;
  ::google::protobuf::int32 brake_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsVehicleInfoImpl();
};
// -------------------------------------------------------------------

class ControlFeedback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.ControlFeedback) */ {
 public:
  ControlFeedback();
  virtual ~ControlFeedback();

  ControlFeedback(const ControlFeedback& from);

  inline ControlFeedback& operator=(const ControlFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlFeedback(ControlFeedback&& from) noexcept
    : ControlFeedback() {
    *this = ::std::move(from);
  }

  inline ControlFeedback& operator=(ControlFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlFeedback* internal_default_instance() {
    return reinterpret_cast<const ControlFeedback*>(
               &_ControlFeedback_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ControlFeedback* other);
  friend void swap(ControlFeedback& a, ControlFeedback& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlFeedback* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlFeedback* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlFeedback& from);
  void MergeFrom(const ControlFeedback& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlFeedback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Control.proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Control::proto::Header& header() const;
  ::Control::proto::Header* release_header();
  ::Control::proto::Header* mutable_header();
  void set_allocated_header(::Control::proto::Header* header);

  // .Control.proto.VehicleInfo vehicle_info = 2;
  bool has_vehicle_info() const;
  void clear_vehicle_info();
  static const int kVehicleInfoFieldNumber = 2;
  const ::Control::proto::VehicleInfo& vehicle_info() const;
  ::Control::proto::VehicleInfo* release_vehicle_info();
  ::Control::proto::VehicleInfo* mutable_vehicle_info();
  void set_allocated_vehicle_info(::Control::proto::VehicleInfo* vehicle_info);

  // @@protoc_insertion_point(class_scope:Control.proto.ControlFeedback)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Control::proto::Header* header_;
  ::Control::proto::VehicleInfo* vehicle_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsControlFeedbackImpl();
};
// -------------------------------------------------------------------

class Latcontrol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.Latcontrol) */ {
 public:
  Latcontrol();
  virtual ~Latcontrol();

  Latcontrol(const Latcontrol& from);

  inline Latcontrol& operator=(const Latcontrol& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Latcontrol(Latcontrol&& from) noexcept
    : Latcontrol() {
    *this = ::std::move(from);
  }

  inline Latcontrol& operator=(Latcontrol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Latcontrol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Latcontrol* internal_default_instance() {
    return reinterpret_cast<const Latcontrol*>(
               &_Latcontrol_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Latcontrol* other);
  friend void swap(Latcontrol& a, Latcontrol& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Latcontrol* New() const PROTOBUF_FINAL { return New(NULL); }

  Latcontrol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Latcontrol& from);
  void MergeFrom(const Latcontrol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Latcontrol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float targetangle = 1;
  void clear_targetangle();
  static const int kTargetangleFieldNumber = 1;
  float targetangle() const;
  void set_targetangle(float value);

  // int32 targettorque = 2;
  void clear_targettorque();
  static const int kTargettorqueFieldNumber = 2;
  ::google::protobuf::int32 targettorque() const;
  void set_targettorque(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.Latcontrol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float targetangle_;
  ::google::protobuf::int32 targettorque_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsLatcontrolImpl();
};
// -------------------------------------------------------------------

class Loncontrol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.Loncontrol) */ {
 public:
  Loncontrol();
  virtual ~Loncontrol();

  Loncontrol(const Loncontrol& from);

  inline Loncontrol& operator=(const Loncontrol& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Loncontrol(Loncontrol&& from) noexcept
    : Loncontrol() {
    *this = ::std::move(from);
  }

  inline Loncontrol& operator=(Loncontrol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Loncontrol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Loncontrol* internal_default_instance() {
    return reinterpret_cast<const Loncontrol*>(
               &_Loncontrol_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Loncontrol* other);
  friend void swap(Loncontrol& a, Loncontrol& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Loncontrol* New() const PROTOBUF_FINAL { return New(NULL); }

  Loncontrol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Loncontrol& from);
  void MergeFrom(const Loncontrol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Loncontrol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float targettorque = 1;
  void clear_targettorque();
  static const int kTargettorqueFieldNumber = 1;
  float targettorque() const;
  void set_targettorque(float value);

  // float targetpressure = 2;
  void clear_targetpressure();
  static const int kTargetpressureFieldNumber = 2;
  float targetpressure() const;
  void set_targetpressure(float value);

  // float pitch = 3;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  float pitch() const;
  void set_pitch(float value);

  // float targetspeed = 4;
  void clear_targetspeed();
  static const int kTargetspeedFieldNumber = 4;
  float targetspeed() const;
  void set_targetspeed(float value);

  // float targetaccelation = 5;
  void clear_targetaccelation();
  static const int kTargetaccelationFieldNumber = 5;
  float targetaccelation() const;
  void set_targetaccelation(float value);

  // int32 actuatormode = 6;
  void clear_actuatormode();
  static const int kActuatormodeFieldNumber = 6;
  ::google::protobuf::int32 actuatormode() const;
  void set_actuatormode(::google::protobuf::int32 value);

  // int32 shiftposition = 7;
  void clear_shiftposition();
  static const int kShiftpositionFieldNumber = 7;
  ::google::protobuf::int32 shiftposition() const;
  void set_shiftposition(::google::protobuf::int32 value);

  // bool epbflag = 8;
  void clear_epbflag();
  static const int kEpbflagFieldNumber = 8;
  bool epbflag() const;
  void set_epbflag(bool value);

  // bool brakelight = 9;
  void clear_brakelight();
  static const int kBrakelightFieldNumber = 9;
  bool brakelight() const;
  void set_brakelight(bool value);

  // bool reverselight = 10;
  void clear_reverselight();
  static const int kReverselightFieldNumber = 10;
  bool reverselight() const;
  void set_reverselight(bool value);

  // bool slop_status = 12;
  void clear_slop_status();
  static const int kSlopStatusFieldNumber = 12;
  bool slop_status() const;
  void set_slop_status(bool value);

  // int32 emergency_obstacle = 11;
  void clear_emergency_obstacle();
  static const int kEmergencyObstacleFieldNumber = 11;
  ::google::protobuf::int32 emergency_obstacle() const;
  void set_emergency_obstacle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Control.proto.Loncontrol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float targettorque_;
  float targetpressure_;
  float pitch_;
  float targetspeed_;
  float targetaccelation_;
  ::google::protobuf::int32 actuatormode_;
  ::google::protobuf::int32 shiftposition_;
  bool epbflag_;
  bool brakelight_;
  bool reverselight_;
  bool slop_status_;
  ::google::protobuf::int32 emergency_obstacle_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsLoncontrolImpl();
};
// -------------------------------------------------------------------

class SystemControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Control.proto.SystemControl) */ {
 public:
  SystemControl();
  virtual ~SystemControl();

  SystemControl(const SystemControl& from);

  inline SystemControl& operator=(const SystemControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemControl(SystemControl&& from) noexcept
    : SystemControl() {
    *this = ::std::move(from);
  }

  inline SystemControl& operator=(SystemControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemControl* internal_default_instance() {
    return reinterpret_cast<const SystemControl*>(
               &_SystemControl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SystemControl* other);
  friend void swap(SystemControl& a, SystemControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemControl* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SystemControl& from);
  void MergeFrom(const SystemControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SystemControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Control.proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Control::proto::Header& header() const;
  ::Control::proto::Header* release_header();
  ::Control::proto::Header* mutable_header();
  void set_allocated_header(::Control::proto::Header* header);

  // .Control.proto.Latcontrol latcontrol = 2;
  bool has_latcontrol() const;
  void clear_latcontrol();
  static const int kLatcontrolFieldNumber = 2;
  const ::Control::proto::Latcontrol& latcontrol() const;
  ::Control::proto::Latcontrol* release_latcontrol();
  ::Control::proto::Latcontrol* mutable_latcontrol();
  void set_allocated_latcontrol(::Control::proto::Latcontrol* latcontrol);

  // .Control.proto.Loncontrol loncontrol = 3;
  bool has_loncontrol() const;
  void clear_loncontrol();
  static const int kLoncontrolFieldNumber = 3;
  const ::Control::proto::Loncontrol& loncontrol() const;
  ::Control::proto::Loncontrol* release_loncontrol();
  ::Control::proto::Loncontrol* mutable_loncontrol();
  void set_allocated_loncontrol(::Control::proto::Loncontrol* loncontrol);

  // @@protoc_insertion_point(class_scope:Control.proto.SystemControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Control::proto::Header* header_;
  ::Control::proto::Latcontrol* latcontrol_;
  ::Control::proto::Loncontrol* loncontrol_;
  mutable int _cached_size_;
  friend struct ::protobuf_Control_2eproto::TableStruct;
  friend void ::protobuf_Control_2eproto::InitDefaultsSystemControlImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TimeStatus

// double dtime = 1;
inline void TimeStatus::clear_dtime() {
  dtime_ = 0;
}
inline double TimeStatus::dtime() const {
  // @@protoc_insertion_point(field_get:Control.proto.TimeStatus.dtime)
  return dtime_;
}
inline void TimeStatus::set_dtime(double value) {
  
  dtime_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.TimeStatus.dtime)
}

// string source_node_name = 2;
inline void TimeStatus::clear_source_node_name() {
  source_node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TimeStatus::source_node_name() const {
  // @@protoc_insertion_point(field_get:Control.proto.TimeStatus.source_node_name)
  return source_node_name_.GetNoArena();
}
inline void TimeStatus::set_source_node_name(const ::std::string& value) {
  
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.TimeStatus.source_node_name)
}
#if LANG_CXX11
inline void TimeStatus::set_source_node_name(::std::string&& value) {
  
  source_node_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.TimeStatus.source_node_name)
}
#endif
inline void TimeStatus::set_source_node_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.TimeStatus.source_node_name)
}
inline void TimeStatus::set_source_node_name(const char* value, size_t size) {
  
  source_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.TimeStatus.source_node_name)
}
inline ::std::string* TimeStatus::mutable_source_node_name() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.TimeStatus.source_node_name)
  return source_node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TimeStatus::release_source_node_name() {
  // @@protoc_insertion_point(field_release:Control.proto.TimeStatus.source_node_name)
  
  return source_node_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimeStatus::set_allocated_source_node_name(::std::string* source_node_name) {
  if (source_node_name != NULL) {
    
  } else {
    
  }
  source_node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_node_name);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.TimeStatus.source_node_name)
}

// string destination_node_name = 3;
inline void TimeStatus::clear_destination_node_name() {
  destination_node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TimeStatus::destination_node_name() const {
  // @@protoc_insertion_point(field_get:Control.proto.TimeStatus.destination_node_name)
  return destination_node_name_.GetNoArena();
}
inline void TimeStatus::set_destination_node_name(const ::std::string& value) {
  
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.TimeStatus.destination_node_name)
}
#if LANG_CXX11
inline void TimeStatus::set_destination_node_name(::std::string&& value) {
  
  destination_node_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.TimeStatus.destination_node_name)
}
#endif
inline void TimeStatus::set_destination_node_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.TimeStatus.destination_node_name)
}
inline void TimeStatus::set_destination_node_name(const char* value, size_t size) {
  
  destination_node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.TimeStatus.destination_node_name)
}
inline ::std::string* TimeStatus::mutable_destination_node_name() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.TimeStatus.destination_node_name)
  return destination_node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TimeStatus::release_destination_node_name() {
  // @@protoc_insertion_point(field_release:Control.proto.TimeStatus.destination_node_name)
  
  return destination_node_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TimeStatus::set_allocated_destination_node_name(::std::string* destination_node_name) {
  if (destination_node_name != NULL) {
    
  } else {
    
  }
  destination_node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_node_name);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.TimeStatus.destination_node_name)
}

// -------------------------------------------------------------------

// TimeStatistics

// repeated .Control.proto.TimeStatus dev_time_status_msg = 1;
inline int TimeStatistics::dev_time_status_msg_size() const {
  return dev_time_status_msg_.size();
}
inline void TimeStatistics::clear_dev_time_status_msg() {
  dev_time_status_msg_.Clear();
}
inline const ::Control::proto::TimeStatus& TimeStatistics::dev_time_status_msg(int index) const {
  // @@protoc_insertion_point(field_get:Control.proto.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Get(index);
}
inline ::Control::proto::TimeStatus* TimeStatistics::mutable_dev_time_status_msg(int index) {
  // @@protoc_insertion_point(field_mutable:Control.proto.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Mutable(index);
}
inline ::Control::proto::TimeStatus* TimeStatistics::add_dev_time_status_msg() {
  // @@protoc_insertion_point(field_add:Control.proto.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Control::proto::TimeStatus >*
TimeStatistics::mutable_dev_time_status_msg() {
  // @@protoc_insertion_point(field_mutable_list:Control.proto.TimeStatistics.dev_time_status_msg)
  return &dev_time_status_msg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Control::proto::TimeStatus >&
TimeStatistics::dev_time_status_msg() const {
  // @@protoc_insertion_point(field_list:Control.proto.TimeStatistics.dev_time_status_msg)
  return dev_time_status_msg_;
}

// double sending_timestamp = 2;
inline void TimeStatistics::clear_sending_timestamp() {
  sending_timestamp_ = 0;
}
inline double TimeStatistics::sending_timestamp() const {
  // @@protoc_insertion_point(field_get:Control.proto.TimeStatistics.sending_timestamp)
  return sending_timestamp_;
}
inline void TimeStatistics::set_sending_timestamp(double value) {
  
  sending_timestamp_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.TimeStatistics.sending_timestamp)
}

// -------------------------------------------------------------------

// FaultInfo

// double timestamp_sec = 1;
inline void FaultInfo::clear_timestamp_sec() {
  timestamp_sec_ = 0;
}
inline double FaultInfo::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.timestamp_sec)
  return timestamp_sec_;
}
inline void FaultInfo::set_timestamp_sec(double value) {
  
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.timestamp_sec)
}

// string module_name = 2;
inline void FaultInfo::clear_module_name() {
  module_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultInfo::module_name() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.module_name)
  return module_name_.GetNoArena();
}
inline void FaultInfo::set_module_name(const ::std::string& value) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.module_name)
}
#if LANG_CXX11
inline void FaultInfo::set_module_name(::std::string&& value) {
  
  module_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.FaultInfo.module_name)
}
#endif
inline void FaultInfo::set_module_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.FaultInfo.module_name)
}
inline void FaultInfo::set_module_name(const char* value, size_t size) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.FaultInfo.module_name)
}
inline ::std::string* FaultInfo::mutable_module_name() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.FaultInfo.module_name)
  return module_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultInfo::release_module_name() {
  // @@protoc_insertion_point(field_release:Control.proto.FaultInfo.module_name)
  
  return module_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultInfo::set_allocated_module_name(::std::string* module_name) {
  if (module_name != NULL) {
    
  } else {
    
  }
  module_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_name);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.FaultInfo.module_name)
}

// string version = 3;
inline void FaultInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultInfo::version() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.version)
  return version_.GetNoArena();
}
inline void FaultInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.version)
}
#if LANG_CXX11
inline void FaultInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.FaultInfo.version)
}
#endif
inline void FaultInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.FaultInfo.version)
}
inline void FaultInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.FaultInfo.version)
}
inline ::std::string* FaultInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.FaultInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultInfo::release_version() {
  // @@protoc_insertion_point(field_release:Control.proto.FaultInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.FaultInfo.version)
}

// int32 error_code = 4;
inline void FaultInfo::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 FaultInfo::error_code() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.error_code)
  return error_code_;
}
inline void FaultInfo::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.error_code)
}

// string msg = 5;
inline void FaultInfo::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FaultInfo::msg() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.msg)
  return msg_.GetNoArena();
}
inline void FaultInfo::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.msg)
}
#if LANG_CXX11
inline void FaultInfo::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.FaultInfo.msg)
}
#endif
inline void FaultInfo::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.FaultInfo.msg)
}
inline void FaultInfo::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.FaultInfo.msg)
}
inline ::std::string* FaultInfo::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.FaultInfo.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaultInfo::release_msg() {
  // @@protoc_insertion_point(field_release:Control.proto.FaultInfo.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaultInfo::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.FaultInfo.msg)
}

// int32 fault_level = 6;
inline void FaultInfo::clear_fault_level() {
  fault_level_ = 0;
}
inline ::google::protobuf::int32 FaultInfo::fault_level() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.fault_level)
  return fault_level_;
}
inline void FaultInfo::set_fault_level(::google::protobuf::int32 value) {
  
  fault_level_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.fault_level)
}

// int32 fault_type = 7;
inline void FaultInfo::clear_fault_type() {
  fault_type_ = 0;
}
inline ::google::protobuf::int32 FaultInfo::fault_type() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultInfo.fault_type)
  return fault_type_;
}
inline void FaultInfo::set_fault_type(::google::protobuf::int32 value) {
  
  fault_type_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.FaultInfo.fault_type)
}

// -------------------------------------------------------------------

// FaultVec

// repeated .Control.proto.FaultInfo info_vec = 1;
inline int FaultVec::info_vec_size() const {
  return info_vec_.size();
}
inline void FaultVec::clear_info_vec() {
  info_vec_.Clear();
}
inline const ::Control::proto::FaultInfo& FaultVec::info_vec(int index) const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultVec.info_vec)
  return info_vec_.Get(index);
}
inline ::Control::proto::FaultInfo* FaultVec::mutable_info_vec(int index) {
  // @@protoc_insertion_point(field_mutable:Control.proto.FaultVec.info_vec)
  return info_vec_.Mutable(index);
}
inline ::Control::proto::FaultInfo* FaultVec::add_info_vec() {
  // @@protoc_insertion_point(field_add:Control.proto.FaultVec.info_vec)
  return info_vec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Control::proto::FaultInfo >*
FaultVec::mutable_info_vec() {
  // @@protoc_insertion_point(field_mutable_list:Control.proto.FaultVec.info_vec)
  return &info_vec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Control::proto::FaultInfo >&
FaultVec::info_vec() const {
  // @@protoc_insertion_point(field_list:Control.proto.FaultVec.info_vec)
  return info_vec_;
}

// int32 module_fault_level = 2;
inline void FaultVec::clear_module_fault_level() {
  module_fault_level_ = 0;
}
inline ::google::protobuf::int32 FaultVec::module_fault_level() const {
  // @@protoc_insertion_point(field_get:Control.proto.FaultVec.module_fault_level)
  return module_fault_level_;
}
inline void FaultVec::set_module_fault_level(::google::protobuf::int32 value) {
  
  module_fault_level_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.FaultVec.module_fault_level)
}

// -------------------------------------------------------------------

// Header

// int32 sequence_num = 1;
inline void Header::clear_sequence_num() {
  sequence_num_ = 0;
}
inline ::google::protobuf::int32 Header::sequence_num() const {
  // @@protoc_insertion_point(field_get:Control.proto.Header.sequence_num)
  return sequence_num_;
}
inline void Header::set_sequence_num(::google::protobuf::int32 value) {
  
  sequence_num_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Header.sequence_num)
}

// double time_stamp = 2;
inline void Header::clear_time_stamp() {
  time_stamp_ = 0;
}
inline double Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:Control.proto.Header.time_stamp)
  return time_stamp_;
}
inline void Header::set_time_stamp(double value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Header.time_stamp)
}

// string module_name = 3;
inline void Header::clear_module_name() {
  module_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::module_name() const {
  // @@protoc_insertion_point(field_get:Control.proto.Header.module_name)
  return module_name_.GetNoArena();
}
inline void Header::set_module_name(const ::std::string& value) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.Header.module_name)
}
#if LANG_CXX11
inline void Header::set_module_name(::std::string&& value) {
  
  module_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.Header.module_name)
}
#endif
inline void Header::set_module_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.Header.module_name)
}
inline void Header::set_module_name(const char* value, size_t size) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.Header.module_name)
}
inline ::std::string* Header::mutable_module_name() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.Header.module_name)
  return module_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_module_name() {
  // @@protoc_insertion_point(field_release:Control.proto.Header.module_name)
  
  return module_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_module_name(::std::string* module_name) {
  if (module_name != NULL) {
    
  } else {
    
  }
  module_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_name);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.Header.module_name)
}

// string version = 4;
inline void Header::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:Control.proto.Header.version)
  return version_.GetNoArena();
}
inline void Header::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Control.proto.Header.version)
}
#if LANG_CXX11
inline void Header::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Control.proto.Header.version)
}
#endif
inline void Header::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Control.proto.Header.version)
}
inline void Header::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Control.proto.Header.version)
}
inline ::std::string* Header::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:Control.proto.Header.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_version() {
  // @@protoc_insertion_point(field_release:Control.proto.Header.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:Control.proto.Header.version)
}

// .Control.proto.FaultVec fault_vec = 5;
inline bool Header::has_fault_vec() const {
  return this != internal_default_instance() && fault_vec_ != NULL;
}
inline void Header::clear_fault_vec() {
  if (GetArenaNoVirtual() == NULL && fault_vec_ != NULL) {
    delete fault_vec_;
  }
  fault_vec_ = NULL;
}
inline const ::Control::proto::FaultVec& Header::fault_vec() const {
  const ::Control::proto::FaultVec* p = fault_vec_;
  // @@protoc_insertion_point(field_get:Control.proto.Header.fault_vec)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::FaultVec*>(
      &::Control::proto::_FaultVec_default_instance_);
}
inline ::Control::proto::FaultVec* Header::release_fault_vec() {
  // @@protoc_insertion_point(field_release:Control.proto.Header.fault_vec)
  
  ::Control::proto::FaultVec* temp = fault_vec_;
  fault_vec_ = NULL;
  return temp;
}
inline ::Control::proto::FaultVec* Header::mutable_fault_vec() {
  
  if (fault_vec_ == NULL) {
    fault_vec_ = new ::Control::proto::FaultVec;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.Header.fault_vec)
  return fault_vec_;
}
inline void Header::set_allocated_fault_vec(::Control::proto::FaultVec* fault_vec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fault_vec_;
  }
  if (fault_vec) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fault_vec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fault_vec, submessage_arena);
    }
    
  } else {
    
  }
  fault_vec_ = fault_vec;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.Header.fault_vec)
}

// .Control.proto.TimeStatistics time_statistics = 6;
inline bool Header::has_time_statistics() const {
  return this != internal_default_instance() && time_statistics_ != NULL;
}
inline void Header::clear_time_statistics() {
  if (GetArenaNoVirtual() == NULL && time_statistics_ != NULL) {
    delete time_statistics_;
  }
  time_statistics_ = NULL;
}
inline const ::Control::proto::TimeStatistics& Header::time_statistics() const {
  const ::Control::proto::TimeStatistics* p = time_statistics_;
  // @@protoc_insertion_point(field_get:Control.proto.Header.time_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::TimeStatistics*>(
      &::Control::proto::_TimeStatistics_default_instance_);
}
inline ::Control::proto::TimeStatistics* Header::release_time_statistics() {
  // @@protoc_insertion_point(field_release:Control.proto.Header.time_statistics)
  
  ::Control::proto::TimeStatistics* temp = time_statistics_;
  time_statistics_ = NULL;
  return temp;
}
inline ::Control::proto::TimeStatistics* Header::mutable_time_statistics() {
  
  if (time_statistics_ == NULL) {
    time_statistics_ = new ::Control::proto::TimeStatistics;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.Header.time_statistics)
  return time_statistics_;
}
inline void Header::set_allocated_time_statistics(::Control::proto::TimeStatistics* time_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_statistics_;
  }
  if (time_statistics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_statistics, submessage_arena);
    }
    
  } else {
    
  }
  time_statistics_ = time_statistics;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.Header.time_statistics)
}

// -------------------------------------------------------------------

// VehicleInfo

// float steerangle = 1;
inline void VehicleInfo::clear_steerangle() {
  steerangle_ = 0;
}
inline float VehicleInfo::steerangle() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.steerangle)
  return steerangle_;
}
inline void VehicleInfo::set_steerangle(float value) {
  
  steerangle_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.steerangle)
}

// float speed = 2;
inline void VehicleInfo::clear_speed() {
  speed_ = 0;
}
inline float VehicleInfo::speed() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.speed)
  return speed_;
}
inline void VehicleInfo::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.speed)
}

// float vehicle_accel = 3;
inline void VehicleInfo::clear_vehicle_accel() {
  vehicle_accel_ = 0;
}
inline float VehicleInfo::vehicle_accel() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.vehicle_accel)
  return vehicle_accel_;
}
inline void VehicleInfo::set_vehicle_accel(float value) {
  
  vehicle_accel_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.vehicle_accel)
}

// float brake_pressure = 4;
inline void VehicleInfo::clear_brake_pressure() {
  brake_pressure_ = 0;
}
inline float VehicleInfo::brake_pressure() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.brake_pressure)
  return brake_pressure_;
}
inline void VehicleInfo::set_brake_pressure(float value) {
  
  brake_pressure_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.brake_pressure)
}

// int32 shift_position = 5;
inline void VehicleInfo::clear_shift_position() {
  shift_position_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::shift_position() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.shift_position)
  return shift_position_;
}
inline void VehicleInfo::set_shift_position(::google::protobuf::int32 value) {
  
  shift_position_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.shift_position)
}

// int32 epb_status = 6;
inline void VehicleInfo::clear_epb_status() {
  epb_status_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::epb_status() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.epb_status)
  return epb_status_;
}
inline void VehicleInfo::set_epb_status(::google::protobuf::int32 value) {
  
  epb_status_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.epb_status)
}

// int32 current_drive_mode = 7;
inline void VehicleInfo::clear_current_drive_mode() {
  current_drive_mode_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::current_drive_mode() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.current_drive_mode)
  return current_drive_mode_;
}
inline void VehicleInfo::set_current_drive_mode(::google::protobuf::int32 value) {
  
  current_drive_mode_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.current_drive_mode)
}

// int32 sys_state = 8;
inline void VehicleInfo::clear_sys_state() {
  sys_state_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::sys_state() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.sys_state)
  return sys_state_;
}
inline void VehicleInfo::set_sys_state(::google::protobuf::int32 value) {
  
  sys_state_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.sys_state)
}

// int32 on_accpedal = 9;
inline void VehicleInfo::clear_on_accpedal() {
  on_accpedal_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::on_accpedal() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.on_accpedal)
  return on_accpedal_;
}
inline void VehicleInfo::set_on_accpedal(::google::protobuf::int32 value) {
  
  on_accpedal_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.on_accpedal)
}

// int32 brake_state = 10;
inline void VehicleInfo::clear_brake_state() {
  brake_state_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::brake_state() const {
  // @@protoc_insertion_point(field_get:Control.proto.VehicleInfo.brake_state)
  return brake_state_;
}
inline void VehicleInfo::set_brake_state(::google::protobuf::int32 value) {
  
  brake_state_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.VehicleInfo.brake_state)
}

// -------------------------------------------------------------------

// ControlFeedback

// .Control.proto.Header header = 1;
inline bool ControlFeedback::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ControlFeedback::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::Control::proto::Header& ControlFeedback::header() const {
  const ::Control::proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:Control.proto.ControlFeedback.header)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::Header*>(
      &::Control::proto::_Header_default_instance_);
}
inline ::Control::proto::Header* ControlFeedback::release_header() {
  // @@protoc_insertion_point(field_release:Control.proto.ControlFeedback.header)
  
  ::Control::proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::Control::proto::Header* ControlFeedback::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Control::proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.ControlFeedback.header)
  return header_;
}
inline void ControlFeedback::set_allocated_header(::Control::proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.ControlFeedback.header)
}

// .Control.proto.VehicleInfo vehicle_info = 2;
inline bool ControlFeedback::has_vehicle_info() const {
  return this != internal_default_instance() && vehicle_info_ != NULL;
}
inline void ControlFeedback::clear_vehicle_info() {
  if (GetArenaNoVirtual() == NULL && vehicle_info_ != NULL) {
    delete vehicle_info_;
  }
  vehicle_info_ = NULL;
}
inline const ::Control::proto::VehicleInfo& ControlFeedback::vehicle_info() const {
  const ::Control::proto::VehicleInfo* p = vehicle_info_;
  // @@protoc_insertion_point(field_get:Control.proto.ControlFeedback.vehicle_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::VehicleInfo*>(
      &::Control::proto::_VehicleInfo_default_instance_);
}
inline ::Control::proto::VehicleInfo* ControlFeedback::release_vehicle_info() {
  // @@protoc_insertion_point(field_release:Control.proto.ControlFeedback.vehicle_info)
  
  ::Control::proto::VehicleInfo* temp = vehicle_info_;
  vehicle_info_ = NULL;
  return temp;
}
inline ::Control::proto::VehicleInfo* ControlFeedback::mutable_vehicle_info() {
  
  if (vehicle_info_ == NULL) {
    vehicle_info_ = new ::Control::proto::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.ControlFeedback.vehicle_info)
  return vehicle_info_;
}
inline void ControlFeedback::set_allocated_vehicle_info(::Control::proto::VehicleInfo* vehicle_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_info_;
  }
  if (vehicle_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_info, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_info_ = vehicle_info;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.ControlFeedback.vehicle_info)
}

// -------------------------------------------------------------------

// Latcontrol

// float targetangle = 1;
inline void Latcontrol::clear_targetangle() {
  targetangle_ = 0;
}
inline float Latcontrol::targetangle() const {
  // @@protoc_insertion_point(field_get:Control.proto.Latcontrol.targetangle)
  return targetangle_;
}
inline void Latcontrol::set_targetangle(float value) {
  
  targetangle_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Latcontrol.targetangle)
}

// int32 targettorque = 2;
inline void Latcontrol::clear_targettorque() {
  targettorque_ = 0;
}
inline ::google::protobuf::int32 Latcontrol::targettorque() const {
  // @@protoc_insertion_point(field_get:Control.proto.Latcontrol.targettorque)
  return targettorque_;
}
inline void Latcontrol::set_targettorque(::google::protobuf::int32 value) {
  
  targettorque_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Latcontrol.targettorque)
}

// -------------------------------------------------------------------

// Loncontrol

// float targettorque = 1;
inline void Loncontrol::clear_targettorque() {
  targettorque_ = 0;
}
inline float Loncontrol::targettorque() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.targettorque)
  return targettorque_;
}
inline void Loncontrol::set_targettorque(float value) {
  
  targettorque_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.targettorque)
}

// float targetpressure = 2;
inline void Loncontrol::clear_targetpressure() {
  targetpressure_ = 0;
}
inline float Loncontrol::targetpressure() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.targetpressure)
  return targetpressure_;
}
inline void Loncontrol::set_targetpressure(float value) {
  
  targetpressure_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.targetpressure)
}

// float pitch = 3;
inline void Loncontrol::clear_pitch() {
  pitch_ = 0;
}
inline float Loncontrol::pitch() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.pitch)
  return pitch_;
}
inline void Loncontrol::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.pitch)
}

// float targetspeed = 4;
inline void Loncontrol::clear_targetspeed() {
  targetspeed_ = 0;
}
inline float Loncontrol::targetspeed() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.targetspeed)
  return targetspeed_;
}
inline void Loncontrol::set_targetspeed(float value) {
  
  targetspeed_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.targetspeed)
}

// float targetaccelation = 5;
inline void Loncontrol::clear_targetaccelation() {
  targetaccelation_ = 0;
}
inline float Loncontrol::targetaccelation() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.targetaccelation)
  return targetaccelation_;
}
inline void Loncontrol::set_targetaccelation(float value) {
  
  targetaccelation_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.targetaccelation)
}

// int32 actuatormode = 6;
inline void Loncontrol::clear_actuatormode() {
  actuatormode_ = 0;
}
inline ::google::protobuf::int32 Loncontrol::actuatormode() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.actuatormode)
  return actuatormode_;
}
inline void Loncontrol::set_actuatormode(::google::protobuf::int32 value) {
  
  actuatormode_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.actuatormode)
}

// int32 shiftposition = 7;
inline void Loncontrol::clear_shiftposition() {
  shiftposition_ = 0;
}
inline ::google::protobuf::int32 Loncontrol::shiftposition() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.shiftposition)
  return shiftposition_;
}
inline void Loncontrol::set_shiftposition(::google::protobuf::int32 value) {
  
  shiftposition_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.shiftposition)
}

// bool epbflag = 8;
inline void Loncontrol::clear_epbflag() {
  epbflag_ = false;
}
inline bool Loncontrol::epbflag() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.epbflag)
  return epbflag_;
}
inline void Loncontrol::set_epbflag(bool value) {
  
  epbflag_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.epbflag)
}

// bool brakelight = 9;
inline void Loncontrol::clear_brakelight() {
  brakelight_ = false;
}
inline bool Loncontrol::brakelight() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.brakelight)
  return brakelight_;
}
inline void Loncontrol::set_brakelight(bool value) {
  
  brakelight_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.brakelight)
}

// bool reverselight = 10;
inline void Loncontrol::clear_reverselight() {
  reverselight_ = false;
}
inline bool Loncontrol::reverselight() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.reverselight)
  return reverselight_;
}
inline void Loncontrol::set_reverselight(bool value) {
  
  reverselight_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.reverselight)
}

// int32 emergency_obstacle = 11;
inline void Loncontrol::clear_emergency_obstacle() {
  emergency_obstacle_ = 0;
}
inline ::google::protobuf::int32 Loncontrol::emergency_obstacle() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.emergency_obstacle)
  return emergency_obstacle_;
}
inline void Loncontrol::set_emergency_obstacle(::google::protobuf::int32 value) {
  
  emergency_obstacle_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.emergency_obstacle)
}

// bool slop_status = 12;
inline void Loncontrol::clear_slop_status() {
  slop_status_ = false;
}
inline bool Loncontrol::slop_status() const {
  // @@protoc_insertion_point(field_get:Control.proto.Loncontrol.slop_status)
  return slop_status_;
}
inline void Loncontrol::set_slop_status(bool value) {
  
  slop_status_ = value;
  // @@protoc_insertion_point(field_set:Control.proto.Loncontrol.slop_status)
}

// -------------------------------------------------------------------

// SystemControl

// .Control.proto.Header header = 1;
inline bool SystemControl::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void SystemControl::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::Control::proto::Header& SystemControl::header() const {
  const ::Control::proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:Control.proto.SystemControl.header)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::Header*>(
      &::Control::proto::_Header_default_instance_);
}
inline ::Control::proto::Header* SystemControl::release_header() {
  // @@protoc_insertion_point(field_release:Control.proto.SystemControl.header)
  
  ::Control::proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::Control::proto::Header* SystemControl::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Control::proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.SystemControl.header)
  return header_;
}
inline void SystemControl::set_allocated_header(::Control::proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.SystemControl.header)
}

// .Control.proto.Latcontrol latcontrol = 2;
inline bool SystemControl::has_latcontrol() const {
  return this != internal_default_instance() && latcontrol_ != NULL;
}
inline void SystemControl::clear_latcontrol() {
  if (GetArenaNoVirtual() == NULL && latcontrol_ != NULL) {
    delete latcontrol_;
  }
  latcontrol_ = NULL;
}
inline const ::Control::proto::Latcontrol& SystemControl::latcontrol() const {
  const ::Control::proto::Latcontrol* p = latcontrol_;
  // @@protoc_insertion_point(field_get:Control.proto.SystemControl.latcontrol)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::Latcontrol*>(
      &::Control::proto::_Latcontrol_default_instance_);
}
inline ::Control::proto::Latcontrol* SystemControl::release_latcontrol() {
  // @@protoc_insertion_point(field_release:Control.proto.SystemControl.latcontrol)
  
  ::Control::proto::Latcontrol* temp = latcontrol_;
  latcontrol_ = NULL;
  return temp;
}
inline ::Control::proto::Latcontrol* SystemControl::mutable_latcontrol() {
  
  if (latcontrol_ == NULL) {
    latcontrol_ = new ::Control::proto::Latcontrol;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.SystemControl.latcontrol)
  return latcontrol_;
}
inline void SystemControl::set_allocated_latcontrol(::Control::proto::Latcontrol* latcontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete latcontrol_;
  }
  if (latcontrol) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      latcontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latcontrol, submessage_arena);
    }
    
  } else {
    
  }
  latcontrol_ = latcontrol;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.SystemControl.latcontrol)
}

// .Control.proto.Loncontrol loncontrol = 3;
inline bool SystemControl::has_loncontrol() const {
  return this != internal_default_instance() && loncontrol_ != NULL;
}
inline void SystemControl::clear_loncontrol() {
  if (GetArenaNoVirtual() == NULL && loncontrol_ != NULL) {
    delete loncontrol_;
  }
  loncontrol_ = NULL;
}
inline const ::Control::proto::Loncontrol& SystemControl::loncontrol() const {
  const ::Control::proto::Loncontrol* p = loncontrol_;
  // @@protoc_insertion_point(field_get:Control.proto.SystemControl.loncontrol)
  return p != NULL ? *p : *reinterpret_cast<const ::Control::proto::Loncontrol*>(
      &::Control::proto::_Loncontrol_default_instance_);
}
inline ::Control::proto::Loncontrol* SystemControl::release_loncontrol() {
  // @@protoc_insertion_point(field_release:Control.proto.SystemControl.loncontrol)
  
  ::Control::proto::Loncontrol* temp = loncontrol_;
  loncontrol_ = NULL;
  return temp;
}
inline ::Control::proto::Loncontrol* SystemControl::mutable_loncontrol() {
  
  if (loncontrol_ == NULL) {
    loncontrol_ = new ::Control::proto::Loncontrol;
  }
  // @@protoc_insertion_point(field_mutable:Control.proto.SystemControl.loncontrol)
  return loncontrol_;
}
inline void SystemControl::set_allocated_loncontrol(::Control::proto::Loncontrol* loncontrol) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete loncontrol_;
  }
  if (loncontrol) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      loncontrol = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, loncontrol, submessage_arena);
    }
    
  } else {
    
  }
  loncontrol_ = loncontrol;
  // @@protoc_insertion_point(field_set_allocated:Control.proto.SystemControl.loncontrol)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace Control

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Control_2eproto__INCLUDED
