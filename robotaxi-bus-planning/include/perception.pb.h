// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception.proto

#ifndef PROTOBUF_perception_2eproto__INCLUDED
#define PROTOBUF_perception_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "perception_types.pb.h"
#include "perception_sensor_info.pb.h"
#include "perception_vehicle.pb.h"
#include "perception_road.pb.h"
#include "perception_barricade.pb.h"
#include "perception_diagnose.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsMeasuringStatusImpl();
void InitDefaultsMeasuringStatus();
void InitDefaultsObjectImpl();
void InitDefaultsObject();
void InitDefaultsTrafficLightSpotImpl();
void InitDefaultsTrafficLightSpot();
void InitDefaultsTrafficLightImpl();
void InitDefaultsTrafficLight();
void InitDefaultsTrafficSignImpl();
void InitDefaultsTrafficSign();
void InitDefaultsTrafficSignTypeImpl();
void InitDefaultsTrafficSignType();
void InitDefaultsTrafficSignStatusImpl();
void InitDefaultsTrafficSignStatus();
void InitDefaultsAebObjectImpl();
void InitDefaultsAebObject();
void InitDefaultsVehiclePredictPointImpl();
void InitDefaultsVehiclePredictPoint();
void InitDefaultsVehicle_StateImpl();
void InitDefaultsVehicle_State();
void InitDefaultsSignal_InputImpl();
void InitDefaultsSignal_Input();
void InitDefaultsSignal_OutputImpl();
void InitDefaultsSignal_Output();
void InitDefaultsFault_SignalImpl();
void InitDefaultsFault_Signal();
void InitDefaultsVehicle_SignalImpl();
void InitDefaultsVehicle_Signal();
void InitDefaultsAebOutputImpl();
void InitDefaultsAebOutput();
void InitDefaultsAebInputImpl();
void InitDefaultsAebInput();
void InitDefaultsAebInfoImpl();
void InitDefaultsAebInfo();
void InitDefaultsFailsafeImpl();
void InitDefaultsFailsafe();
void InitDefaultsPerceptionFrameImpl();
void InitDefaultsPerceptionFrame();
inline void InitDefaults() {
  InitDefaultsHeader();
  InitDefaultsMeasuringStatus();
  InitDefaultsObject();
  InitDefaultsTrafficLightSpot();
  InitDefaultsTrafficLight();
  InitDefaultsTrafficSign();
  InitDefaultsTrafficSignType();
  InitDefaultsTrafficSignStatus();
  InitDefaultsAebObject();
  InitDefaultsVehiclePredictPoint();
  InitDefaultsVehicle_State();
  InitDefaultsSignal_Input();
  InitDefaultsSignal_Output();
  InitDefaultsFault_Signal();
  InitDefaultsVehicle_Signal();
  InitDefaultsAebOutput();
  InitDefaultsAebInput();
  InitDefaultsAebInfo();
  InitDefaultsFailsafe();
  InitDefaultsPerceptionFrame();
}
}  // namespace protobuf_perception_2eproto
namespace calmcar {
namespace perception {
class AebInfo;
class AebInfoDefaultTypeInternal;
extern AebInfoDefaultTypeInternal _AebInfo_default_instance_;
class AebInput;
class AebInputDefaultTypeInternal;
extern AebInputDefaultTypeInternal _AebInput_default_instance_;
class AebObject;
class AebObjectDefaultTypeInternal;
extern AebObjectDefaultTypeInternal _AebObject_default_instance_;
class AebOutput;
class AebOutputDefaultTypeInternal;
extern AebOutputDefaultTypeInternal _AebOutput_default_instance_;
class Failsafe;
class FailsafeDefaultTypeInternal;
extern FailsafeDefaultTypeInternal _Failsafe_default_instance_;
class Fault_Signal;
class Fault_SignalDefaultTypeInternal;
extern Fault_SignalDefaultTypeInternal _Fault_Signal_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class MeasuringStatus;
class MeasuringStatusDefaultTypeInternal;
extern MeasuringStatusDefaultTypeInternal _MeasuringStatus_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class PerceptionFrame;
class PerceptionFrameDefaultTypeInternal;
extern PerceptionFrameDefaultTypeInternal _PerceptionFrame_default_instance_;
class Signal_Input;
class Signal_InputDefaultTypeInternal;
extern Signal_InputDefaultTypeInternal _Signal_Input_default_instance_;
class Signal_Output;
class Signal_OutputDefaultTypeInternal;
extern Signal_OutputDefaultTypeInternal _Signal_Output_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficLightSpot;
class TrafficLightSpotDefaultTypeInternal;
extern TrafficLightSpotDefaultTypeInternal _TrafficLightSpot_default_instance_;
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSignStatus;
class TrafficSignStatusDefaultTypeInternal;
extern TrafficSignStatusDefaultTypeInternal _TrafficSignStatus_default_instance_;
class TrafficSignType;
class TrafficSignTypeDefaultTypeInternal;
extern TrafficSignTypeDefaultTypeInternal _TrafficSignType_default_instance_;
class VehiclePredictPoint;
class VehiclePredictPointDefaultTypeInternal;
extern VehiclePredictPointDefaultTypeInternal _VehiclePredictPoint_default_instance_;
class Vehicle_Signal;
class Vehicle_SignalDefaultTypeInternal;
extern Vehicle_SignalDefaultTypeInternal _Vehicle_Signal_default_instance_;
class Vehicle_State;
class Vehicle_StateDefaultTypeInternal;
extern Vehicle_StateDefaultTypeInternal _Vehicle_State_default_instance_;
}  // namespace perception
}  // namespace calmcar
namespace calmcar {
namespace perception {

enum Header_ProtobufVersion {
  Header_ProtobufVersion_V_1_0_0 = 0,
  Header_ProtobufVersion_V_1_0_1 = 1,
  Header_ProtobufVersion_V_1_0_2 = 2,
  Header_ProtobufVersion_V_1_0_3 = 3,
  Header_ProtobufVersion_V_1_0_4 = 4,
  Header_ProtobufVersion_V_1_0_5 = 5,
  Header_ProtobufVersion_V_1_0_6 = 6,
  Header_ProtobufVersion_V_1_0_7 = 7,
  Header_ProtobufVersion_V_1_0_8 = 8,
  Header_ProtobufVersion_V_1_0_9 = 9,
  Header_ProtobufVersion_V_1_0_10 = 10,
  Header_ProtobufVersion_V_1_0_11 = 11,
  Header_ProtobufVersion_V_1_0_12 = 12,
  Header_ProtobufVersion_V_1_0_13 = 13,
  Header_ProtobufVersion_V_1_0_14 = 14,
  Header_ProtobufVersion_V_1_0_15 = 15,
  Header_ProtobufVersion_V_1_0_16 = 16,
  Header_ProtobufVersion_V_1_0_17 = 17,
  Header_ProtobufVersion_CURRENT_VERSION = 17,
  Header_ProtobufVersion_Header_ProtobufVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_ProtobufVersion_Header_ProtobufVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_ProtobufVersion_IsValid(int value);
const Header_ProtobufVersion Header_ProtobufVersion_ProtobufVersion_MIN = Header_ProtobufVersion_V_1_0_0;
const Header_ProtobufVersion Header_ProtobufVersion_ProtobufVersion_MAX = Header_ProtobufVersion_V_1_0_17;
const int Header_ProtobufVersion_ProtobufVersion_ARRAYSIZE = Header_ProtobufVersion_ProtobufVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_ProtobufVersion_descriptor();
inline const ::std::string& Header_ProtobufVersion_Name(Header_ProtobufVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_ProtobufVersion_descriptor(), value);
}
inline bool Header_ProtobufVersion_Parse(
    const ::std::string& name, Header_ProtobufVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ProtobufVersion>(
    Header_ProtobufVersion_descriptor(), name, value);
}
enum Header_ObjectVersion {
  Header_ObjectVersion_OD_V_1_0 = 0,
  Header_ObjectVersion_OD_V_1_1 = 1,
  Header_ObjectVersion_OD_CURRENT_VERSION = 1,
  Header_ObjectVersion_Header_ObjectVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_ObjectVersion_Header_ObjectVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_ObjectVersion_IsValid(int value);
const Header_ObjectVersion Header_ObjectVersion_ObjectVersion_MIN = Header_ObjectVersion_OD_V_1_0;
const Header_ObjectVersion Header_ObjectVersion_ObjectVersion_MAX = Header_ObjectVersion_OD_V_1_1;
const int Header_ObjectVersion_ObjectVersion_ARRAYSIZE = Header_ObjectVersion_ObjectVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_ObjectVersion_descriptor();
inline const ::std::string& Header_ObjectVersion_Name(Header_ObjectVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_ObjectVersion_descriptor(), value);
}
inline bool Header_ObjectVersion_Parse(
    const ::std::string& name, Header_ObjectVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ObjectVersion>(
    Header_ObjectVersion_descriptor(), name, value);
}
enum Header_TrafficLightStructVersion {
  Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0 = 0,
  Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1 = 1,
  Header_TrafficLightStructVersion_TFL_STRUCT_CURRENT_VERSION = 1,
  Header_TrafficLightStructVersion_Header_TrafficLightStructVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficLightStructVersion_Header_TrafficLightStructVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficLightStructVersion_IsValid(int value);
const Header_TrafficLightStructVersion Header_TrafficLightStructVersion_TrafficLightStructVersion_MIN = Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0;
const Header_TrafficLightStructVersion Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX = Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1;
const int Header_TrafficLightStructVersion_TrafficLightStructVersion_ARRAYSIZE = Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficLightStructVersion_descriptor();
inline const ::std::string& Header_TrafficLightStructVersion_Name(Header_TrafficLightStructVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficLightStructVersion_descriptor(), value);
}
inline bool Header_TrafficLightStructVersion_Parse(
    const ::std::string& name, Header_TrafficLightStructVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficLightStructVersion>(
    Header_TrafficLightStructVersion_descriptor(), name, value);
}
enum Header_TrafficLightSpotVersion {
  Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0 = 0,
  Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1 = 1,
  Header_TrafficLightSpotVersion_TFL_SPOT_CURRENT_VERSION = 1,
  Header_TrafficLightSpotVersion_Header_TrafficLightSpotVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficLightSpotVersion_Header_TrafficLightSpotVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficLightSpotVersion_IsValid(int value);
const Header_TrafficLightSpotVersion Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MIN = Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0;
const Header_TrafficLightSpotVersion Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX = Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1;
const int Header_TrafficLightSpotVersion_TrafficLightSpotVersion_ARRAYSIZE = Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficLightSpotVersion_descriptor();
inline const ::std::string& Header_TrafficLightSpotVersion_Name(Header_TrafficLightSpotVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficLightSpotVersion_descriptor(), value);
}
inline bool Header_TrafficLightSpotVersion_Parse(
    const ::std::string& name, Header_TrafficLightSpotVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficLightSpotVersion>(
    Header_TrafficLightSpotVersion_descriptor(), name, value);
}
enum Header_TrafficSignVersion {
  Header_TrafficSignVersion_TSR_V_1_0 = 0,
  Header_TrafficSignVersion_TSR_V_1_1 = 1,
  Header_TrafficSignVersion_TSR_CURRENT_VERSION = 1,
  Header_TrafficSignVersion_Header_TrafficSignVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficSignVersion_Header_TrafficSignVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficSignVersion_IsValid(int value);
const Header_TrafficSignVersion Header_TrafficSignVersion_TrafficSignVersion_MIN = Header_TrafficSignVersion_TSR_V_1_0;
const Header_TrafficSignVersion Header_TrafficSignVersion_TrafficSignVersion_MAX = Header_TrafficSignVersion_TSR_V_1_1;
const int Header_TrafficSignVersion_TrafficSignVersion_ARRAYSIZE = Header_TrafficSignVersion_TrafficSignVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficSignVersion_descriptor();
inline const ::std::string& Header_TrafficSignVersion_Name(Header_TrafficSignVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficSignVersion_descriptor(), value);
}
inline bool Header_TrafficSignVersion_Parse(
    const ::std::string& name, Header_TrafficSignVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficSignVersion>(
    Header_TrafficSignVersion_descriptor(), name, value);
}
enum Header_FailSafeVersion {
  Header_FailSafeVersion_FS_V_1_0 = 0,
  Header_FailSafeVersion_FS_V_1_1 = 1,
  Header_FailSafeVersion_FS_CURRENT_VERSION = 1,
  Header_FailSafeVersion_Header_FailSafeVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_FailSafeVersion_Header_FailSafeVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_FailSafeVersion_IsValid(int value);
const Header_FailSafeVersion Header_FailSafeVersion_FailSafeVersion_MIN = Header_FailSafeVersion_FS_V_1_0;
const Header_FailSafeVersion Header_FailSafeVersion_FailSafeVersion_MAX = Header_FailSafeVersion_FS_V_1_1;
const int Header_FailSafeVersion_FailSafeVersion_ARRAYSIZE = Header_FailSafeVersion_FailSafeVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_FailSafeVersion_descriptor();
inline const ::std::string& Header_FailSafeVersion_Name(Header_FailSafeVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_FailSafeVersion_descriptor(), value);
}
inline bool Header_FailSafeVersion_Parse(
    const ::std::string& name, Header_FailSafeVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_FailSafeVersion>(
    Header_FailSafeVersion_descriptor(), name, value);
}
enum Header_LaneVersion {
  Header_LaneVersion_LANE_V_1_0 = 0,
  Header_LaneVersion_LANE_V_1_1 = 1,
  Header_LaneVersion_LANE_CURRENT_VERSION = 1,
  Header_LaneVersion_Header_LaneVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_LaneVersion_Header_LaneVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_LaneVersion_IsValid(int value);
const Header_LaneVersion Header_LaneVersion_LaneVersion_MIN = Header_LaneVersion_LANE_V_1_0;
const Header_LaneVersion Header_LaneVersion_LaneVersion_MAX = Header_LaneVersion_LANE_V_1_1;
const int Header_LaneVersion_LaneVersion_ARRAYSIZE = Header_LaneVersion_LaneVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_LaneVersion_descriptor();
inline const ::std::string& Header_LaneVersion_Name(Header_LaneVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_LaneVersion_descriptor(), value);
}
inline bool Header_LaneVersion_Parse(
    const ::std::string& name, Header_LaneVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_LaneVersion>(
    Header_LaneVersion_descriptor(), name, value);
}
enum Header_RoadMarkVersion {
  Header_RoadMarkVersion_RM_V_1_0 = 0,
  Header_RoadMarkVersion_RM_V_1_1 = 1,
  Header_RoadMarkVersion_RM_CURRENT_VERSION = 1,
  Header_RoadMarkVersion_Header_RoadMarkVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_RoadMarkVersion_Header_RoadMarkVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_RoadMarkVersion_IsValid(int value);
const Header_RoadMarkVersion Header_RoadMarkVersion_RoadMarkVersion_MIN = Header_RoadMarkVersion_RM_V_1_0;
const Header_RoadMarkVersion Header_RoadMarkVersion_RoadMarkVersion_MAX = Header_RoadMarkVersion_RM_V_1_1;
const int Header_RoadMarkVersion_RoadMarkVersion_ARRAYSIZE = Header_RoadMarkVersion_RoadMarkVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_RoadMarkVersion_descriptor();
inline const ::std::string& Header_RoadMarkVersion_Name(Header_RoadMarkVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_RoadMarkVersion_descriptor(), value);
}
inline bool Header_RoadMarkVersion_Parse(
    const ::std::string& name, Header_RoadMarkVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_RoadMarkVersion>(
    Header_RoadMarkVersion_descriptor(), name, value);
}
enum Header_FreeSpaceVersion {
  Header_FreeSpaceVersion_FSP_V_1_0 = 0,
  Header_FreeSpaceVersion_FSP_V_1_1 = 1,
  Header_FreeSpaceVersion_FSP_CURRENT_VERSION = 1,
  Header_FreeSpaceVersion_Header_FreeSpaceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_FreeSpaceVersion_Header_FreeSpaceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_FreeSpaceVersion_IsValid(int value);
const Header_FreeSpaceVersion Header_FreeSpaceVersion_FreeSpaceVersion_MIN = Header_FreeSpaceVersion_FSP_V_1_0;
const Header_FreeSpaceVersion Header_FreeSpaceVersion_FreeSpaceVersion_MAX = Header_FreeSpaceVersion_FSP_V_1_1;
const int Header_FreeSpaceVersion_FreeSpaceVersion_ARRAYSIZE = Header_FreeSpaceVersion_FreeSpaceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_FreeSpaceVersion_descriptor();
inline const ::std::string& Header_FreeSpaceVersion_Name(Header_FreeSpaceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_FreeSpaceVersion_descriptor(), value);
}
inline bool Header_FreeSpaceVersion_Parse(
    const ::std::string& name, Header_FreeSpaceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_FreeSpaceVersion>(
    Header_FreeSpaceVersion_descriptor(), name, value);
}
enum Header_BarricadeVersion {
  Header_BarricadeVersion_BA_V_1_0 = 0,
  Header_BarricadeVersion_BA_CURRENT_VERSION = 0,
  Header_BarricadeVersion_Header_BarricadeVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_BarricadeVersion_Header_BarricadeVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_BarricadeVersion_IsValid(int value);
const Header_BarricadeVersion Header_BarricadeVersion_BarricadeVersion_MIN = Header_BarricadeVersion_BA_V_1_0;
const Header_BarricadeVersion Header_BarricadeVersion_BarricadeVersion_MAX = Header_BarricadeVersion_BA_V_1_0;
const int Header_BarricadeVersion_BarricadeVersion_ARRAYSIZE = Header_BarricadeVersion_BarricadeVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_BarricadeVersion_descriptor();
inline const ::std::string& Header_BarricadeVersion_Name(Header_BarricadeVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_BarricadeVersion_descriptor(), value);
}
inline bool Header_BarricadeVersion_Parse(
    const ::std::string& name, Header_BarricadeVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_BarricadeVersion>(
    Header_BarricadeVersion_descriptor(), name, value);
}
enum TrafficLightSpot_Color {
  TrafficLightSpot_Color_COLOR_UNKNOWN = 0,
  TrafficLightSpot_Color_COLOR_GREEN = 1,
  TrafficLightSpot_Color_COLOR_RED = 2,
  TrafficLightSpot_Color_COLOR_YELLOW = 3,
  TrafficLightSpot_Color_TrafficLightSpot_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLightSpot_Color_TrafficLightSpot_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLightSpot_Color_IsValid(int value);
const TrafficLightSpot_Color TrafficLightSpot_Color_Color_MIN = TrafficLightSpot_Color_COLOR_UNKNOWN;
const TrafficLightSpot_Color TrafficLightSpot_Color_Color_MAX = TrafficLightSpot_Color_COLOR_YELLOW;
const int TrafficLightSpot_Color_Color_ARRAYSIZE = TrafficLightSpot_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightSpot_Color_descriptor();
inline const ::std::string& TrafficLightSpot_Color_Name(TrafficLightSpot_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightSpot_Color_descriptor(), value);
}
inline bool TrafficLightSpot_Color_Parse(
    const ::std::string& name, TrafficLightSpot_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightSpot_Color>(
    TrafficLightSpot_Color_descriptor(), name, value);
}
enum TrafficLightSpot_Type {
  TrafficLightSpot_Type_TYPE_UNKNOWN = 0,
  TrafficLightSpot_Type_TYPE_ARROW_STRAIGHT = 1,
  TrafficLightSpot_Type_TYPE_ARROW_LEFT = 2,
  TrafficLightSpot_Type_TYPE_ARROW_RIGHT = 3,
  TrafficLightSpot_Type_TYPE_ARROW_UTURN = 4,
  TrafficLightSpot_Type_TYPE_CIRCLE = 5,
  TrafficLightSpot_Type_TYPE_NUM = 6,
  TrafficLightSpot_Type_TrafficLightSpot_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLightSpot_Type_TrafficLightSpot_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLightSpot_Type_IsValid(int value);
const TrafficLightSpot_Type TrafficLightSpot_Type_Type_MIN = TrafficLightSpot_Type_TYPE_UNKNOWN;
const TrafficLightSpot_Type TrafficLightSpot_Type_Type_MAX = TrafficLightSpot_Type_TYPE_NUM;
const int TrafficLightSpot_Type_Type_ARRAYSIZE = TrafficLightSpot_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightSpot_Type_descriptor();
inline const ::std::string& TrafficLightSpot_Type_Name(TrafficLightSpot_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightSpot_Type_descriptor(), value);
}
inline bool TrafficLightSpot_Type_Parse(
    const ::std::string& name, TrafficLightSpot_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightSpot_Type>(
    TrafficLightSpot_Type_descriptor(), name, value);
}
enum TrafficLight_Color {
  TrafficLight_Color_COLOR_UNKNOWN = 0,
  TrafficLight_Color_COLOR_GREEN = 1,
  TrafficLight_Color_COLOR_RED = 2,
  TrafficLight_Color_COLOR_YELLOW = 3,
  TrafficLight_Color_TrafficLight_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Color_TrafficLight_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Color_IsValid(int value);
const TrafficLight_Color TrafficLight_Color_Color_MIN = TrafficLight_Color_COLOR_UNKNOWN;
const TrafficLight_Color TrafficLight_Color_Color_MAX = TrafficLight_Color_COLOR_YELLOW;
const int TrafficLight_Color_Color_ARRAYSIZE = TrafficLight_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Color_descriptor();
inline const ::std::string& TrafficLight_Color_Name(TrafficLight_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Color_descriptor(), value);
}
inline bool TrafficLight_Color_Parse(
    const ::std::string& name, TrafficLight_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Color>(
    TrafficLight_Color_descriptor(), name, value);
}
enum TrafficLight_Type {
  TrafficLight_Type_TYPE_UNKNOWN = 0,
  TrafficLight_Type_TYPE_ARROW_STRAIGHT = 1,
  TrafficLight_Type_TYPE_ARROW_LEFT = 2,
  TrafficLight_Type_TYPE_ARROW_RIGHT = 3,
  TrafficLight_Type_TYPE_ARROW_UTURN = 4,
  TrafficLight_Type_TYPE_CIRCLE = 5,
  TrafficLight_Type_TYPE_NUM = 6,
  TrafficLight_Type_TrafficLight_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Type_TrafficLight_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Type_IsValid(int value);
const TrafficLight_Type TrafficLight_Type_Type_MIN = TrafficLight_Type_TYPE_UNKNOWN;
const TrafficLight_Type TrafficLight_Type_Type_MAX = TrafficLight_Type_TYPE_NUM;
const int TrafficLight_Type_Type_ARRAYSIZE = TrafficLight_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Type_descriptor();
inline const ::std::string& TrafficLight_Type_Name(TrafficLight_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Type_descriptor(), value);
}
inline bool TrafficLight_Type_Parse(
    const ::std::string& name, TrafficLight_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Type>(
    TrafficLight_Type_descriptor(), name, value);
}
enum TrafficLight_Mode {
  TrafficLight_Mode_NO_BRIGHT = 0,
  TrafficLight_Mode_ALWAYS_BRIGHT = 1,
  TrafficLight_Mode_FLASH = 2,
  TrafficLight_Mode_TrafficLight_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Mode_TrafficLight_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Mode_IsValid(int value);
const TrafficLight_Mode TrafficLight_Mode_Mode_MIN = TrafficLight_Mode_NO_BRIGHT;
const TrafficLight_Mode TrafficLight_Mode_Mode_MAX = TrafficLight_Mode_FLASH;
const int TrafficLight_Mode_Mode_ARRAYSIZE = TrafficLight_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Mode_descriptor();
inline const ::std::string& TrafficLight_Mode_Name(TrafficLight_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Mode_descriptor(), value);
}
inline bool TrafficLight_Mode_Parse(
    const ::std::string& name, TrafficLight_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Mode>(
    TrafficLight_Mode_descriptor(), name, value);
}
enum TrafficSign_TrafficSIgnRelevancy {
  TrafficSign_TrafficSIgnRelevancy_Unknow = 0,
  TrafficSign_TrafficSIgnRelevancy_RELEVANT = 1,
  TrafficSign_TrafficSIgnRelevancy_UNRELEVANT = 2,
  TrafficSign_TrafficSIgnRelevancy_TrafficSign_TrafficSIgnRelevancy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_TrafficSIgnRelevancy_TrafficSign_TrafficSIgnRelevancy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_TrafficSIgnRelevancy_IsValid(int value);
const TrafficSign_TrafficSIgnRelevancy TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MIN = TrafficSign_TrafficSIgnRelevancy_Unknow;
const TrafficSign_TrafficSIgnRelevancy TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX = TrafficSign_TrafficSIgnRelevancy_UNRELEVANT;
const int TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_ARRAYSIZE = TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_TrafficSIgnRelevancy_descriptor();
inline const ::std::string& TrafficSign_TrafficSIgnRelevancy_Name(TrafficSign_TrafficSIgnRelevancy value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_TrafficSIgnRelevancy_descriptor(), value);
}
inline bool TrafficSign_TrafficSIgnRelevancy_Parse(
    const ::std::string& name, TrafficSign_TrafficSIgnRelevancy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_TrafficSIgnRelevancy>(
    TrafficSign_TrafficSIgnRelevancy_descriptor(), name, value);
}
enum TrafficSignType_Type {
  TrafficSignType_Type_UNKNOWN = 0,
  TrafficSignType_Type_WARNING = 6,
  TrafficSignType_Type_PROHIBIT = 7,
  TrafficSignType_Type_SUPPLEMENT = 11,
  TrafficSignType_Type_TrafficSignType_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_Type_TrafficSignType_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_Type_IsValid(int value);
const TrafficSignType_Type TrafficSignType_Type_Type_MIN = TrafficSignType_Type_UNKNOWN;
const TrafficSignType_Type TrafficSignType_Type_Type_MAX = TrafficSignType_Type_SUPPLEMENT;
const int TrafficSignType_Type_Type_ARRAYSIZE = TrafficSignType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_Type_descriptor();
inline const ::std::string& TrafficSignType_Type_Name(TrafficSignType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_Type_descriptor(), value);
}
inline bool TrafficSignType_Type_Parse(
    const ::std::string& name, TrafficSignType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_Type>(
    TrafficSignType_Type_descriptor(), name, value);
}
enum TrafficSignType_ProhibitionSign {
  TrafficSignType_ProhibitionSign_SPEED_LIMIT5 = 0,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT10 = 1,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT15 = 2,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT20 = 3,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT30 = 4,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT35 = 5,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT40 = 6,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT50 = 7,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT60 = 8,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT70 = 9,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT80 = 10,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT90 = 11,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT100 = 12,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT110 = 13,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT120 = 14,
  TrafficSignType_ProhibitionSign_STOP = 15,
  TrafficSignType_ProhibitionSign_YIELD = 16,
  TrafficSignType_ProhibitionSign_NO_ENTRY = 17,
  TrafficSignType_ProhibitionSign_DONOT_ENTER = 18,
  TrafficSignType_ProhibitionSign_NO_MOTOR_VEHICLES = 19,
  TrafficSignType_ProhibitionSign_NO_TRUCKS = 20,
  TrafficSignType_ProhibitionSign_NO_LARGE_BUESE = 21,
  TrafficSignType_ProhibitionSign_NO_MOTORCYCLES = 22,
  TrafficSignType_ProhibitionSign_ONLY_MOTOR_VEHICLES = 23,
  TrafficSignType_ProhibitionSign_NO_PEDESTRIANS = 24,
  TrafficSignType_ProhibitionSign_NO_LEFT_TURN = 25,
  TrafficSignType_ProhibitionSign_NO_RIGHT_TURN = 26,
  TrafficSignType_ProhibitionSign_NO_U_TURN = 27,
  TrafficSignType_ProhibitionSign_NO_OVERTAKING = 28,
  TrafficSignType_ProhibitionSign_NO_STOPPING = 29,
  TrafficSignType_ProhibitionSign_NO_HONKING = 30,
  TrafficSignType_ProhibitionSign_MAX_CLEARANCE = 31,
  TrafficSignType_ProhibitionSign_WEIGHT_LIMIT = 32,
  TrafficSignType_ProhibitionSign_AXLE_WEIGHT_LIMIT = 33,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT_END = 34,
  TrafficSignType_ProhibitionSign_NO_MINIBUSES = 35,
  TrafficSignType_ProhibitionSign_NO_TRACTOR = 36,
  TrafficSignType_ProhibitionSign_NO_STRAIGHT = 37,
  TrafficSignType_ProhibitionSign_NO_LEFT_RIGHT_TURN = 38,
  TrafficSignType_ProhibitionSign_NO_OVERTAKING_END = 39,
  TrafficSignType_ProhibitionSign_MAX_WIDTH = 40,
  TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES = 41,
  TrafficSignType_ProhibitionSign_TrafficSignType_ProhibitionSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_ProhibitionSign_TrafficSignType_ProhibitionSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_ProhibitionSign_IsValid(int value);
const TrafficSignType_ProhibitionSign TrafficSignType_ProhibitionSign_ProhibitionSign_MIN = TrafficSignType_ProhibitionSign_SPEED_LIMIT5;
const TrafficSignType_ProhibitionSign TrafficSignType_ProhibitionSign_ProhibitionSign_MAX = TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES;
const int TrafficSignType_ProhibitionSign_ProhibitionSign_ARRAYSIZE = TrafficSignType_ProhibitionSign_ProhibitionSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_ProhibitionSign_descriptor();
inline const ::std::string& TrafficSignType_ProhibitionSign_Name(TrafficSignType_ProhibitionSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_ProhibitionSign_descriptor(), value);
}
inline bool TrafficSignType_ProhibitionSign_Parse(
    const ::std::string& name, TrafficSignType_ProhibitionSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_ProhibitionSign>(
    TrafficSignType_ProhibitionSign_descriptor(), name, value);
}
enum TrafficSignType_WarningSign {
  TrafficSignType_WarningSign_CROSSROADS = 0,
  TrafficSignType_WarningSign_SHARP_CURVE = 1,
  TrafficSignType_WarningSign_REVERSE_CURVE = 2,
  TrafficSignType_WarningSign_WINDING_CURVES = 3,
  TrafficSignType_WarningSign_STEEP_DESCENT = 4,
  TrafficSignType_WarningSign_NARROW_ROAD = 5,
  TrafficSignType_WarningSign_NARROW_BRIDGE = 6,
  TrafficSignType_WarningSign_TWO_WAY_TRAFFIC = 7,
  TrafficSignType_WarningSign_WATCH_PEDESTRIANS = 8,
  TrafficSignType_WarningSign_WATCH_CHILDREN = 9,
  TrafficSignType_WarningSign_TRAFFIC_LIGHTS = 10,
  TrafficSignType_WarningSign_FALING_ROCKS = 11,
  TrafficSignType_WarningSign_CROSSWIND = 12,
  TrafficSignType_WarningSign_SLIPPERY_SURFACE = 13,
  TrafficSignType_WarningSign_STEEP_MOUNTAIN_ROAD = 14,
  TrafficSignType_WarningSign_EMBANKMENT_ROAD = 15,
  TrafficSignType_WarningSign_VILLAGE = 16,
  TrafficSignType_WarningSign_TUNNEL = 17,
  TrafficSignType_WarningSign_HUMP_BACK_BRIDGE = 18,
  TrafficSignType_WarningSign_BUMPY_ROAD = 19,
  TrafficSignType_WarningSign_GUARDED_RAILWAY_CROSSING = 20,
  TrafficSignType_WarningSign_UNGUARDED_RAILWAY_CROSSING = 21,
  TrafficSignType_WarningSign_NON_MOTOR_VEHICLES = 22,
  TrafficSignType_WarningSign_ACCIDENT_BLACK_SPOT = 23,
  TrafficSignType_WarningSign_SLOW_DOWN = 24,
  TrafficSignType_WarningSign_OBSTACLES = 25,
  TrafficSignType_WarningSign_CAUTION_DRIVE = 26,
  TrafficSignType_WarningSign_ROAD_WORK = 27,
  TrafficSignType_WarningSign_SUGGESTED_SPEED = 28,
  TrafficSignType_WarningSign_REVERSIBLE_LANE = 29,
  TrafficSignType_WarningSign_ROADS_MERGE = 30,
  TrafficSignType_WarningSign_ICY_ROAD = 31,
  TrafficSignType_WarningSign_QUEUES_LIKELY = 32,
  TrafficSignType_WarningSign_TrafficSignType_WarningSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_WarningSign_TrafficSignType_WarningSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_WarningSign_IsValid(int value);
const TrafficSignType_WarningSign TrafficSignType_WarningSign_WarningSign_MIN = TrafficSignType_WarningSign_CROSSROADS;
const TrafficSignType_WarningSign TrafficSignType_WarningSign_WarningSign_MAX = TrafficSignType_WarningSign_QUEUES_LIKELY;
const int TrafficSignType_WarningSign_WarningSign_ARRAYSIZE = TrafficSignType_WarningSign_WarningSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_WarningSign_descriptor();
inline const ::std::string& TrafficSignType_WarningSign_Name(TrafficSignType_WarningSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_WarningSign_descriptor(), value);
}
inline bool TrafficSignType_WarningSign_Parse(
    const ::std::string& name, TrafficSignType_WarningSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_WarningSign>(
    TrafficSignType_WarningSign_descriptor(), name, value);
}
enum TrafficSignType_SupplementSign {
  TrafficSignType_SupplementSign_Time_Limit = 0,
  TrafficSignType_SupplementSign_Motor_Vehicles = 1,
  TrafficSignType_SupplementSign_Trucks = 2,
  TrafficSignType_SupplementSign_Arrow_Straight = 3,
  TrafficSignType_SupplementSign_Distance_In = 4,
  TrafficSignType_SupplementSign_School = 5,
  TrafficSignType_SupplementSign_Ramp = 6,
  TrafficSignType_SupplementSign_Minbuses = 7,
  TrafficSignType_SupplementSign_Arrow_Left = 8,
  TrafficSignType_SupplementSign_Arrow_Right = 9,
  TrafficSignType_SupplementSign_BendArrow_Left = 10,
  TrafficSignType_SupplementSign_BendArrow_Right = 11,
  TrafficSignType_SupplementSign_Arrow_Twoway = 12,
  TrafficSignType_SupplementSign_TrafficSignType_SupplementSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_SupplementSign_TrafficSignType_SupplementSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_SupplementSign_IsValid(int value);
const TrafficSignType_SupplementSign TrafficSignType_SupplementSign_SupplementSign_MIN = TrafficSignType_SupplementSign_Time_Limit;
const TrafficSignType_SupplementSign TrafficSignType_SupplementSign_SupplementSign_MAX = TrafficSignType_SupplementSign_Arrow_Twoway;
const int TrafficSignType_SupplementSign_SupplementSign_ARRAYSIZE = TrafficSignType_SupplementSign_SupplementSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_SupplementSign_descriptor();
inline const ::std::string& TrafficSignType_SupplementSign_Name(TrafficSignType_SupplementSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_SupplementSign_descriptor(), value);
}
inline bool TrafficSignType_SupplementSign_Parse(
    const ::std::string& name, TrafficSignType_SupplementSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_SupplementSign>(
    TrafficSignType_SupplementSign_descriptor(), name, value);
}
enum AebOutput_AebOut {
  AebOutput_AebOut_AEB_IDLE = 0,
  AebOutput_AebOut_AEB_WARNING = 1,
  AebOutput_AebOut_AEB_BRAKING_LEVEL1 = 2,
  AebOutput_AebOut_AEB_BRAKING_LEVEL2 = 3,
  AebOutput_AebOut_AEB_BRAKING_LEVEL3 = 4,
  AebOutput_AebOut_AebOutput_AebOut_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AebOutput_AebOut_AebOutput_AebOut_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AebOutput_AebOut_IsValid(int value);
const AebOutput_AebOut AebOutput_AebOut_AebOut_MIN = AebOutput_AebOut_AEB_IDLE;
const AebOutput_AebOut AebOutput_AebOut_AebOut_MAX = AebOutput_AebOut_AEB_BRAKING_LEVEL3;
const int AebOutput_AebOut_AebOut_ARRAYSIZE = AebOutput_AebOut_AebOut_MAX + 1;

const ::google::protobuf::EnumDescriptor* AebOutput_AebOut_descriptor();
inline const ::std::string& AebOutput_AebOut_Name(AebOutput_AebOut value) {
  return ::google::protobuf::internal::NameOfEnum(
    AebOutput_AebOut_descriptor(), value);
}
inline bool AebOutput_AebOut_Parse(
    const ::std::string& name, AebOutput_AebOut* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AebOutput_AebOut>(
    AebOutput_AebOut_descriptor(), name, value);
}
enum AebOutput_AebDecision {
  AebOutput_AebDecision_AEB_DECISION_IDLE = 0,
  AebOutput_AebDecision_AEB_DECISION_WARNING = 1,
  AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL1 = 2,
  AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL2 = 3,
  AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL3 = 4,
  AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL1 = 5,
  AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL2 = 6,
  AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL3 = 7,
  AebOutput_AebDecision_AebOutput_AebDecision_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AebOutput_AebDecision_AebOutput_AebDecision_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AebOutput_AebDecision_IsValid(int value);
const AebOutput_AebDecision AebOutput_AebDecision_AebDecision_MIN = AebOutput_AebDecision_AEB_DECISION_IDLE;
const AebOutput_AebDecision AebOutput_AebDecision_AebDecision_MAX = AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL3;
const int AebOutput_AebDecision_AebDecision_ARRAYSIZE = AebOutput_AebDecision_AebDecision_MAX + 1;

const ::google::protobuf::EnumDescriptor* AebOutput_AebDecision_descriptor();
inline const ::std::string& AebOutput_AebDecision_Name(AebOutput_AebDecision value) {
  return ::google::protobuf::internal::NameOfEnum(
    AebOutput_AebDecision_descriptor(), value);
}
inline bool AebOutput_AebDecision_Parse(
    const ::std::string& name, AebOutput_AebDecision* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AebOutput_AebDecision>(
    AebOutput_AebDecision_descriptor(), name, value);
}
enum Failsafe_FailSafeBlockage {
  Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN = 0,
  Failsafe_FailSafeBlockage_BLOCKAGE_FULL = 1,
  Failsafe_FailSafeBlockage_BLOCKAGE_PARTICAL = 2,
  Failsafe_FailSafeBlockage_BLOCKAGE_NONE = 3,
  Failsafe_FailSafeBlockage_Failsafe_FailSafeBlockage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeBlockage_Failsafe_FailSafeBlockage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeBlockage_IsValid(int value);
const Failsafe_FailSafeBlockage Failsafe_FailSafeBlockage_FailSafeBlockage_MIN = Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN;
const Failsafe_FailSafeBlockage Failsafe_FailSafeBlockage_FailSafeBlockage_MAX = Failsafe_FailSafeBlockage_BLOCKAGE_NONE;
const int Failsafe_FailSafeBlockage_FailSafeBlockage_ARRAYSIZE = Failsafe_FailSafeBlockage_FailSafeBlockage_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeBlockage_descriptor();
inline const ::std::string& Failsafe_FailSafeBlockage_Name(Failsafe_FailSafeBlockage value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeBlockage_descriptor(), value);
}
inline bool Failsafe_FailSafeBlockage_Parse(
    const ::std::string& name, Failsafe_FailSafeBlockage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeBlockage>(
    Failsafe_FailSafeBlockage_descriptor(), name, value);
}
enum Failsafe_FailSafeWeather {
  Failsafe_FailSafeWeather_WEATHER_UNKNOWN = 0,
  Failsafe_FailSafeWeather_WEATHER_FOG = 1,
  Failsafe_FailSafeWeather_WEATHER_RAIN = 2,
  Failsafe_FailSafeWeather_WEATHER_SNOW = 3,
  Failsafe_FailSafeWeather_WEATHER_SUNNY = 4,
  Failsafe_FailSafeWeather_Failsafe_FailSafeWeather_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeWeather_Failsafe_FailSafeWeather_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeWeather_IsValid(int value);
const Failsafe_FailSafeWeather Failsafe_FailSafeWeather_FailSafeWeather_MIN = Failsafe_FailSafeWeather_WEATHER_UNKNOWN;
const Failsafe_FailSafeWeather Failsafe_FailSafeWeather_FailSafeWeather_MAX = Failsafe_FailSafeWeather_WEATHER_SUNNY;
const int Failsafe_FailSafeWeather_FailSafeWeather_ARRAYSIZE = Failsafe_FailSafeWeather_FailSafeWeather_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeWeather_descriptor();
inline const ::std::string& Failsafe_FailSafeWeather_Name(Failsafe_FailSafeWeather value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeWeather_descriptor(), value);
}
inline bool Failsafe_FailSafeWeather_Parse(
    const ::std::string& name, Failsafe_FailSafeWeather* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeWeather>(
    Failsafe_FailSafeWeather_descriptor(), name, value);
}
enum Failsafe_FailSafeIllumination {
  Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN = 0,
  Failsafe_FailSafeIllumination_ILLUMINATION_DAY = 1,
  Failsafe_FailSafeIllumination_ILLUMINATION_DUSK = 2,
  Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT = 3,
  Failsafe_FailSafeIllumination_Failsafe_FailSafeIllumination_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeIllumination_Failsafe_FailSafeIllumination_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeIllumination_IsValid(int value);
const Failsafe_FailSafeIllumination Failsafe_FailSafeIllumination_FailSafeIllumination_MIN = Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN;
const Failsafe_FailSafeIllumination Failsafe_FailSafeIllumination_FailSafeIllumination_MAX = Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT;
const int Failsafe_FailSafeIllumination_FailSafeIllumination_ARRAYSIZE = Failsafe_FailSafeIllumination_FailSafeIllumination_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeIllumination_descriptor();
inline const ::std::string& Failsafe_FailSafeIllumination_Name(Failsafe_FailSafeIllumination value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeIllumination_descriptor(), value);
}
inline bool Failsafe_FailSafeIllumination_Parse(
    const ::std::string& name, Failsafe_FailSafeIllumination* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeIllumination>(
    Failsafe_FailSafeIllumination_descriptor(), name, value);
}
enum Failsafe_FailSafeImageLimited {
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN = 0,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_NORMAL = 1,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_LOWSUN = 2,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SPALSHES = 3,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_BLUR = 4,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SUNRAY = 5,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_FROZEN = 6,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER = 7,
  Failsafe_FailSafeImageLimited_Failsafe_FailSafeImageLimited_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeImageLimited_Failsafe_FailSafeImageLimited_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeImageLimited_IsValid(int value);
const Failsafe_FailSafeImageLimited Failsafe_FailSafeImageLimited_FailSafeImageLimited_MIN = Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN;
const Failsafe_FailSafeImageLimited Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX = Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER;
const int Failsafe_FailSafeImageLimited_FailSafeImageLimited_ARRAYSIZE = Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeImageLimited_descriptor();
inline const ::std::string& Failsafe_FailSafeImageLimited_Name(Failsafe_FailSafeImageLimited value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeImageLimited_descriptor(), value);
}
inline bool Failsafe_FailSafeImageLimited_Parse(
    const ::std::string& name, Failsafe_FailSafeImageLimited* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeImageLimited>(
    Failsafe_FailSafeImageLimited_descriptor(), name, value);
}
enum MeasuringStatus0 {
  MS_OLD = 0,
  MS_NEW = 1,
  MeasuringStatus0_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus0_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus0_IsValid(int value);
const MeasuringStatus0 MeasuringStatus0_MIN = MS_OLD;
const MeasuringStatus0 MeasuringStatus0_MAX = MS_NEW;
const int MeasuringStatus0_ARRAYSIZE = MeasuringStatus0_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus0_descriptor();
inline const ::std::string& MeasuringStatus0_Name(MeasuringStatus0 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus0_descriptor(), value);
}
inline bool MeasuringStatus0_Parse(
    const ::std::string& name, MeasuringStatus0* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus0>(
    MeasuringStatus0_descriptor(), name, value);
}
enum MeasuringStatus1 {
  MS_PREDICTED = 0,
  MS_MEASURED = 1,
  MeasuringStatus1_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus1_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus1_IsValid(int value);
const MeasuringStatus1 MeasuringStatus1_MIN = MS_PREDICTED;
const MeasuringStatus1 MeasuringStatus1_MAX = MS_MEASURED;
const int MeasuringStatus1_ARRAYSIZE = MeasuringStatus1_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus1_descriptor();
inline const ::std::string& MeasuringStatus1_Name(MeasuringStatus1 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus1_descriptor(), value);
}
inline bool MeasuringStatus1_Parse(
    const ::std::string& name, MeasuringStatus1* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus1>(
    MeasuringStatus1_descriptor(), name, value);
}
enum MeasuringStatus2 {
  MS_INVALID = 0,
  MS_VALID = 1,
  MeasuringStatus2_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus2_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus2_IsValid(int value);
const MeasuringStatus2 MeasuringStatus2_MIN = MS_INVALID;
const MeasuringStatus2 MeasuringStatus2_MAX = MS_VALID;
const int MeasuringStatus2_ARRAYSIZE = MeasuringStatus2_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus2_descriptor();
inline const ::std::string& MeasuringStatus2_Name(MeasuringStatus2 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus2_descriptor(), value);
}
inline bool MeasuringStatus2_Parse(
    const ::std::string& name, MeasuringStatus2* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus2>(
    MeasuringStatus2_descriptor(), name, value);
}
enum MotionCategory {
  MC_UNFILLED = 0,
  MC_UNDEFINED = 1,
  MC_PASSING = 2,
  MC_PASSING_IN = 3,
  MC_PASSING_OUT = 4,
  MC_CLOSE_CUT_IN = 5,
  MC_MOVING_IN = 6,
  MC_MOVING_OUT = 7,
  MC_CROSSING = 8,
  MC_LTAP = 9,
  MC_RTAP = 10,
  MC_MOVING = 11,
  MC_PRECEEDING = 12,
  MC_ONCOMING = 13,
  MotionCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionCategory_IsValid(int value);
const MotionCategory MotionCategory_MIN = MC_UNFILLED;
const MotionCategory MotionCategory_MAX = MC_ONCOMING;
const int MotionCategory_ARRAYSIZE = MotionCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionCategory_descriptor();
inline const ::std::string& MotionCategory_Name(MotionCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionCategory_descriptor(), value);
}
inline bool MotionCategory_Parse(
    const ::std::string& name, MotionCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionCategory>(
    MotionCategory_descriptor(), name, value);
}
enum MotionOrientation {
  MO_INVALID = 0,
  MO_DRIFTING_RIGHT = 1,
  MO_CROSSING_RIGHT = 3,
  MO_OC_DRIFTING_RIGHT = 5,
  MO_ONCOMING = 6,
  MO_OC_DRIFTING_LEFT = 7,
  MO_CROSSING_LEFT = 9,
  MO_DRIFTING_LEFT = 11,
  MO_PRECEEDING = 12,
  MO_UNKNOWN = 13,
  MotionOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionOrientation_IsValid(int value);
const MotionOrientation MotionOrientation_MIN = MO_INVALID;
const MotionOrientation MotionOrientation_MAX = MO_UNKNOWN;
const int MotionOrientation_ARRAYSIZE = MotionOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionOrientation_descriptor();
inline const ::std::string& MotionOrientation_Name(MotionOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionOrientation_descriptor(), value);
}
inline bool MotionOrientation_Parse(
    const ::std::string& name, MotionOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionOrientation>(
    MotionOrientation_descriptor(), name, value);
}
enum VisibilitySide {
  VS_NOT_VISIBLE = 0,
  VS_FRONT = 1,
  VS_REAR = 2,
  VisibilitySide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VisibilitySide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VisibilitySide_IsValid(int value);
const VisibilitySide VisibilitySide_MIN = VS_NOT_VISIBLE;
const VisibilitySide VisibilitySide_MAX = VS_REAR;
const int VisibilitySide_ARRAYSIZE = VisibilitySide_MAX + 1;

const ::google::protobuf::EnumDescriptor* VisibilitySide_descriptor();
inline const ::std::string& VisibilitySide_Name(VisibilitySide value) {
  return ::google::protobuf::internal::NameOfEnum(
    VisibilitySide_descriptor(), value);
}
inline bool VisibilitySide_Parse(
    const ::std::string& name, VisibilitySide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisibilitySide>(
    VisibilitySide_descriptor(), name, value);
}
enum MotionStatusV2 {
  MotionStatusV2_INVALID = 0,
  MotionStatusV2_UNKNOWN = 1,
  MotionStatusV2_MOVING = 2,
  MotionStatusV2_STATIONARY = 3,
  MotionStatusV2_STOPPED = 4,
  MotionStatusV2_MOVING_SLOWLY = 5,
  MotionStatusV2_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionStatusV2_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionStatusV2_IsValid(int value);
const MotionStatusV2 MotionStatusV2_MIN = MotionStatusV2_INVALID;
const MotionStatusV2 MotionStatusV2_MAX = MotionStatusV2_MOVING_SLOWLY;
const int MotionStatusV2_ARRAYSIZE = MotionStatusV2_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionStatusV2_descriptor();
inline const ::std::string& MotionStatusV2_Name(MotionStatusV2 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionStatusV2_descriptor(), value);
}
inline bool MotionStatusV2_Parse(
    const ::std::string& name, MotionStatusV2* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionStatusV2>(
    MotionStatusV2_descriptor(), name, value);
}
enum CutInCutOut {
  CUT_IN_CUT_OUT_UNKNOWN = 0,
  CUT_IN_CUT_OUT_HOST_CUT_IN_LEFT = 1,
  CUT_IN_CUT_OUT_HOST_CUT_IN_RIGHT = 2,
  CUT_IN_CUT_OUT_HOST_CUT_OUT_LEFT = 3,
  CUT_IN_CUT_OUT_HOST_CUT_OUT_RIGHT = 4,
  CUT_IN_CUT_OUT_NO_CUT_IN_OUT = 5,
  CutInCutOut_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CutInCutOut_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CutInCutOut_IsValid(int value);
const CutInCutOut CutInCutOut_MIN = CUT_IN_CUT_OUT_UNKNOWN;
const CutInCutOut CutInCutOut_MAX = CUT_IN_CUT_OUT_NO_CUT_IN_OUT;
const int CutInCutOut_ARRAYSIZE = CutInCutOut_MAX + 1;

const ::google::protobuf::EnumDescriptor* CutInCutOut_descriptor();
inline const ::std::string& CutInCutOut_Name(CutInCutOut value) {
  return ::google::protobuf::internal::NameOfEnum(
    CutInCutOut_descriptor(), value);
}
inline bool CutInCutOut_Parse(
    const ::std::string& name, CutInCutOut* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CutInCutOut>(
    CutInCutOut_descriptor(), name, value);
}
enum AebFollowObjectState {
  AEB_OBJ_NORMAL = 0,
  AEB_OBJ_WARNING = 1,
  AEB_OBJ_FRONT_STOP = 2,
  AEB_OBJ_FRONT_SLOWMOVE = 3,
  AEB_OBJ_PASS_THOUGH = 4,
  AebFollowObjectState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AebFollowObjectState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AebFollowObjectState_IsValid(int value);
const AebFollowObjectState AebFollowObjectState_MIN = AEB_OBJ_NORMAL;
const AebFollowObjectState AebFollowObjectState_MAX = AEB_OBJ_PASS_THOUGH;
const int AebFollowObjectState_ARRAYSIZE = AebFollowObjectState_MAX + 1;

const ::google::protobuf::EnumDescriptor* AebFollowObjectState_descriptor();
inline const ::std::string& AebFollowObjectState_Name(AebFollowObjectState value) {
  return ::google::protobuf::internal::NameOfEnum(
    AebFollowObjectState_descriptor(), value);
}
inline bool AebFollowObjectState_Parse(
    const ::std::string& name, AebFollowObjectState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AebFollowObjectState>(
    AebFollowObjectState_descriptor(), name, value);
}
enum CipvLost {
  CipvLost_NO_LOSS = 0,
  CipvLost_LOST_TARGET_FOV_OUT = 1,
  CipvLost_LOST_TARGET_FOV_IN = 2,
  CipvLost_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CipvLost_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CipvLost_IsValid(int value);
const CipvLost CipvLost_MIN = CipvLost_NO_LOSS;
const CipvLost CipvLost_MAX = CipvLost_LOST_TARGET_FOV_IN;
const int CipvLost_ARRAYSIZE = CipvLost_MAX + 1;

const ::google::protobuf::EnumDescriptor* CipvLost_descriptor();
inline const ::std::string& CipvLost_Name(CipvLost value) {
  return ::google::protobuf::internal::NameOfEnum(
    CipvLost_descriptor(), value);
}
inline bool CipvLost_Parse(
    const ::std::string& name, CipvLost* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CipvLost>(
    CipvLost_descriptor(), name, value);
}
enum AllowAcc {
  AllowAcc_FREE_SPACE = 0,
  AllowAcc_SPACE_NOT_FREE = 1,
  AllowAcc_FREE_SPACE_UNKNOWN = 2,
  AllowAcc_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AllowAcc_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AllowAcc_IsValid(int value);
const AllowAcc AllowAcc_MIN = AllowAcc_FREE_SPACE;
const AllowAcc AllowAcc_MAX = AllowAcc_FREE_SPACE_UNKNOWN;
const int AllowAcc_ARRAYSIZE = AllowAcc_MAX + 1;

const ::google::protobuf::EnumDescriptor* AllowAcc_descriptor();
inline const ::std::string& AllowAcc_Name(AllowAcc value) {
  return ::google::protobuf::internal::NameOfEnum(
    AllowAcc_descriptor(), value);
}
inline bool AllowAcc_Parse(
    const ::std::string& name, AllowAcc* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AllowAcc>(
    AllowAcc_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Header_ProtobufVersion ProtobufVersion;
  static const ProtobufVersion V_1_0_0 =
    Header_ProtobufVersion_V_1_0_0;
  static const ProtobufVersion V_1_0_1 =
    Header_ProtobufVersion_V_1_0_1;
  static const ProtobufVersion V_1_0_2 =
    Header_ProtobufVersion_V_1_0_2;
  static const ProtobufVersion V_1_0_3 =
    Header_ProtobufVersion_V_1_0_3;
  static const ProtobufVersion V_1_0_4 =
    Header_ProtobufVersion_V_1_0_4;
  static const ProtobufVersion V_1_0_5 =
    Header_ProtobufVersion_V_1_0_5;
  static const ProtobufVersion V_1_0_6 =
    Header_ProtobufVersion_V_1_0_6;
  static const ProtobufVersion V_1_0_7 =
    Header_ProtobufVersion_V_1_0_7;
  static const ProtobufVersion V_1_0_8 =
    Header_ProtobufVersion_V_1_0_8;
  static const ProtobufVersion V_1_0_9 =
    Header_ProtobufVersion_V_1_0_9;
  static const ProtobufVersion V_1_0_10 =
    Header_ProtobufVersion_V_1_0_10;
  static const ProtobufVersion V_1_0_11 =
    Header_ProtobufVersion_V_1_0_11;
  static const ProtobufVersion V_1_0_12 =
    Header_ProtobufVersion_V_1_0_12;
  static const ProtobufVersion V_1_0_13 =
    Header_ProtobufVersion_V_1_0_13;
  static const ProtobufVersion V_1_0_14 =
    Header_ProtobufVersion_V_1_0_14;
  static const ProtobufVersion V_1_0_15 =
    Header_ProtobufVersion_V_1_0_15;
  static const ProtobufVersion V_1_0_16 =
    Header_ProtobufVersion_V_1_0_16;
  static const ProtobufVersion V_1_0_17 =
    Header_ProtobufVersion_V_1_0_17;
  static const ProtobufVersion CURRENT_VERSION =
    Header_ProtobufVersion_CURRENT_VERSION;
  static inline bool ProtobufVersion_IsValid(int value) {
    return Header_ProtobufVersion_IsValid(value);
  }
  static const ProtobufVersion ProtobufVersion_MIN =
    Header_ProtobufVersion_ProtobufVersion_MIN;
  static const ProtobufVersion ProtobufVersion_MAX =
    Header_ProtobufVersion_ProtobufVersion_MAX;
  static const int ProtobufVersion_ARRAYSIZE =
    Header_ProtobufVersion_ProtobufVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtobufVersion_descriptor() {
    return Header_ProtobufVersion_descriptor();
  }
  static inline const ::std::string& ProtobufVersion_Name(ProtobufVersion value) {
    return Header_ProtobufVersion_Name(value);
  }
  static inline bool ProtobufVersion_Parse(const ::std::string& name,
      ProtobufVersion* value) {
    return Header_ProtobufVersion_Parse(name, value);
  }

  typedef Header_ObjectVersion ObjectVersion;
  static const ObjectVersion OD_V_1_0 =
    Header_ObjectVersion_OD_V_1_0;
  static const ObjectVersion OD_V_1_1 =
    Header_ObjectVersion_OD_V_1_1;
  static const ObjectVersion OD_CURRENT_VERSION =
    Header_ObjectVersion_OD_CURRENT_VERSION;
  static inline bool ObjectVersion_IsValid(int value) {
    return Header_ObjectVersion_IsValid(value);
  }
  static const ObjectVersion ObjectVersion_MIN =
    Header_ObjectVersion_ObjectVersion_MIN;
  static const ObjectVersion ObjectVersion_MAX =
    Header_ObjectVersion_ObjectVersion_MAX;
  static const int ObjectVersion_ARRAYSIZE =
    Header_ObjectVersion_ObjectVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectVersion_descriptor() {
    return Header_ObjectVersion_descriptor();
  }
  static inline const ::std::string& ObjectVersion_Name(ObjectVersion value) {
    return Header_ObjectVersion_Name(value);
  }
  static inline bool ObjectVersion_Parse(const ::std::string& name,
      ObjectVersion* value) {
    return Header_ObjectVersion_Parse(name, value);
  }

  typedef Header_TrafficLightStructVersion TrafficLightStructVersion;
  static const TrafficLightStructVersion TFL_STRUCT_V_1_0 =
    Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0;
  static const TrafficLightStructVersion TFL_STRUCT_V_1_1 =
    Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1;
  static const TrafficLightStructVersion TFL_STRUCT_CURRENT_VERSION =
    Header_TrafficLightStructVersion_TFL_STRUCT_CURRENT_VERSION;
  static inline bool TrafficLightStructVersion_IsValid(int value) {
    return Header_TrafficLightStructVersion_IsValid(value);
  }
  static const TrafficLightStructVersion TrafficLightStructVersion_MIN =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_MIN;
  static const TrafficLightStructVersion TrafficLightStructVersion_MAX =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX;
  static const int TrafficLightStructVersion_ARRAYSIZE =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficLightStructVersion_descriptor() {
    return Header_TrafficLightStructVersion_descriptor();
  }
  static inline const ::std::string& TrafficLightStructVersion_Name(TrafficLightStructVersion value) {
    return Header_TrafficLightStructVersion_Name(value);
  }
  static inline bool TrafficLightStructVersion_Parse(const ::std::string& name,
      TrafficLightStructVersion* value) {
    return Header_TrafficLightStructVersion_Parse(name, value);
  }

  typedef Header_TrafficLightSpotVersion TrafficLightSpotVersion;
  static const TrafficLightSpotVersion TFL_SPOT_V_1_0 =
    Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0;
  static const TrafficLightSpotVersion TFL_SPOT_V_1_1 =
    Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1;
  static const TrafficLightSpotVersion TFL_SPOT_CURRENT_VERSION =
    Header_TrafficLightSpotVersion_TFL_SPOT_CURRENT_VERSION;
  static inline bool TrafficLightSpotVersion_IsValid(int value) {
    return Header_TrafficLightSpotVersion_IsValid(value);
  }
  static const TrafficLightSpotVersion TrafficLightSpotVersion_MIN =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MIN;
  static const TrafficLightSpotVersion TrafficLightSpotVersion_MAX =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX;
  static const int TrafficLightSpotVersion_ARRAYSIZE =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficLightSpotVersion_descriptor() {
    return Header_TrafficLightSpotVersion_descriptor();
  }
  static inline const ::std::string& TrafficLightSpotVersion_Name(TrafficLightSpotVersion value) {
    return Header_TrafficLightSpotVersion_Name(value);
  }
  static inline bool TrafficLightSpotVersion_Parse(const ::std::string& name,
      TrafficLightSpotVersion* value) {
    return Header_TrafficLightSpotVersion_Parse(name, value);
  }

  typedef Header_TrafficSignVersion TrafficSignVersion;
  static const TrafficSignVersion TSR_V_1_0 =
    Header_TrafficSignVersion_TSR_V_1_0;
  static const TrafficSignVersion TSR_V_1_1 =
    Header_TrafficSignVersion_TSR_V_1_1;
  static const TrafficSignVersion TSR_CURRENT_VERSION =
    Header_TrafficSignVersion_TSR_CURRENT_VERSION;
  static inline bool TrafficSignVersion_IsValid(int value) {
    return Header_TrafficSignVersion_IsValid(value);
  }
  static const TrafficSignVersion TrafficSignVersion_MIN =
    Header_TrafficSignVersion_TrafficSignVersion_MIN;
  static const TrafficSignVersion TrafficSignVersion_MAX =
    Header_TrafficSignVersion_TrafficSignVersion_MAX;
  static const int TrafficSignVersion_ARRAYSIZE =
    Header_TrafficSignVersion_TrafficSignVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSignVersion_descriptor() {
    return Header_TrafficSignVersion_descriptor();
  }
  static inline const ::std::string& TrafficSignVersion_Name(TrafficSignVersion value) {
    return Header_TrafficSignVersion_Name(value);
  }
  static inline bool TrafficSignVersion_Parse(const ::std::string& name,
      TrafficSignVersion* value) {
    return Header_TrafficSignVersion_Parse(name, value);
  }

  typedef Header_FailSafeVersion FailSafeVersion;
  static const FailSafeVersion FS_V_1_0 =
    Header_FailSafeVersion_FS_V_1_0;
  static const FailSafeVersion FS_V_1_1 =
    Header_FailSafeVersion_FS_V_1_1;
  static const FailSafeVersion FS_CURRENT_VERSION =
    Header_FailSafeVersion_FS_CURRENT_VERSION;
  static inline bool FailSafeVersion_IsValid(int value) {
    return Header_FailSafeVersion_IsValid(value);
  }
  static const FailSafeVersion FailSafeVersion_MIN =
    Header_FailSafeVersion_FailSafeVersion_MIN;
  static const FailSafeVersion FailSafeVersion_MAX =
    Header_FailSafeVersion_FailSafeVersion_MAX;
  static const int FailSafeVersion_ARRAYSIZE =
    Header_FailSafeVersion_FailSafeVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeVersion_descriptor() {
    return Header_FailSafeVersion_descriptor();
  }
  static inline const ::std::string& FailSafeVersion_Name(FailSafeVersion value) {
    return Header_FailSafeVersion_Name(value);
  }
  static inline bool FailSafeVersion_Parse(const ::std::string& name,
      FailSafeVersion* value) {
    return Header_FailSafeVersion_Parse(name, value);
  }

  typedef Header_LaneVersion LaneVersion;
  static const LaneVersion LANE_V_1_0 =
    Header_LaneVersion_LANE_V_1_0;
  static const LaneVersion LANE_V_1_1 =
    Header_LaneVersion_LANE_V_1_1;
  static const LaneVersion LANE_CURRENT_VERSION =
    Header_LaneVersion_LANE_CURRENT_VERSION;
  static inline bool LaneVersion_IsValid(int value) {
    return Header_LaneVersion_IsValid(value);
  }
  static const LaneVersion LaneVersion_MIN =
    Header_LaneVersion_LaneVersion_MIN;
  static const LaneVersion LaneVersion_MAX =
    Header_LaneVersion_LaneVersion_MAX;
  static const int LaneVersion_ARRAYSIZE =
    Header_LaneVersion_LaneVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneVersion_descriptor() {
    return Header_LaneVersion_descriptor();
  }
  static inline const ::std::string& LaneVersion_Name(LaneVersion value) {
    return Header_LaneVersion_Name(value);
  }
  static inline bool LaneVersion_Parse(const ::std::string& name,
      LaneVersion* value) {
    return Header_LaneVersion_Parse(name, value);
  }

  typedef Header_RoadMarkVersion RoadMarkVersion;
  static const RoadMarkVersion RM_V_1_0 =
    Header_RoadMarkVersion_RM_V_1_0;
  static const RoadMarkVersion RM_V_1_1 =
    Header_RoadMarkVersion_RM_V_1_1;
  static const RoadMarkVersion RM_CURRENT_VERSION =
    Header_RoadMarkVersion_RM_CURRENT_VERSION;
  static inline bool RoadMarkVersion_IsValid(int value) {
    return Header_RoadMarkVersion_IsValid(value);
  }
  static const RoadMarkVersion RoadMarkVersion_MIN =
    Header_RoadMarkVersion_RoadMarkVersion_MIN;
  static const RoadMarkVersion RoadMarkVersion_MAX =
    Header_RoadMarkVersion_RoadMarkVersion_MAX;
  static const int RoadMarkVersion_ARRAYSIZE =
    Header_RoadMarkVersion_RoadMarkVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadMarkVersion_descriptor() {
    return Header_RoadMarkVersion_descriptor();
  }
  static inline const ::std::string& RoadMarkVersion_Name(RoadMarkVersion value) {
    return Header_RoadMarkVersion_Name(value);
  }
  static inline bool RoadMarkVersion_Parse(const ::std::string& name,
      RoadMarkVersion* value) {
    return Header_RoadMarkVersion_Parse(name, value);
  }

  typedef Header_FreeSpaceVersion FreeSpaceVersion;
  static const FreeSpaceVersion FSP_V_1_0 =
    Header_FreeSpaceVersion_FSP_V_1_0;
  static const FreeSpaceVersion FSP_V_1_1 =
    Header_FreeSpaceVersion_FSP_V_1_1;
  static const FreeSpaceVersion FSP_CURRENT_VERSION =
    Header_FreeSpaceVersion_FSP_CURRENT_VERSION;
  static inline bool FreeSpaceVersion_IsValid(int value) {
    return Header_FreeSpaceVersion_IsValid(value);
  }
  static const FreeSpaceVersion FreeSpaceVersion_MIN =
    Header_FreeSpaceVersion_FreeSpaceVersion_MIN;
  static const FreeSpaceVersion FreeSpaceVersion_MAX =
    Header_FreeSpaceVersion_FreeSpaceVersion_MAX;
  static const int FreeSpaceVersion_ARRAYSIZE =
    Header_FreeSpaceVersion_FreeSpaceVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FreeSpaceVersion_descriptor() {
    return Header_FreeSpaceVersion_descriptor();
  }
  static inline const ::std::string& FreeSpaceVersion_Name(FreeSpaceVersion value) {
    return Header_FreeSpaceVersion_Name(value);
  }
  static inline bool FreeSpaceVersion_Parse(const ::std::string& name,
      FreeSpaceVersion* value) {
    return Header_FreeSpaceVersion_Parse(name, value);
  }

  typedef Header_BarricadeVersion BarricadeVersion;
  static const BarricadeVersion BA_V_1_0 =
    Header_BarricadeVersion_BA_V_1_0;
  static const BarricadeVersion BA_CURRENT_VERSION =
    Header_BarricadeVersion_BA_CURRENT_VERSION;
  static inline bool BarricadeVersion_IsValid(int value) {
    return Header_BarricadeVersion_IsValid(value);
  }
  static const BarricadeVersion BarricadeVersion_MIN =
    Header_BarricadeVersion_BarricadeVersion_MIN;
  static const BarricadeVersion BarricadeVersion_MAX =
    Header_BarricadeVersion_BarricadeVersion_MAX;
  static const int BarricadeVersion_ARRAYSIZE =
    Header_BarricadeVersion_BarricadeVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BarricadeVersion_descriptor() {
    return Header_BarricadeVersion_descriptor();
  }
  static inline const ::std::string& BarricadeVersion_Name(BarricadeVersion value) {
    return Header_BarricadeVersion_Name(value);
  }
  static inline bool BarricadeVersion_Parse(const ::std::string& name,
      BarricadeVersion* value) {
    return Header_BarricadeVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string perception_version = 3;
  void clear_perception_version();
  static const int kPerceptionVersionFieldNumber = 3;
  const ::std::string& perception_version() const;
  void set_perception_version(const ::std::string& value);
  #if LANG_CXX11
  void set_perception_version(::std::string&& value);
  #endif
  void set_perception_version(const char* value);
  void set_perception_version(const char* value, size_t size);
  ::std::string* mutable_perception_version();
  ::std::string* release_perception_version();
  void set_allocated_perception_version(::std::string* perception_version);

  // int64 frame_index = 1;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.Header.ProtobufVersion protobuf_version = 4;
  void clear_protobuf_version();
  static const int kProtobufVersionFieldNumber = 4;
  ::calmcar::perception::Header_ProtobufVersion protobuf_version() const;
  void set_protobuf_version(::calmcar::perception::Header_ProtobufVersion value);

  // .calmcar.perception.Header.ObjectVersion object_version = 5;
  void clear_object_version();
  static const int kObjectVersionFieldNumber = 5;
  ::calmcar::perception::Header_ObjectVersion object_version() const;
  void set_object_version(::calmcar::perception::Header_ObjectVersion value);

  // .calmcar.perception.Header.TrafficLightStructVersion tfl_struct_version = 6;
  void clear_tfl_struct_version();
  static const int kTflStructVersionFieldNumber = 6;
  ::calmcar::perception::Header_TrafficLightStructVersion tfl_struct_version() const;
  void set_tfl_struct_version(::calmcar::perception::Header_TrafficLightStructVersion value);

  // .calmcar.perception.Header.TrafficLightSpotVersion tfl_spot_version = 7;
  void clear_tfl_spot_version();
  static const int kTflSpotVersionFieldNumber = 7;
  ::calmcar::perception::Header_TrafficLightSpotVersion tfl_spot_version() const;
  void set_tfl_spot_version(::calmcar::perception::Header_TrafficLightSpotVersion value);

  // .calmcar.perception.Header.TrafficSignVersion traffic_sign_version = 8;
  void clear_traffic_sign_version();
  static const int kTrafficSignVersionFieldNumber = 8;
  ::calmcar::perception::Header_TrafficSignVersion traffic_sign_version() const;
  void set_traffic_sign_version(::calmcar::perception::Header_TrafficSignVersion value);

  // .calmcar.perception.Header.FailSafeVersion fail_safe_version = 9;
  void clear_fail_safe_version();
  static const int kFailSafeVersionFieldNumber = 9;
  ::calmcar::perception::Header_FailSafeVersion fail_safe_version() const;
  void set_fail_safe_version(::calmcar::perception::Header_FailSafeVersion value);

  // .calmcar.perception.Header.LaneVersion lane_version = 10;
  void clear_lane_version();
  static const int kLaneVersionFieldNumber = 10;
  ::calmcar::perception::Header_LaneVersion lane_version() const;
  void set_lane_version(::calmcar::perception::Header_LaneVersion value);

  // .calmcar.perception.Header.RoadMarkVersion road_mark_version = 11;
  void clear_road_mark_version();
  static const int kRoadMarkVersionFieldNumber = 11;
  ::calmcar::perception::Header_RoadMarkVersion road_mark_version() const;
  void set_road_mark_version(::calmcar::perception::Header_RoadMarkVersion value);

  // .calmcar.perception.Header.FreeSpaceVersion free_space_version = 12;
  void clear_free_space_version();
  static const int kFreeSpaceVersionFieldNumber = 12;
  ::calmcar::perception::Header_FreeSpaceVersion free_space_version() const;
  void set_free_space_version(::calmcar::perception::Header_FreeSpaceVersion value);

  // .calmcar.perception.Header.BarricadeVersion barricade_version = 13;
  void clear_barricade_version();
  static const int kBarricadeVersionFieldNumber = 13;
  ::calmcar::perception::Header_BarricadeVersion barricade_version() const;
  void set_barricade_version(::calmcar::perception::Header_BarricadeVersion value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr perception_version_;
  ::google::protobuf::int64 frame_index_;
  ::google::protobuf::int64 timestamp_;
  int protobuf_version_;
  int object_version_;
  int tfl_struct_version_;
  int tfl_spot_version_;
  int traffic_sign_version_;
  int fail_safe_version_;
  int lane_version_;
  int road_mark_version_;
  int free_space_version_;
  int barricade_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class MeasuringStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.MeasuringStatus) */ {
 public:
  MeasuringStatus();
  virtual ~MeasuringStatus();

  MeasuringStatus(const MeasuringStatus& from);

  inline MeasuringStatus& operator=(const MeasuringStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasuringStatus(MeasuringStatus&& from) noexcept
    : MeasuringStatus() {
    *this = ::std::move(from);
  }

  inline MeasuringStatus& operator=(MeasuringStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasuringStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeasuringStatus* internal_default_instance() {
    return reinterpret_cast<const MeasuringStatus*>(
               &_MeasuringStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MeasuringStatus* other);
  friend void swap(MeasuringStatus& a, MeasuringStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasuringStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  MeasuringStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeasuringStatus& from);
  void MergeFrom(const MeasuringStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeasuringStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.MeasuringStatus0 measuring_status_0 = 1;
  void clear_measuring_status_0();
  static const int kMeasuringStatus0FieldNumber = 1;
  ::calmcar::perception::MeasuringStatus0 measuring_status_0() const;
  void set_measuring_status_0(::calmcar::perception::MeasuringStatus0 value);

  // .calmcar.perception.MeasuringStatus1 measuring_status_1 = 2;
  void clear_measuring_status_1();
  static const int kMeasuringStatus1FieldNumber = 2;
  ::calmcar::perception::MeasuringStatus1 measuring_status_1() const;
  void set_measuring_status_1(::calmcar::perception::MeasuringStatus1 value);

  // .calmcar.perception.MeasuringStatus2 measuring_status_2 = 3;
  void clear_measuring_status_2();
  static const int kMeasuringStatus2FieldNumber = 3;
  ::calmcar::perception::MeasuringStatus2 measuring_status_2() const;
  void set_measuring_status_2(::calmcar::perception::MeasuringStatus2 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.MeasuringStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int measuring_status_0_;
  int measuring_status_1_;
  int measuring_status_2_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsMeasuringStatusImpl();
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const PROTOBUF_FINAL { return New(NULL); }

  Object* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // string subclass_name = 8;
  void clear_subclass_name();
  static const int kSubclassNameFieldNumber = 8;
  const ::std::string& subclass_name() const;
  void set_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subclass_name(::std::string&& value);
  #endif
  void set_subclass_name(const char* value);
  void set_subclass_name(const char* value, size_t size);
  ::std::string* mutable_subclass_name();
  ::std::string* release_subclass_name();
  void set_allocated_subclass_name(::std::string* subclass_name);

  // .calmcar.perception.Rect bbox = 10;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 10;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // .calmcar.perception.MeasuringStatus measuring_status = 59;
  bool has_measuring_status() const;
  void clear_measuring_status();
  static const int kMeasuringStatusFieldNumber = 59;
  const ::calmcar::perception::MeasuringStatus& measuring_status() const;
  ::calmcar::perception::MeasuringStatus* release_measuring_status();
  ::calmcar::perception::MeasuringStatus* mutable_measuring_status();
  void set_allocated_measuring_status(::calmcar::perception::MeasuringStatus* measuring_status);

  // int64 frame_index = 1;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 class_ = 5;
  void clear_class_();
  static const int kClassFieldNumber = 5;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 3;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 3;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float confidence = 9;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 9;
  float confidence() const;
  void set_confidence(float value);

  // int64 subclass = 7;
  void clear_subclass();
  static const int kSubclassFieldNumber = 7;
  ::google::protobuf::int64 subclass() const;
  void set_subclass(::google::protobuf::int64 value);

  // float length = 11;
  void clear_length();
  static const int kLengthFieldNumber = 11;
  float length() const;
  void set_length(float value);

  // float length_std = 12;
  void clear_length_std();
  static const int kLengthStdFieldNumber = 12;
  float length_std() const;
  void set_length_std(float value);

  // float width = 13;
  void clear_width();
  static const int kWidthFieldNumber = 13;
  float width() const;
  void set_width(float value);

  // float width_std = 14;
  void clear_width_std();
  static const int kWidthStdFieldNumber = 14;
  float width_std() const;
  void set_width_std(float value);

  // float height = 15;
  void clear_height();
  static const int kHeightFieldNumber = 15;
  float height() const;
  void set_height(float value);

  // float height_std = 16;
  void clear_height_std();
  static const int kHeightStdFieldNumber = 16;
  float height_std() const;
  void set_height_std(float value);

  // int64 age_count = 17;
  void clear_age_count();
  static const int kAgeCountFieldNumber = 17;
  ::google::protobuf::int64 age_count() const;
  void set_age_count(::google::protobuf::int64 value);

  // float age_seconds = 18;
  void clear_age_seconds();
  static const int kAgeSecondsFieldNumber = 18;
  float age_seconds() const;
  void set_age_seconds(float value);

  // .calmcar.perception.VisibilitySide visibility_side = 19;
  void clear_visibility_side();
  static const int kVisibilitySideFieldNumber = 19;
  ::calmcar::perception::VisibilitySide visibility_side() const;
  void set_visibility_side(::calmcar::perception::VisibilitySide value);

  // float lat_distance = 20;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 20;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float lat_distance_std = 21;
  void clear_lat_distance_std();
  static const int kLatDistanceStdFieldNumber = 21;
  float lat_distance_std() const;
  void set_lat_distance_std(float value);

  // float long_distance = 22;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 22;
  float long_distance() const;
  void set_long_distance(float value);

  // float long_distance_std = 23;
  void clear_long_distance_std();
  static const int kLongDistanceStdFieldNumber = 23;
  float long_distance_std() const;
  void set_long_distance_std(float value);

  // float relative_lat_velocity = 24;
  void clear_relative_lat_velocity();
  static const int kRelativeLatVelocityFieldNumber = 24;
  float relative_lat_velocity() const;
  void set_relative_lat_velocity(float value);

  // float relative_lat_velocity_std = 25;
  void clear_relative_lat_velocity_std();
  static const int kRelativeLatVelocityStdFieldNumber = 25;
  float relative_lat_velocity_std() const;
  void set_relative_lat_velocity_std(float value);

  // float relative_long_velocity = 26;
  void clear_relative_long_velocity();
  static const int kRelativeLongVelocityFieldNumber = 26;
  float relative_long_velocity() const;
  void set_relative_long_velocity(float value);

  // float relative_long_velocity_std = 27;
  void clear_relative_long_velocity_std();
  static const int kRelativeLongVelocityStdFieldNumber = 27;
  float relative_long_velocity_std() const;
  void set_relative_long_velocity_std(float value);

  // float abs_lat_velocity = 28;
  void clear_abs_lat_velocity();
  static const int kAbsLatVelocityFieldNumber = 28;
  float abs_lat_velocity() const;
  void set_abs_lat_velocity(float value);

  // float abs_lat_velocity_std = 29;
  void clear_abs_lat_velocity_std();
  static const int kAbsLatVelocityStdFieldNumber = 29;
  float abs_lat_velocity_std() const;
  void set_abs_lat_velocity_std(float value);

  // float abs_long_velocity = 30;
  void clear_abs_long_velocity();
  static const int kAbsLongVelocityFieldNumber = 30;
  float abs_long_velocity() const;
  void set_abs_long_velocity(float value);

  // float abs_long_velocity_std = 31;
  void clear_abs_long_velocity_std();
  static const int kAbsLongVelocityStdFieldNumber = 31;
  float abs_long_velocity_std() const;
  void set_abs_long_velocity_std(float value);

  // float relative_lat_acc = 32;
  void clear_relative_lat_acc();
  static const int kRelativeLatAccFieldNumber = 32;
  float relative_lat_acc() const;
  void set_relative_lat_acc(float value);

  // float relative_lat_acc_std = 33;
  void clear_relative_lat_acc_std();
  static const int kRelativeLatAccStdFieldNumber = 33;
  float relative_lat_acc_std() const;
  void set_relative_lat_acc_std(float value);

  // float relative_long_acc = 34;
  void clear_relative_long_acc();
  static const int kRelativeLongAccFieldNumber = 34;
  float relative_long_acc() const;
  void set_relative_long_acc(float value);

  // float relative_long_acc_std = 35;
  void clear_relative_long_acc_std();
  static const int kRelativeLongAccStdFieldNumber = 35;
  float relative_long_acc_std() const;
  void set_relative_long_acc_std(float value);

  // float abs_lat_acc = 36;
  void clear_abs_lat_acc();
  static const int kAbsLatAccFieldNumber = 36;
  float abs_lat_acc() const;
  void set_abs_lat_acc(float value);

  // float abs_lat_acc_std = 37;
  void clear_abs_lat_acc_std();
  static const int kAbsLatAccStdFieldNumber = 37;
  float abs_lat_acc_std() const;
  void set_abs_lat_acc_std(float value);

  // float abs_long_acc = 38;
  void clear_abs_long_acc();
  static const int kAbsLongAccFieldNumber = 38;
  float abs_long_acc() const;
  void set_abs_long_acc(float value);

  // float abs_long_acc_std = 39;
  void clear_abs_long_acc_std();
  static const int kAbsLongAccStdFieldNumber = 39;
  float abs_long_acc_std() const;
  void set_abs_long_acc_std(float value);

  // float abs_speed = 40;
  void clear_abs_speed();
  static const int kAbsSpeedFieldNumber = 40;
  float abs_speed() const;
  void set_abs_speed(float value);

  // float abs_speed_std = 41;
  void clear_abs_speed_std();
  static const int kAbsSpeedStdFieldNumber = 41;
  float abs_speed_std() const;
  void set_abs_speed_std(float value);

  // float abs_acceleration = 42;
  void clear_abs_acceleration();
  static const int kAbsAccelerationFieldNumber = 42;
  float abs_acceleration() const;
  void set_abs_acceleration(float value);

  // float abs_acceleration_std = 43;
  void clear_abs_acceleration_std();
  static const int kAbsAccelerationStdFieldNumber = 43;
  float abs_acceleration_std() const;
  void set_abs_acceleration_std(float value);

  // float heading = 44;
  void clear_heading();
  static const int kHeadingFieldNumber = 44;
  float heading() const;
  void set_heading(float value);

  // float heading_std = 45;
  void clear_heading_std();
  static const int kHeadingStdFieldNumber = 45;
  float heading_std() const;
  void set_heading_std(float value);

  // float inverse_ttc = 46;
  void clear_inverse_ttc();
  static const int kInverseTtcFieldNumber = 46;
  float inverse_ttc() const;
  void set_inverse_ttc(float value);

  // float inverse_ttc_std = 47;
  void clear_inverse_ttc_std();
  static const int kInverseTtcStdFieldNumber = 47;
  float inverse_ttc_std() const;
  void set_inverse_ttc_std(float value);

  // float angle_left = 48;
  void clear_angle_left();
  static const int kAngleLeftFieldNumber = 48;
  float angle_left() const;
  void set_angle_left(float value);

  // float angle_right = 49;
  void clear_angle_right();
  static const int kAngleRightFieldNumber = 49;
  float angle_right() const;
  void set_angle_right(float value);

  // float angle_rate = 50;
  void clear_angle_rate();
  static const int kAngleRateFieldNumber = 50;
  float angle_rate() const;
  void set_angle_rate(float value);

  // float angle_side = 51;
  void clear_angle_side();
  static const int kAngleSideFieldNumber = 51;
  float angle_side() const;
  void set_angle_side(float value);

  // bool top_out_of_image = 52;
  void clear_top_out_of_image();
  static const int kTopOutOfImageFieldNumber = 52;
  bool top_out_of_image() const;
  void set_top_out_of_image(bool value);

  // bool bottom_out_of_image = 53;
  void clear_bottom_out_of_image();
  static const int kBottomOutOfImageFieldNumber = 53;
  bool bottom_out_of_image() const;
  void set_bottom_out_of_image(bool value);

  // bool left_out_of_image = 54;
  void clear_left_out_of_image();
  static const int kLeftOutOfImageFieldNumber = 54;
  bool left_out_of_image() const;
  void set_left_out_of_image(bool value);

  // bool right_out_of_image = 55;
  void clear_right_out_of_image();
  static const int kRightOutOfImageFieldNumber = 55;
  bool right_out_of_image() const;
  void set_right_out_of_image(bool value);

  // bool brake_light = 56;
  void clear_brake_light();
  static const int kBrakeLightFieldNumber = 56;
  bool brake_light() const;
  void set_brake_light(bool value);

  // bool turn_indicator_left = 57;
  void clear_turn_indicator_left();
  static const int kTurnIndicatorLeftFieldNumber = 57;
  bool turn_indicator_left() const;
  void set_turn_indicator_left(bool value);

  // bool turn_indicator_right = 58;
  void clear_turn_indicator_right();
  static const int kTurnIndicatorRightFieldNumber = 58;
  bool turn_indicator_right() const;
  void set_turn_indicator_right(bool value);

  // bool lane_assignment_v = 65;
  void clear_lane_assignment_v();
  static const int kLaneAssignmentVFieldNumber = 65;
  bool lane_assignment_v() const;
  void set_lane_assignment_v(bool value);

  // .calmcar.perception.MotionOrientation motion_orientation = 60;
  void clear_motion_orientation();
  static const int kMotionOrientationFieldNumber = 60;
  ::calmcar::perception::MotionOrientation motion_orientation() const;
  void set_motion_orientation(::calmcar::perception::MotionOrientation value);

  // .calmcar.perception.MotionCategory motion_category = 61;
  void clear_motion_category();
  static const int kMotionCategoryFieldNumber = 61;
  ::calmcar::perception::MotionCategory motion_category() const;
  void set_motion_category(::calmcar::perception::MotionCategory value);

  // .calmcar.perception.MotionStatusV2 motion_status = 62;
  void clear_motion_status();
  static const int kMotionStatusFieldNumber = 62;
  ::calmcar::perception::MotionStatusV2 motion_status() const;
  void set_motion_status(::calmcar::perception::MotionStatusV2 value);

  // .calmcar.perception.CutInCutOut cutin_cutout = 63;
  void clear_cutin_cutout();
  static const int kCutinCutoutFieldNumber = 63;
  ::calmcar::perception::CutInCutOut cutin_cutout() const;
  void set_cutin_cutout(::calmcar::perception::CutInCutOut value);

  // int32 lane_assignment = 64;
  void clear_lane_assignment();
  static const int kLaneAssignmentFieldNumber = 64;
  ::google::protobuf::int32 lane_assignment() const;
  void set_lane_assignment(::google::protobuf::int32 value);

  // bool is_bev_object = 66;
  void clear_is_bev_object();
  static const int kIsBevObjectFieldNumber = 66;
  bool is_bev_object() const;
  void set_is_bev_object(bool value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::internal::ArenaStringPtr subclass_name_;
  ::calmcar::perception::Rect* bbox_;
  ::calmcar::perception::MeasuringStatus* measuring_status_;
  ::google::protobuf::int64 frame_index_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 class__;
  int camera_position_;
  float confidence_;
  ::google::protobuf::int64 subclass_;
  float length_;
  float length_std_;
  float width_;
  float width_std_;
  float height_;
  float height_std_;
  ::google::protobuf::int64 age_count_;
  float age_seconds_;
  int visibility_side_;
  float lat_distance_;
  float lat_distance_std_;
  float long_distance_;
  float long_distance_std_;
  float relative_lat_velocity_;
  float relative_lat_velocity_std_;
  float relative_long_velocity_;
  float relative_long_velocity_std_;
  float abs_lat_velocity_;
  float abs_lat_velocity_std_;
  float abs_long_velocity_;
  float abs_long_velocity_std_;
  float relative_lat_acc_;
  float relative_lat_acc_std_;
  float relative_long_acc_;
  float relative_long_acc_std_;
  float abs_lat_acc_;
  float abs_lat_acc_std_;
  float abs_long_acc_;
  float abs_long_acc_std_;
  float abs_speed_;
  float abs_speed_std_;
  float abs_acceleration_;
  float abs_acceleration_std_;
  float heading_;
  float heading_std_;
  float inverse_ttc_;
  float inverse_ttc_std_;
  float angle_left_;
  float angle_right_;
  float angle_rate_;
  float angle_side_;
  bool top_out_of_image_;
  bool bottom_out_of_image_;
  bool left_out_of_image_;
  bool right_out_of_image_;
  bool brake_light_;
  bool turn_indicator_left_;
  bool turn_indicator_right_;
  bool lane_assignment_v_;
  int motion_orientation_;
  int motion_category_;
  int motion_status_;
  int cutin_cutout_;
  ::google::protobuf::int32 lane_assignment_;
  bool is_bev_object_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsObjectImpl();
};
// -------------------------------------------------------------------

class TrafficLightSpot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficLightSpot) */ {
 public:
  TrafficLightSpot();
  virtual ~TrafficLightSpot();

  TrafficLightSpot(const TrafficLightSpot& from);

  inline TrafficLightSpot& operator=(const TrafficLightSpot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightSpot(TrafficLightSpot&& from) noexcept
    : TrafficLightSpot() {
    *this = ::std::move(from);
  }

  inline TrafficLightSpot& operator=(TrafficLightSpot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightSpot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightSpot* internal_default_instance() {
    return reinterpret_cast<const TrafficLightSpot*>(
               &_TrafficLightSpot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TrafficLightSpot* other);
  friend void swap(TrafficLightSpot& a, TrafficLightSpot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightSpot* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightSpot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightSpot& from);
  void MergeFrom(const TrafficLightSpot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightSpot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLightSpot_Color Color;
  static const Color COLOR_UNKNOWN =
    TrafficLightSpot_Color_COLOR_UNKNOWN;
  static const Color COLOR_GREEN =
    TrafficLightSpot_Color_COLOR_GREEN;
  static const Color COLOR_RED =
    TrafficLightSpot_Color_COLOR_RED;
  static const Color COLOR_YELLOW =
    TrafficLightSpot_Color_COLOR_YELLOW;
  static inline bool Color_IsValid(int value) {
    return TrafficLightSpot_Color_IsValid(value);
  }
  static const Color Color_MIN =
    TrafficLightSpot_Color_Color_MIN;
  static const Color Color_MAX =
    TrafficLightSpot_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    TrafficLightSpot_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return TrafficLightSpot_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return TrafficLightSpot_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return TrafficLightSpot_Color_Parse(name, value);
  }

  typedef TrafficLightSpot_Type Type;
  static const Type TYPE_UNKNOWN =
    TrafficLightSpot_Type_TYPE_UNKNOWN;
  static const Type TYPE_ARROW_STRAIGHT =
    TrafficLightSpot_Type_TYPE_ARROW_STRAIGHT;
  static const Type TYPE_ARROW_LEFT =
    TrafficLightSpot_Type_TYPE_ARROW_LEFT;
  static const Type TYPE_ARROW_RIGHT =
    TrafficLightSpot_Type_TYPE_ARROW_RIGHT;
  static const Type TYPE_ARROW_UTURN =
    TrafficLightSpot_Type_TYPE_ARROW_UTURN;
  static const Type TYPE_CIRCLE =
    TrafficLightSpot_Type_TYPE_CIRCLE;
  static const Type TYPE_NUM =
    TrafficLightSpot_Type_TYPE_NUM;
  static inline bool Type_IsValid(int value) {
    return TrafficLightSpot_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficLightSpot_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficLightSpot_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficLightSpot_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficLightSpot_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficLightSpot_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficLightSpot_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .calmcar.perception.Rect bbox = 5;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 5;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // .calmcar.perception.TrafficLightSpot.Color color = 1;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::calmcar::perception::TrafficLightSpot_Color color() const;
  void set_color(::calmcar::perception::TrafficLightSpot_Color value);

  // float color_confidence = 2;
  void clear_color_confidence();
  static const int kColorConfidenceFieldNumber = 2;
  float color_confidence() const;
  void set_color_confidence(float value);

  // .calmcar.perception.TrafficLightSpot.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::calmcar::perception::TrafficLightSpot_Type type() const;
  void set_type(::calmcar::perception::TrafficLightSpot_Type value);

  // float dir_confidence = 4;
  void clear_dir_confidence();
  static const int kDirConfidenceFieldNumber = 4;
  float dir_confidence() const;
  void set_dir_confidence(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficLightSpot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::Rect* bbox_;
  int color_;
  float color_confidence_;
  int type_;
  float dir_confidence_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsTrafficLightSpotImpl();
};
// -------------------------------------------------------------------

class TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficLight) */ {
 public:
  TrafficLight();
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLight(TrafficLight&& from) noexcept
    : TrafficLight() {
    *this = ::std::move(from);
  }

  inline TrafficLight& operator=(TrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TrafficLight* other);
  friend void swap(TrafficLight& a, TrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficLight_Color Color;
  static const Color COLOR_UNKNOWN =
    TrafficLight_Color_COLOR_UNKNOWN;
  static const Color COLOR_GREEN =
    TrafficLight_Color_COLOR_GREEN;
  static const Color COLOR_RED =
    TrafficLight_Color_COLOR_RED;
  static const Color COLOR_YELLOW =
    TrafficLight_Color_COLOR_YELLOW;
  static inline bool Color_IsValid(int value) {
    return TrafficLight_Color_IsValid(value);
  }
  static const Color Color_MIN =
    TrafficLight_Color_Color_MIN;
  static const Color Color_MAX =
    TrafficLight_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    TrafficLight_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return TrafficLight_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return TrafficLight_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return TrafficLight_Color_Parse(name, value);
  }

  typedef TrafficLight_Type Type;
  static const Type TYPE_UNKNOWN =
    TrafficLight_Type_TYPE_UNKNOWN;
  static const Type TYPE_ARROW_STRAIGHT =
    TrafficLight_Type_TYPE_ARROW_STRAIGHT;
  static const Type TYPE_ARROW_LEFT =
    TrafficLight_Type_TYPE_ARROW_LEFT;
  static const Type TYPE_ARROW_RIGHT =
    TrafficLight_Type_TYPE_ARROW_RIGHT;
  static const Type TYPE_ARROW_UTURN =
    TrafficLight_Type_TYPE_ARROW_UTURN;
  static const Type TYPE_CIRCLE =
    TrafficLight_Type_TYPE_CIRCLE;
  static const Type TYPE_NUM =
    TrafficLight_Type_TYPE_NUM;
  static inline bool Type_IsValid(int value) {
    return TrafficLight_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficLight_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficLight_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficLight_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficLight_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficLight_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficLight_Type_Parse(name, value);
  }

  typedef TrafficLight_Mode Mode;
  static const Mode NO_BRIGHT =
    TrafficLight_Mode_NO_BRIGHT;
  static const Mode ALWAYS_BRIGHT =
    TrafficLight_Mode_ALWAYS_BRIGHT;
  static const Mode FLASH =
    TrafficLight_Mode_FLASH;
  static inline bool Mode_IsValid(int value) {
    return TrafficLight_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    TrafficLight_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    TrafficLight_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    TrafficLight_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return TrafficLight_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return TrafficLight_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return TrafficLight_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.TrafficLightSpot spots = 22;
  int spots_size() const;
  void clear_spots();
  static const int kSpotsFieldNumber = 22;
  const ::calmcar::perception::TrafficLightSpot& spots(int index) const;
  ::calmcar::perception::TrafficLightSpot* mutable_spots(int index);
  ::calmcar::perception::TrafficLightSpot* add_spots();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLightSpot >*
      mutable_spots();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLightSpot >&
      spots() const;

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // .calmcar.perception.Rect bbox = 8;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 8;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 struct_id = 3;
  void clear_struct_id();
  static const int kStructIdFieldNumber = 3;
  ::google::protobuf::int64 struct_id() const;
  void set_struct_id(::google::protobuf::int64 value);

  // int64 spot_id = 4;
  void clear_spot_id();
  static const int kSpotIdFieldNumber = 4;
  ::google::protobuf::int64 spot_id() const;
  void set_spot_id(::google::protobuf::int64 value);

  // int64 class_ = 5;
  void clear_class_();
  static const int kClassFieldNumber = 5;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  float height() const;
  void set_height(float value);

  // int64 tracking_age = 7;
  void clear_tracking_age();
  static const int kTrackingAgeFieldNumber = 7;
  ::google::protobuf::int64 tracking_age() const;
  void set_tracking_age(::google::protobuf::int64 value);

  // float width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  float width() const;
  void set_width(float value);

  // float lat_distance = 11;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 11;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float lat_distance_std = 12;
  void clear_lat_distance_std();
  static const int kLatDistanceStdFieldNumber = 12;
  float lat_distance_std() const;
  void set_lat_distance_std(float value);

  // float long_distance = 13;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 13;
  float long_distance() const;
  void set_long_distance(float value);

  // float long_distance_std = 14;
  void clear_long_distance_std();
  static const int kLongDistanceStdFieldNumber = 14;
  float long_distance_std() const;
  void set_long_distance_std(float value);

  // float rel_height = 15;
  void clear_rel_height();
  static const int kRelHeightFieldNumber = 15;
  float rel_height() const;
  void set_rel_height(float value);

  // float rel_height_std = 16;
  void clear_rel_height_std();
  static const int kRelHeightStdFieldNumber = 16;
  float rel_height_std() const;
  void set_rel_height_std(float value);

  // .calmcar.perception.TrafficLight.Color color = 17;
  void clear_color();
  static const int kColorFieldNumber = 17;
  ::calmcar::perception::TrafficLight_Color color() const;
  void set_color(::calmcar::perception::TrafficLight_Color value);

  // float color_confidence = 18;
  void clear_color_confidence();
  static const int kColorConfidenceFieldNumber = 18;
  float color_confidence() const;
  void set_color_confidence(float value);

  // .calmcar.perception.TrafficLight.Type type = 19;
  void clear_type();
  static const int kTypeFieldNumber = 19;
  ::calmcar::perception::TrafficLight_Type type() const;
  void set_type(::calmcar::perception::TrafficLight_Type value);

  // float type_confidence = 20;
  void clear_type_confidence();
  static const int kTypeConfidenceFieldNumber = 20;
  float type_confidence() const;
  void set_type_confidence(float value);

  // .calmcar.perception.TrafficLight.Mode mode = 21;
  void clear_mode();
  static const int kModeFieldNumber = 21;
  ::calmcar::perception::TrafficLight_Mode mode() const;
  void set_mode(::calmcar::perception::TrafficLight_Mode value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLightSpot > spots_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 struct_id_;
  ::google::protobuf::int64 spot_id_;
  ::google::protobuf::int64 class__;
  int camera_position_;
  float height_;
  ::google::protobuf::int64 tracking_age_;
  float width_;
  float lat_distance_;
  float lat_distance_std_;
  float long_distance_;
  float long_distance_std_;
  float rel_height_;
  float rel_height_std_;
  int color_;
  float color_confidence_;
  int type_;
  float type_confidence_;
  int mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsTrafficLightImpl();
};
// -------------------------------------------------------------------

class TrafficSign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSign) */ {
 public:
  TrafficSign();
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TrafficSign* other);
  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficSign* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficSign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficSign_TrafficSIgnRelevancy TrafficSIgnRelevancy;
  static const TrafficSIgnRelevancy Unknow =
    TrafficSign_TrafficSIgnRelevancy_Unknow;
  static const TrafficSIgnRelevancy RELEVANT =
    TrafficSign_TrafficSIgnRelevancy_RELEVANT;
  static const TrafficSIgnRelevancy UNRELEVANT =
    TrafficSign_TrafficSIgnRelevancy_UNRELEVANT;
  static inline bool TrafficSIgnRelevancy_IsValid(int value) {
    return TrafficSign_TrafficSIgnRelevancy_IsValid(value);
  }
  static const TrafficSIgnRelevancy TrafficSIgnRelevancy_MIN =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MIN;
  static const TrafficSIgnRelevancy TrafficSIgnRelevancy_MAX =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX;
  static const int TrafficSIgnRelevancy_ARRAYSIZE =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSIgnRelevancy_descriptor() {
    return TrafficSign_TrafficSIgnRelevancy_descriptor();
  }
  static inline const ::std::string& TrafficSIgnRelevancy_Name(TrafficSIgnRelevancy value) {
    return TrafficSign_TrafficSIgnRelevancy_Name(value);
  }
  static inline bool TrafficSIgnRelevancy_Parse(const ::std::string& name,
      TrafficSIgnRelevancy* value) {
    return TrafficSign_TrafficSIgnRelevancy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // string subclass_name = 7;
  void clear_subclass_name();
  static const int kSubclassNameFieldNumber = 7;
  const ::std::string& subclass_name() const;
  void set_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subclass_name(::std::string&& value);
  #endif
  void set_subclass_name(const char* value);
  void set_subclass_name(const char* value, size_t size);
  ::std::string* mutable_subclass_name();
  ::std::string* release_subclass_name();
  void set_allocated_subclass_name(::std::string* subclass_name);

  // .calmcar.perception.Rect bbox = 8;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 8;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 class_ = 4;
  void clear_class_();
  static const int kClassFieldNumber = 4;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // int64 subclass = 5;
  void clear_subclass();
  static const int kSubclassFieldNumber = 5;
  ::google::protobuf::int64 subclass() const;
  void set_subclass(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  float height() const;
  void set_height(float value);

  // float width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  float width() const;
  void set_width(float value);

  // float lat_distance = 11;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 11;
  float lat_distance() const;
  void set_lat_distance(float value);

  // int64 tracking_age = 13;
  void clear_tracking_age();
  static const int kTrackingAgeFieldNumber = 13;
  ::google::protobuf::int64 tracking_age() const;
  void set_tracking_age(::google::protobuf::int64 value);

  // float long_distance = 12;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 12;
  float long_distance() const;
  void set_long_distance(float value);

  // .calmcar.perception.TrafficSign.TrafficSIgnRelevancy relevance = 14;
  void clear_relevance();
  static const int kRelevanceFieldNumber = 14;
  ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy relevance() const;
  void set_relevance(::calmcar::perception::TrafficSign_TrafficSIgnRelevancy value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::internal::ArenaStringPtr subclass_name_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 class__;
  ::google::protobuf::int64 subclass_;
  int camera_position_;
  float height_;
  float width_;
  float lat_distance_;
  ::google::protobuf::int64 tracking_age_;
  float long_distance_;
  int relevance_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsTrafficSignImpl();
};
// -------------------------------------------------------------------

class TrafficSignType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSignType) */ {
 public:
  TrafficSignType();
  virtual ~TrafficSignType();

  TrafficSignType(const TrafficSignType& from);

  inline TrafficSignType& operator=(const TrafficSignType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignType(TrafficSignType&& from) noexcept
    : TrafficSignType() {
    *this = ::std::move(from);
  }

  inline TrafficSignType& operator=(TrafficSignType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignType* internal_default_instance() {
    return reinterpret_cast<const TrafficSignType*>(
               &_TrafficSignType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TrafficSignType* other);
  friend void swap(TrafficSignType& a, TrafficSignType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignType* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficSignType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficSignType& from);
  void MergeFrom(const TrafficSignType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficSignType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrafficSignType_Type Type;
  static const Type UNKNOWN =
    TrafficSignType_Type_UNKNOWN;
  static const Type WARNING =
    TrafficSignType_Type_WARNING;
  static const Type PROHIBIT =
    TrafficSignType_Type_PROHIBIT;
  static const Type SUPPLEMENT =
    TrafficSignType_Type_SUPPLEMENT;
  static inline bool Type_IsValid(int value) {
    return TrafficSignType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSignType_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSignType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSignType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSignType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSignType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSignType_Type_Parse(name, value);
  }

  typedef TrafficSignType_ProhibitionSign ProhibitionSign;
  static const ProhibitionSign SPEED_LIMIT5 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT5;
  static const ProhibitionSign SPEED_LIMIT10 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT10;
  static const ProhibitionSign SPEED_LIMIT15 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT15;
  static const ProhibitionSign SPEED_LIMIT20 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT20;
  static const ProhibitionSign SPEED_LIMIT30 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT30;
  static const ProhibitionSign SPEED_LIMIT35 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT35;
  static const ProhibitionSign SPEED_LIMIT40 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT40;
  static const ProhibitionSign SPEED_LIMIT50 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT50;
  static const ProhibitionSign SPEED_LIMIT60 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT60;
  static const ProhibitionSign SPEED_LIMIT70 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT70;
  static const ProhibitionSign SPEED_LIMIT80 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT80;
  static const ProhibitionSign SPEED_LIMIT90 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT90;
  static const ProhibitionSign SPEED_LIMIT100 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT100;
  static const ProhibitionSign SPEED_LIMIT110 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT110;
  static const ProhibitionSign SPEED_LIMIT120 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT120;
  static const ProhibitionSign STOP =
    TrafficSignType_ProhibitionSign_STOP;
  static const ProhibitionSign YIELD =
    TrafficSignType_ProhibitionSign_YIELD;
  static const ProhibitionSign NO_ENTRY =
    TrafficSignType_ProhibitionSign_NO_ENTRY;
  static const ProhibitionSign DONOT_ENTER =
    TrafficSignType_ProhibitionSign_DONOT_ENTER;
  static const ProhibitionSign NO_MOTOR_VEHICLES =
    TrafficSignType_ProhibitionSign_NO_MOTOR_VEHICLES;
  static const ProhibitionSign NO_TRUCKS =
    TrafficSignType_ProhibitionSign_NO_TRUCKS;
  static const ProhibitionSign NO_LARGE_BUESE =
    TrafficSignType_ProhibitionSign_NO_LARGE_BUESE;
  static const ProhibitionSign NO_MOTORCYCLES =
    TrafficSignType_ProhibitionSign_NO_MOTORCYCLES;
  static const ProhibitionSign ONLY_MOTOR_VEHICLES =
    TrafficSignType_ProhibitionSign_ONLY_MOTOR_VEHICLES;
  static const ProhibitionSign NO_PEDESTRIANS =
    TrafficSignType_ProhibitionSign_NO_PEDESTRIANS;
  static const ProhibitionSign NO_LEFT_TURN =
    TrafficSignType_ProhibitionSign_NO_LEFT_TURN;
  static const ProhibitionSign NO_RIGHT_TURN =
    TrafficSignType_ProhibitionSign_NO_RIGHT_TURN;
  static const ProhibitionSign NO_U_TURN =
    TrafficSignType_ProhibitionSign_NO_U_TURN;
  static const ProhibitionSign NO_OVERTAKING =
    TrafficSignType_ProhibitionSign_NO_OVERTAKING;
  static const ProhibitionSign NO_STOPPING =
    TrafficSignType_ProhibitionSign_NO_STOPPING;
  static const ProhibitionSign NO_HONKING =
    TrafficSignType_ProhibitionSign_NO_HONKING;
  static const ProhibitionSign MAX_CLEARANCE =
    TrafficSignType_ProhibitionSign_MAX_CLEARANCE;
  static const ProhibitionSign WEIGHT_LIMIT =
    TrafficSignType_ProhibitionSign_WEIGHT_LIMIT;
  static const ProhibitionSign AXLE_WEIGHT_LIMIT =
    TrafficSignType_ProhibitionSign_AXLE_WEIGHT_LIMIT;
  static const ProhibitionSign SPEED_LIMIT_END =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT_END;
  static const ProhibitionSign NO_MINIBUSES =
    TrafficSignType_ProhibitionSign_NO_MINIBUSES;
  static const ProhibitionSign NO_TRACTOR =
    TrafficSignType_ProhibitionSign_NO_TRACTOR;
  static const ProhibitionSign NO_STRAIGHT =
    TrafficSignType_ProhibitionSign_NO_STRAIGHT;
  static const ProhibitionSign NO_LEFT_RIGHT_TURN =
    TrafficSignType_ProhibitionSign_NO_LEFT_RIGHT_TURN;
  static const ProhibitionSign NO_OVERTAKING_END =
    TrafficSignType_ProhibitionSign_NO_OVERTAKING_END;
  static const ProhibitionSign MAX_WIDTH =
    TrafficSignType_ProhibitionSign_MAX_WIDTH;
  static const ProhibitionSign HAZARDOUS_VEHICLES =
    TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES;
  static inline bool ProhibitionSign_IsValid(int value) {
    return TrafficSignType_ProhibitionSign_IsValid(value);
  }
  static const ProhibitionSign ProhibitionSign_MIN =
    TrafficSignType_ProhibitionSign_ProhibitionSign_MIN;
  static const ProhibitionSign ProhibitionSign_MAX =
    TrafficSignType_ProhibitionSign_ProhibitionSign_MAX;
  static const int ProhibitionSign_ARRAYSIZE =
    TrafficSignType_ProhibitionSign_ProhibitionSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProhibitionSign_descriptor() {
    return TrafficSignType_ProhibitionSign_descriptor();
  }
  static inline const ::std::string& ProhibitionSign_Name(ProhibitionSign value) {
    return TrafficSignType_ProhibitionSign_Name(value);
  }
  static inline bool ProhibitionSign_Parse(const ::std::string& name,
      ProhibitionSign* value) {
    return TrafficSignType_ProhibitionSign_Parse(name, value);
  }

  typedef TrafficSignType_WarningSign WarningSign;
  static const WarningSign CROSSROADS =
    TrafficSignType_WarningSign_CROSSROADS;
  static const WarningSign SHARP_CURVE =
    TrafficSignType_WarningSign_SHARP_CURVE;
  static const WarningSign REVERSE_CURVE =
    TrafficSignType_WarningSign_REVERSE_CURVE;
  static const WarningSign WINDING_CURVES =
    TrafficSignType_WarningSign_WINDING_CURVES;
  static const WarningSign STEEP_DESCENT =
    TrafficSignType_WarningSign_STEEP_DESCENT;
  static const WarningSign NARROW_ROAD =
    TrafficSignType_WarningSign_NARROW_ROAD;
  static const WarningSign NARROW_BRIDGE =
    TrafficSignType_WarningSign_NARROW_BRIDGE;
  static const WarningSign TWO_WAY_TRAFFIC =
    TrafficSignType_WarningSign_TWO_WAY_TRAFFIC;
  static const WarningSign WATCH_PEDESTRIANS =
    TrafficSignType_WarningSign_WATCH_PEDESTRIANS;
  static const WarningSign WATCH_CHILDREN =
    TrafficSignType_WarningSign_WATCH_CHILDREN;
  static const WarningSign TRAFFIC_LIGHTS =
    TrafficSignType_WarningSign_TRAFFIC_LIGHTS;
  static const WarningSign FALING_ROCKS =
    TrafficSignType_WarningSign_FALING_ROCKS;
  static const WarningSign CROSSWIND =
    TrafficSignType_WarningSign_CROSSWIND;
  static const WarningSign SLIPPERY_SURFACE =
    TrafficSignType_WarningSign_SLIPPERY_SURFACE;
  static const WarningSign STEEP_MOUNTAIN_ROAD =
    TrafficSignType_WarningSign_STEEP_MOUNTAIN_ROAD;
  static const WarningSign EMBANKMENT_ROAD =
    TrafficSignType_WarningSign_EMBANKMENT_ROAD;
  static const WarningSign VILLAGE =
    TrafficSignType_WarningSign_VILLAGE;
  static const WarningSign TUNNEL =
    TrafficSignType_WarningSign_TUNNEL;
  static const WarningSign HUMP_BACK_BRIDGE =
    TrafficSignType_WarningSign_HUMP_BACK_BRIDGE;
  static const WarningSign BUMPY_ROAD =
    TrafficSignType_WarningSign_BUMPY_ROAD;
  static const WarningSign GUARDED_RAILWAY_CROSSING =
    TrafficSignType_WarningSign_GUARDED_RAILWAY_CROSSING;
  static const WarningSign UNGUARDED_RAILWAY_CROSSING =
    TrafficSignType_WarningSign_UNGUARDED_RAILWAY_CROSSING;
  static const WarningSign NON_MOTOR_VEHICLES =
    TrafficSignType_WarningSign_NON_MOTOR_VEHICLES;
  static const WarningSign ACCIDENT_BLACK_SPOT =
    TrafficSignType_WarningSign_ACCIDENT_BLACK_SPOT;
  static const WarningSign SLOW_DOWN =
    TrafficSignType_WarningSign_SLOW_DOWN;
  static const WarningSign OBSTACLES =
    TrafficSignType_WarningSign_OBSTACLES;
  static const WarningSign CAUTION_DRIVE =
    TrafficSignType_WarningSign_CAUTION_DRIVE;
  static const WarningSign ROAD_WORK =
    TrafficSignType_WarningSign_ROAD_WORK;
  static const WarningSign SUGGESTED_SPEED =
    TrafficSignType_WarningSign_SUGGESTED_SPEED;
  static const WarningSign REVERSIBLE_LANE =
    TrafficSignType_WarningSign_REVERSIBLE_LANE;
  static const WarningSign ROADS_MERGE =
    TrafficSignType_WarningSign_ROADS_MERGE;
  static const WarningSign ICY_ROAD =
    TrafficSignType_WarningSign_ICY_ROAD;
  static const WarningSign QUEUES_LIKELY =
    TrafficSignType_WarningSign_QUEUES_LIKELY;
  static inline bool WarningSign_IsValid(int value) {
    return TrafficSignType_WarningSign_IsValid(value);
  }
  static const WarningSign WarningSign_MIN =
    TrafficSignType_WarningSign_WarningSign_MIN;
  static const WarningSign WarningSign_MAX =
    TrafficSignType_WarningSign_WarningSign_MAX;
  static const int WarningSign_ARRAYSIZE =
    TrafficSignType_WarningSign_WarningSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WarningSign_descriptor() {
    return TrafficSignType_WarningSign_descriptor();
  }
  static inline const ::std::string& WarningSign_Name(WarningSign value) {
    return TrafficSignType_WarningSign_Name(value);
  }
  static inline bool WarningSign_Parse(const ::std::string& name,
      WarningSign* value) {
    return TrafficSignType_WarningSign_Parse(name, value);
  }

  typedef TrafficSignType_SupplementSign SupplementSign;
  static const SupplementSign Time_Limit =
    TrafficSignType_SupplementSign_Time_Limit;
  static const SupplementSign Motor_Vehicles =
    TrafficSignType_SupplementSign_Motor_Vehicles;
  static const SupplementSign Trucks =
    TrafficSignType_SupplementSign_Trucks;
  static const SupplementSign Arrow_Straight =
    TrafficSignType_SupplementSign_Arrow_Straight;
  static const SupplementSign Distance_In =
    TrafficSignType_SupplementSign_Distance_In;
  static const SupplementSign School =
    TrafficSignType_SupplementSign_School;
  static const SupplementSign Ramp =
    TrafficSignType_SupplementSign_Ramp;
  static const SupplementSign Minbuses =
    TrafficSignType_SupplementSign_Minbuses;
  static const SupplementSign Arrow_Left =
    TrafficSignType_SupplementSign_Arrow_Left;
  static const SupplementSign Arrow_Right =
    TrafficSignType_SupplementSign_Arrow_Right;
  static const SupplementSign BendArrow_Left =
    TrafficSignType_SupplementSign_BendArrow_Left;
  static const SupplementSign BendArrow_Right =
    TrafficSignType_SupplementSign_BendArrow_Right;
  static const SupplementSign Arrow_Twoway =
    TrafficSignType_SupplementSign_Arrow_Twoway;
  static inline bool SupplementSign_IsValid(int value) {
    return TrafficSignType_SupplementSign_IsValid(value);
  }
  static const SupplementSign SupplementSign_MIN =
    TrafficSignType_SupplementSign_SupplementSign_MIN;
  static const SupplementSign SupplementSign_MAX =
    TrafficSignType_SupplementSign_SupplementSign_MAX;
  static const int SupplementSign_ARRAYSIZE =
    TrafficSignType_SupplementSign_SupplementSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SupplementSign_descriptor() {
    return TrafficSignType_SupplementSign_descriptor();
  }
  static inline const ::std::string& SupplementSign_Name(SupplementSign value) {
    return TrafficSignType_SupplementSign_Name(value);
  }
  static inline bool SupplementSign_Parse(const ::std::string& name,
      SupplementSign* value) {
    return TrafficSignType_SupplementSign_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value sign = 2;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 2;
  const ::google::protobuf::Int32Value& sign() const;
  ::google::protobuf::Int32Value* release_sign();
  ::google::protobuf::Int32Value* mutable_sign();
  void set_allocated_sign(::google::protobuf::Int32Value* sign);

  // .calmcar.perception.TrafficSignType.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::calmcar::perception::TrafficSignType_Type type() const;
  void set_type(::calmcar::perception::TrafficSignType_Type value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSignType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* sign_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsTrafficSignTypeImpl();
};
// -------------------------------------------------------------------

class TrafficSignStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSignStatus) */ {
 public:
  TrafficSignStatus();
  virtual ~TrafficSignStatus();

  TrafficSignStatus(const TrafficSignStatus& from);

  inline TrafficSignStatus& operator=(const TrafficSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignStatus(TrafficSignStatus&& from) noexcept
    : TrafficSignStatus() {
    *this = ::std::move(from);
  }

  inline TrafficSignStatus& operator=(TrafficSignStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignStatus* internal_default_instance() {
    return reinterpret_cast<const TrafficSignStatus*>(
               &_TrafficSignStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TrafficSignStatus* other);
  friend void swap(TrafficSignStatus& a, TrafficSignStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficSignStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficSignStatus& from);
  void MergeFrom(const TrafficSignStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficSignStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.TrafficSignType derived_signs = 2;
  int derived_signs_size() const;
  void clear_derived_signs();
  static const int kDerivedSignsFieldNumber = 2;
  const ::calmcar::perception::TrafficSignType& derived_signs(int index) const;
  ::calmcar::perception::TrafficSignType* mutable_derived_signs(int index);
  ::calmcar::perception::TrafficSignType* add_derived_signs();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >*
      mutable_derived_signs();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >&
      derived_signs() const;

  // .calmcar.perception.TrafficSignType sign = 1;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 1;
  const ::calmcar::perception::TrafficSignType& sign() const;
  ::calmcar::perception::TrafficSignType* release_sign();
  ::calmcar::perception::TrafficSignType* mutable_sign();
  void set_allocated_sign(::calmcar::perception::TrafficSignType* sign);

  // .calmcar.perception.Rect bbox = 3;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 3;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // .google.protobuf.FloatValue speed_limit = 9;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 9;
  const ::google::protobuf::FloatValue& speed_limit() const;
  ::google::protobuf::FloatValue* release_speed_limit();
  ::google::protobuf::FloatValue* mutable_speed_limit();
  void set_allocated_speed_limit(::google::protobuf::FloatValue* speed_limit);

  // .google.protobuf.FloatValue height_limit = 10;
  bool has_height_limit() const;
  void clear_height_limit();
  static const int kHeightLimitFieldNumber = 10;
  const ::google::protobuf::FloatValue& height_limit() const;
  ::google::protobuf::FloatValue* release_height_limit();
  ::google::protobuf::FloatValue* mutable_height_limit();
  void set_allocated_height_limit(::google::protobuf::FloatValue* height_limit);

  // .google.protobuf.FloatValue weight_limit = 11;
  bool has_weight_limit() const;
  void clear_weight_limit();
  static const int kWeightLimitFieldNumber = 11;
  const ::google::protobuf::FloatValue& weight_limit() const;
  ::google::protobuf::FloatValue* release_weight_limit();
  ::google::protobuf::FloatValue* mutable_weight_limit();
  void set_allocated_weight_limit(::google::protobuf::FloatValue* weight_limit);

  // float lat_distance = 4;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 4;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float long_distance = 5;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 5;
  float long_distance() const;
  void set_long_distance(float value);

  // float panel_width = 6;
  void clear_panel_width();
  static const int kPanelWidthFieldNumber = 6;
  float panel_width() const;
  void set_panel_width(float value);

  // float panel_height = 7;
  void clear_panel_height();
  static const int kPanelHeightFieldNumber = 7;
  float panel_height() const;
  void set_panel_height(float value);

  // float height = 8;
  void clear_height();
  static const int kHeightFieldNumber = 8;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSignStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType > derived_signs_;
  ::calmcar::perception::TrafficSignType* sign_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::FloatValue* speed_limit_;
  ::google::protobuf::FloatValue* height_limit_;
  ::google::protobuf::FloatValue* weight_limit_;
  float lat_distance_;
  float long_distance_;
  float panel_width_;
  float panel_height_;
  float height_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsTrafficSignStatusImpl();
};
// -------------------------------------------------------------------

class AebObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.AebObject) */ {
 public:
  AebObject();
  virtual ~AebObject();

  AebObject(const AebObject& from);

  inline AebObject& operator=(const AebObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AebObject(AebObject&& from) noexcept
    : AebObject() {
    *this = ::std::move(from);
  }

  inline AebObject& operator=(AebObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AebObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AebObject* internal_default_instance() {
    return reinterpret_cast<const AebObject*>(
               &_AebObject_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AebObject* other);
  friend void swap(AebObject& a, AebObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AebObject* New() const PROTOBUF_FINAL { return New(NULL); }

  AebObject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AebObject& from);
  void MergeFrom(const AebObject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AebObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float last_1s_x = 10;
  int last_1s_x_size() const;
  void clear_last_1s_x();
  static const int kLast1SXFieldNumber = 10;
  float last_1s_x(int index) const;
  void set_last_1s_x(int index, float value);
  void add_last_1s_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      last_1s_x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_last_1s_x();

  // repeated float last_1s_y = 11;
  int last_1s_y_size() const;
  void clear_last_1s_y();
  static const int kLast1SYFieldNumber = 11;
  float last_1s_y(int index) const;
  void set_last_1s_y(int index, float value);
  void add_last_1s_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      last_1s_y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_last_1s_y();

  // repeated float last_1s_heading = 12;
  int last_1s_heading_size() const;
  void clear_last_1s_heading();
  static const int kLast1SHeadingFieldNumber = 12;
  float last_1s_heading(int index) const;
  void set_last_1s_heading(int index, float value);
  void add_last_1s_heading(float value);
  const ::google::protobuf::RepeatedField< float >&
      last_1s_heading() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_last_1s_heading();

  // repeated int32 last_record_counter = 13;
  int last_record_counter_size() const;
  void clear_last_record_counter();
  static const int kLastRecordCounterFieldNumber = 13;
  ::google::protobuf::int32 last_record_counter(int index) const;
  void set_last_record_counter(int index, ::google::protobuf::int32 value);
  void add_last_record_counter(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      last_record_counter() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_last_record_counter();

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // uint64 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint64 type() const;
  void set_type(::google::protobuf::uint64 value);

  // int32 appear_count = 2;
  void clear_appear_count();
  static const int kAppearCountFieldNumber = 2;
  ::google::protobuf::int32 appear_count() const;
  void set_appear_count(::google::protobuf::int32 value);

  // float width = 4;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  float width() const;
  void set_width(float value);

  // float length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  float length() const;
  void set_length(float value);

  // float speed_x = 6;
  void clear_speed_x();
  static const int kSpeedXFieldNumber = 6;
  float speed_x() const;
  void set_speed_x(float value);

  // float speed_y = 7;
  void clear_speed_y();
  static const int kSpeedYFieldNumber = 7;
  float speed_y() const;
  void set_speed_y(float value);

  // float cur_distance_x = 8;
  void clear_cur_distance_x();
  static const int kCurDistanceXFieldNumber = 8;
  float cur_distance_x() const;
  void set_cur_distance_x(float value);

  // float cur_distance_y = 9;
  void clear_cur_distance_y();
  static const int kCurDistanceYFieldNumber = 9;
  float cur_distance_y() const;
  void set_cur_distance_y(float value);

  // .calmcar.perception.AebFollowObjectState state = 14;
  void clear_state();
  static const int kStateFieldNumber = 14;
  ::calmcar::perception::AebFollowObjectState state() const;
  void set_state(::calmcar::perception::AebFollowObjectState value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.AebObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > last_1s_x_;
  mutable int _last_1s_x_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > last_1s_y_;
  mutable int _last_1s_y_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > last_1s_heading_;
  mutable int _last_1s_heading_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > last_record_counter_;
  mutable int _last_record_counter_cached_byte_size_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint64 type_;
  ::google::protobuf::int32 appear_count_;
  float width_;
  float length_;
  float speed_x_;
  float speed_y_;
  float cur_distance_x_;
  float cur_distance_y_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsAebObjectImpl();
};
// -------------------------------------------------------------------

class VehiclePredictPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.VehiclePredictPoint) */ {
 public:
  VehiclePredictPoint();
  virtual ~VehiclePredictPoint();

  VehiclePredictPoint(const VehiclePredictPoint& from);

  inline VehiclePredictPoint& operator=(const VehiclePredictPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehiclePredictPoint(VehiclePredictPoint&& from) noexcept
    : VehiclePredictPoint() {
    *this = ::std::move(from);
  }

  inline VehiclePredictPoint& operator=(VehiclePredictPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePredictPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehiclePredictPoint* internal_default_instance() {
    return reinterpret_cast<const VehiclePredictPoint*>(
               &_VehiclePredictPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(VehiclePredictPoint* other);
  friend void swap(VehiclePredictPoint& a, VehiclePredictPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehiclePredictPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  VehiclePredictPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehiclePredictPoint& from);
  void MergeFrom(const VehiclePredictPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehiclePredictPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float t = 3;
  void clear_t();
  static const int kTFieldNumber = 3;
  float t() const;
  void set_t(float value);

  // .calmcar.perception.AebFollowObjectState status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::calmcar::perception::AebFollowObjectState status() const;
  void set_status(::calmcar::perception::AebFollowObjectState value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.VehiclePredictPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float t_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsVehiclePredictPointImpl();
};
// -------------------------------------------------------------------

class Vehicle_State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Vehicle_State) */ {
 public:
  Vehicle_State();
  virtual ~Vehicle_State();

  Vehicle_State(const Vehicle_State& from);

  inline Vehicle_State& operator=(const Vehicle_State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_State(Vehicle_State&& from) noexcept
    : Vehicle_State() {
    *this = ::std::move(from);
  }

  inline Vehicle_State& operator=(Vehicle_State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_State* internal_default_instance() {
    return reinterpret_cast<const Vehicle_State*>(
               &_Vehicle_State_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Vehicle_State* other);
  friend void swap(Vehicle_State& a, Vehicle_State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_State* New() const PROTOBUF_FINAL { return New(NULL); }

  Vehicle_State* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vehicle_State& from);
  void MergeFrom(const Vehicle_State& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vehicle_State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float vehicle_spd = 1;
  void clear_vehicle_spd();
  static const int kVehicleSpdFieldNumber = 1;
  float vehicle_spd() const;
  void set_vehicle_spd(float value);

  // float vehicle_yaw_rate = 2;
  void clear_vehicle_yaw_rate();
  static const int kVehicleYawRateFieldNumber = 2;
  float vehicle_yaw_rate() const;
  void set_vehicle_yaw_rate(float value);

  // float lateral_acce = 3;
  void clear_lateral_acce();
  static const int kLateralAcceFieldNumber = 3;
  float lateral_acce() const;
  void set_lateral_acce(float value);

  // float longitude_acce = 4;
  void clear_longitude_acce();
  static const int kLongitudeAcceFieldNumber = 4;
  float longitude_acce() const;
  void set_longitude_acce(float value);

  // bool throttle_report_driver = 5;
  void clear_throttle_report_driver();
  static const int kThrottleReportDriverFieldNumber = 5;
  bool throttle_report_driver() const;
  void set_throttle_report_driver(bool value);

  // float steering_torque_nm = 6;
  void clear_steering_torque_nm();
  static const int kSteeringTorqueNmFieldNumber = 6;
  float steering_torque_nm() const;
  void set_steering_torque_nm(float value);

  // float steer_angle = 7;
  void clear_steer_angle();
  static const int kSteerAngleFieldNumber = 7;
  float steer_angle() const;
  void set_steer_angle(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Vehicle_State)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float vehicle_spd_;
  float vehicle_yaw_rate_;
  float lateral_acce_;
  float longitude_acce_;
  bool throttle_report_driver_;
  float steering_torque_nm_;
  float steer_angle_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsVehicle_StateImpl();
};
// -------------------------------------------------------------------

class Signal_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Signal_Input) */ {
 public:
  Signal_Input();
  virtual ~Signal_Input();

  Signal_Input(const Signal_Input& from);

  inline Signal_Input& operator=(const Signal_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Input(Signal_Input&& from) noexcept
    : Signal_Input() {
    *this = ::std::move(from);
  }

  inline Signal_Input& operator=(Signal_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_Input* internal_default_instance() {
    return reinterpret_cast<const Signal_Input*>(
               &_Signal_Input_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Signal_Input* other);
  friend void swap(Signal_Input& a, Signal_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Input* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal_Input* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal_Input& from);
  void MergeFrom(const Signal_Input& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.Vehicle_State vehicle_state = 8;
  bool has_vehicle_state() const;
  void clear_vehicle_state();
  static const int kVehicleStateFieldNumber = 8;
  const ::calmcar::perception::Vehicle_State& vehicle_state() const;
  ::calmcar::perception::Vehicle_State* release_vehicle_state();
  ::calmcar::perception::Vehicle_State* mutable_vehicle_state();
  void set_allocated_vehicle_state(::calmcar::perception::Vehicle_State* vehicle_state);

  // bool FCW_Enable = 1;
  void clear_fcw_enable();
  static const int kFCWEnableFieldNumber = 1;
  bool fcw_enable() const;
  void set_fcw_enable(bool value);

  // bool AEB_Enable = 2;
  void clear_aeb_enable();
  static const int kAEBEnableFieldNumber = 2;
  bool aeb_enable() const;
  void set_aeb_enable(bool value);

  // uint32 FCWSensitiveLevel = 3;
  void clear_fcwsensitivelevel();
  static const int kFCWSensitiveLevelFieldNumber = 3;
  ::google::protobuf::uint32 fcwsensitivelevel() const;
  void set_fcwsensitivelevel(::google::protobuf::uint32 value);

  // uint32 AEBSensitiveLevel = 4;
  void clear_aebsensitivelevel();
  static const int kAEBSensitiveLevelFieldNumber = 4;
  ::google::protobuf::uint32 aebsensitivelevel() const;
  void set_aebsensitivelevel(::google::protobuf::uint32 value);

  // uint32 TireComplexityLevel = 5;
  void clear_tirecomplexitylevel();
  static const int kTireComplexityLevelFieldNumber = 5;
  ::google::protobuf::uint32 tirecomplexitylevel() const;
  void set_tirecomplexitylevel(::google::protobuf::uint32 value);

  // float EnvTemperature = 6;
  void clear_envtemperature();
  static const int kEnvTemperatureFieldNumber = 6;
  float envtemperature() const;
  void set_envtemperature(float value);

  // float EnvHumidity = 7;
  void clear_envhumidity();
  static const int kEnvHumidityFieldNumber = 7;
  float envhumidity() const;
  void set_envhumidity(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Signal_Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::Vehicle_State* vehicle_state_;
  bool fcw_enable_;
  bool aeb_enable_;
  ::google::protobuf::uint32 fcwsensitivelevel_;
  ::google::protobuf::uint32 aebsensitivelevel_;
  ::google::protobuf::uint32 tirecomplexitylevel_;
  float envtemperature_;
  float envhumidity_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsSignal_InputImpl();
};
// -------------------------------------------------------------------

class Signal_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Signal_Output) */ {
 public:
  Signal_Output();
  virtual ~Signal_Output();

  Signal_Output(const Signal_Output& from);

  inline Signal_Output& operator=(const Signal_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Output(Signal_Output&& from) noexcept
    : Signal_Output() {
    *this = ::std::move(from);
  }

  inline Signal_Output& operator=(Signal_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_Output* internal_default_instance() {
    return reinterpret_cast<const Signal_Output*>(
               &_Signal_Output_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Signal_Output* other);
  friend void swap(Signal_Output& a, Signal_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Output* New() const PROTOBUF_FINAL { return New(NULL); }

  Signal_Output* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signal_Output& from);
  void MergeFrom(const Signal_Output& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signal_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool FCW_Active = 1;
  void clear_fcw_active();
  static const int kFCWActiveFieldNumber = 1;
  bool fcw_active() const;
  void set_fcw_active(bool value);

  // bool AEB_Active = 2;
  void clear_aeb_active();
  static const int kAEBActiveFieldNumber = 2;
  bool aeb_active() const;
  void set_aeb_active(bool value);

  // uint32 FCWStatus = 3;
  void clear_fcwstatus();
  static const int kFCWStatusFieldNumber = 3;
  ::google::protobuf::uint32 fcwstatus() const;
  void set_fcwstatus(::google::protobuf::uint32 value);

  // uint32 FCWSensitiveLevel = 4;
  void clear_fcwsensitivelevel();
  static const int kFCWSensitiveLevelFieldNumber = 4;
  ::google::protobuf::uint32 fcwsensitivelevel() const;
  void set_fcwsensitivelevel(::google::protobuf::uint32 value);

  // uint32 FCW_State = 5;
  void clear_fcw_state();
  static const int kFCWStateFieldNumber = 5;
  ::google::protobuf::uint32 fcw_state() const;
  void set_fcw_state(::google::protobuf::uint32 value);

  // uint32 AEBStatus = 6;
  void clear_aebstatus();
  static const int kAEBStatusFieldNumber = 6;
  ::google::protobuf::uint32 aebstatus() const;
  void set_aebstatus(::google::protobuf::uint32 value);

  // uint32 AEBSensitiveLevel = 7;
  void clear_aebsensitivelevel();
  static const int kAEBSensitiveLevelFieldNumber = 7;
  ::google::protobuf::uint32 aebsensitivelevel() const;
  void set_aebsensitivelevel(::google::protobuf::uint32 value);

  // uint32 AEB_State = 8;
  void clear_aeb_state();
  static const int kAEBStateFieldNumber = 8;
  ::google::protobuf::uint32 aeb_state() const;
  void set_aeb_state(::google::protobuf::uint32 value);

  // uint32 AEBVehicleHoldReq = 9;
  void clear_aebvehicleholdreq();
  static const int kAEBVehicleHoldReqFieldNumber = 9;
  ::google::protobuf::uint32 aebvehicleholdreq() const;
  void set_aebvehicleholdreq(::google::protobuf::uint32 value);

  // uint32 AEBFullBrake = 10;
  void clear_aebfullbrake();
  static const int kAEBFullBrakeFieldNumber = 10;
  ::google::protobuf::uint32 aebfullbrake() const;
  void set_aebfullbrake(::google::protobuf::uint32 value);

  // uint32 AEBDBSLevel = 11;
  void clear_aebdbslevel();
  static const int kAEBDBSLevelFieldNumber = 11;
  ::google::protobuf::uint32 aebdbslevel() const;
  void set_aebdbslevel(::google::protobuf::uint32 value);

  // uint32 AEBPrefillReq = 12;
  void clear_aebprefillreq();
  static const int kAEBPrefillReqFieldNumber = 12;
  ::google::protobuf::uint32 aebprefillreq() const;
  void set_aebprefillreq(::google::protobuf::uint32 value);

  // uint32 AEBJerkReq = 13;
  void clear_aebjerkreq();
  static const int kAEBJerkReqFieldNumber = 13;
  ::google::protobuf::uint32 aebjerkreq() const;
  void set_aebjerkreq(::google::protobuf::uint32 value);

  // float AEBTargetDeceleration = 14;
  void clear_aebtargetdeceleration();
  static const int kAEBTargetDecelerationFieldNumber = 14;
  float aebtargetdeceleration() const;
  void set_aebtargetdeceleration(float value);

  // uint32 AEBJerkLevel = 15;
  void clear_aebjerklevel();
  static const int kAEBJerkLevelFieldNumber = 15;
  ::google::protobuf::uint32 aebjerklevel() const;
  void set_aebjerklevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Signal_Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool fcw_active_;
  bool aeb_active_;
  ::google::protobuf::uint32 fcwstatus_;
  ::google::protobuf::uint32 fcwsensitivelevel_;
  ::google::protobuf::uint32 fcw_state_;
  ::google::protobuf::uint32 aebstatus_;
  ::google::protobuf::uint32 aebsensitivelevel_;
  ::google::protobuf::uint32 aeb_state_;
  ::google::protobuf::uint32 aebvehicleholdreq_;
  ::google::protobuf::uint32 aebfullbrake_;
  ::google::protobuf::uint32 aebdbslevel_;
  ::google::protobuf::uint32 aebprefillreq_;
  ::google::protobuf::uint32 aebjerkreq_;
  float aebtargetdeceleration_;
  ::google::protobuf::uint32 aebjerklevel_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsSignal_OutputImpl();
};
// -------------------------------------------------------------------

class Fault_Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Fault_Signal) */ {
 public:
  Fault_Signal();
  virtual ~Fault_Signal();

  Fault_Signal(const Fault_Signal& from);

  inline Fault_Signal& operator=(const Fault_Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fault_Signal(Fault_Signal&& from) noexcept
    : Fault_Signal() {
    *this = ::std::move(from);
  }

  inline Fault_Signal& operator=(Fault_Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fault_Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fault_Signal* internal_default_instance() {
    return reinterpret_cast<const Fault_Signal*>(
               &_Fault_Signal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Fault_Signal* other);
  friend void swap(Fault_Signal& a, Fault_Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fault_Signal* New() const PROTOBUF_FINAL { return New(NULL); }

  Fault_Signal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fault_Signal& from);
  void MergeFrom(const Fault_Signal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fault_Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 FCWSystemFaultStatus = 1;
  void clear_fcwsystemfaultstatus();
  static const int kFCWSystemFaultStatusFieldNumber = 1;
  ::google::protobuf::uint32 fcwsystemfaultstatus() const;
  void set_fcwsystemfaultstatus(::google::protobuf::uint32 value);

  // uint32 AEBSystemFaultStatus = 2;
  void clear_aebsystemfaultstatus();
  static const int kAEBSystemFaultStatusFieldNumber = 2;
  ::google::protobuf::uint32 aebsystemfaultstatus() const;
  void set_aebsystemfaultstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Fault_Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 fcwsystemfaultstatus_;
  ::google::protobuf::uint32 aebsystemfaultstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsFault_SignalImpl();
};
// -------------------------------------------------------------------

class Vehicle_Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Vehicle_Signal) */ {
 public:
  Vehicle_Signal();
  virtual ~Vehicle_Signal();

  Vehicle_Signal(const Vehicle_Signal& from);

  inline Vehicle_Signal& operator=(const Vehicle_Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_Signal(Vehicle_Signal&& from) noexcept
    : Vehicle_Signal() {
    *this = ::std::move(from);
  }

  inline Vehicle_Signal& operator=(Vehicle_Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_Signal* internal_default_instance() {
    return reinterpret_cast<const Vehicle_Signal*>(
               &_Vehicle_Signal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Vehicle_Signal* other);
  friend void swap(Vehicle_Signal& a, Vehicle_Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_Signal* New() const PROTOBUF_FINAL { return New(NULL); }

  Vehicle_Signal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vehicle_Signal& from);
  void MergeFrom(const Vehicle_Signal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vehicle_Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.Signal_Output signal_output = 1;
  bool has_signal_output() const;
  void clear_signal_output();
  static const int kSignalOutputFieldNumber = 1;
  const ::calmcar::perception::Signal_Output& signal_output() const;
  ::calmcar::perception::Signal_Output* release_signal_output();
  ::calmcar::perception::Signal_Output* mutable_signal_output();
  void set_allocated_signal_output(::calmcar::perception::Signal_Output* signal_output);

  // .calmcar.perception.Fault_Signal fault_signal = 2;
  bool has_fault_signal() const;
  void clear_fault_signal();
  static const int kFaultSignalFieldNumber = 2;
  const ::calmcar::perception::Fault_Signal& fault_signal() const;
  ::calmcar::perception::Fault_Signal* release_fault_signal();
  ::calmcar::perception::Fault_Signal* mutable_fault_signal();
  void set_allocated_fault_signal(::calmcar::perception::Fault_Signal* fault_signal);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Vehicle_Signal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::Signal_Output* signal_output_;
  ::calmcar::perception::Fault_Signal* fault_signal_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsVehicle_SignalImpl();
};
// -------------------------------------------------------------------

class AebOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.AebOutput) */ {
 public:
  AebOutput();
  virtual ~AebOutput();

  AebOutput(const AebOutput& from);

  inline AebOutput& operator=(const AebOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AebOutput(AebOutput&& from) noexcept
    : AebOutput() {
    *this = ::std::move(from);
  }

  inline AebOutput& operator=(AebOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AebOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AebOutput* internal_default_instance() {
    return reinterpret_cast<const AebOutput*>(
               &_AebOutput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AebOutput* other);
  friend void swap(AebOutput& a, AebOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AebOutput* New() const PROTOBUF_FINAL { return New(NULL); }

  AebOutput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AebOutput& from);
  void MergeFrom(const AebOutput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AebOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AebOutput_AebOut AebOut;
  static const AebOut AEB_IDLE =
    AebOutput_AebOut_AEB_IDLE;
  static const AebOut AEB_WARNING =
    AebOutput_AebOut_AEB_WARNING;
  static const AebOut AEB_BRAKING_LEVEL1 =
    AebOutput_AebOut_AEB_BRAKING_LEVEL1;
  static const AebOut AEB_BRAKING_LEVEL2 =
    AebOutput_AebOut_AEB_BRAKING_LEVEL2;
  static const AebOut AEB_BRAKING_LEVEL3 =
    AebOutput_AebOut_AEB_BRAKING_LEVEL3;
  static inline bool AebOut_IsValid(int value) {
    return AebOutput_AebOut_IsValid(value);
  }
  static const AebOut AebOut_MIN =
    AebOutput_AebOut_AebOut_MIN;
  static const AebOut AebOut_MAX =
    AebOutput_AebOut_AebOut_MAX;
  static const int AebOut_ARRAYSIZE =
    AebOutput_AebOut_AebOut_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AebOut_descriptor() {
    return AebOutput_AebOut_descriptor();
  }
  static inline const ::std::string& AebOut_Name(AebOut value) {
    return AebOutput_AebOut_Name(value);
  }
  static inline bool AebOut_Parse(const ::std::string& name,
      AebOut* value) {
    return AebOutput_AebOut_Parse(name, value);
  }

  typedef AebOutput_AebDecision AebDecision;
  static const AebDecision AEB_DECISION_IDLE =
    AebOutput_AebDecision_AEB_DECISION_IDLE;
  static const AebDecision AEB_DECISION_WARNING =
    AebOutput_AebDecision_AEB_DECISION_WARNING;
  static const AebDecision AEB_DECISION_FRONT_BRAKE_LEVEL1 =
    AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL1;
  static const AebDecision AEB_DECISION_FRONT_BRAKE_LEVEL2 =
    AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL2;
  static const AebDecision AEB_DECISION_FRONT_BRAKE_LEVEL3 =
    AebOutput_AebDecision_AEB_DECISION_FRONT_BRAKE_LEVEL3;
  static const AebDecision AEB_DECISION_PASS_BRAKE_LEVEL1 =
    AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL1;
  static const AebDecision AEB_DECISION_PASS_BRAKE_LEVEL2 =
    AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL2;
  static const AebDecision AEB_DECISION_PASS_BRAKE_LEVEL3 =
    AebOutput_AebDecision_AEB_DECISION_PASS_BRAKE_LEVEL3;
  static inline bool AebDecision_IsValid(int value) {
    return AebOutput_AebDecision_IsValid(value);
  }
  static const AebDecision AebDecision_MIN =
    AebOutput_AebDecision_AebDecision_MIN;
  static const AebDecision AebDecision_MAX =
    AebOutput_AebDecision_AebDecision_MAX;
  static const int AebDecision_ARRAYSIZE =
    AebOutput_AebDecision_AebDecision_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AebDecision_descriptor() {
    return AebOutput_AebDecision_descriptor();
  }
  static inline const ::std::string& AebDecision_Name(AebDecision value) {
    return AebOutput_AebDecision_Name(value);
  }
  static inline bool AebDecision_Parse(const ::std::string& name,
      AebDecision* value) {
    return AebOutput_AebDecision_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.AebObject follow_objects = 4;
  int follow_objects_size() const;
  void clear_follow_objects();
  static const int kFollowObjectsFieldNumber = 4;
  const ::calmcar::perception::AebObject& follow_objects(int index) const;
  ::calmcar::perception::AebObject* mutable_follow_objects(int index);
  ::calmcar::perception::AebObject* add_follow_objects();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::AebObject >*
      mutable_follow_objects();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::AebObject >&
      follow_objects() const;

  // repeated .calmcar.perception.VehiclePredictPoint predict_pts = 5;
  int predict_pts_size() const;
  void clear_predict_pts();
  static const int kPredictPtsFieldNumber = 5;
  const ::calmcar::perception::VehiclePredictPoint& predict_pts(int index) const;
  ::calmcar::perception::VehiclePredictPoint* mutable_predict_pts(int index);
  ::calmcar::perception::VehiclePredictPoint* add_predict_pts();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::VehiclePredictPoint >*
      mutable_predict_pts();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::VehiclePredictPoint >&
      predict_pts() const;

  // .calmcar.perception.Vehicle_Signal vehicle_signal = 6;
  bool has_vehicle_signal() const;
  void clear_vehicle_signal();
  static const int kVehicleSignalFieldNumber = 6;
  const ::calmcar::perception::Vehicle_Signal& vehicle_signal() const;
  ::calmcar::perception::Vehicle_Signal* release_vehicle_signal();
  ::calmcar::perception::Vehicle_Signal* mutable_vehicle_signal();
  void set_allocated_vehicle_signal(::calmcar::perception::Vehicle_Signal* vehicle_signal);

  // bool is_valid = 1;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 1;
  bool is_valid() const;
  void set_is_valid(bool value);

  // .calmcar.perception.AebOutput.AebOut aeb_out = 2;
  void clear_aeb_out();
  static const int kAebOutFieldNumber = 2;
  ::calmcar::perception::AebOutput_AebOut aeb_out() const;
  void set_aeb_out(::calmcar::perception::AebOutput_AebOut value);

  // .calmcar.perception.AebOutput.AebDecision aeb_decision = 3;
  void clear_aeb_decision();
  static const int kAebDecisionFieldNumber = 3;
  ::calmcar::perception::AebOutput_AebDecision aeb_decision() const;
  void set_aeb_decision(::calmcar::perception::AebOutput_AebDecision value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.AebOutput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::AebObject > follow_objects_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::VehiclePredictPoint > predict_pts_;
  ::calmcar::perception::Vehicle_Signal* vehicle_signal_;
  bool is_valid_;
  int aeb_out_;
  int aeb_decision_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsAebOutputImpl();
};
// -------------------------------------------------------------------

class AebInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.AebInput) */ {
 public:
  AebInput();
  virtual ~AebInput();

  AebInput(const AebInput& from);

  inline AebInput& operator=(const AebInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AebInput(AebInput&& from) noexcept
    : AebInput() {
    *this = ::std::move(from);
  }

  inline AebInput& operator=(AebInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AebInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AebInput* internal_default_instance() {
    return reinterpret_cast<const AebInput*>(
               &_AebInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(AebInput* other);
  friend void swap(AebInput& a, AebInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AebInput* New() const PROTOBUF_FINAL { return New(NULL); }

  AebInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AebInput& from);
  void MergeFrom(const AebInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AebInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.Signal_Input signal_input = 1;
  bool has_signal_input() const;
  void clear_signal_input();
  static const int kSignalInputFieldNumber = 1;
  const ::calmcar::perception::Signal_Input& signal_input() const;
  ::calmcar::perception::Signal_Input* release_signal_input();
  ::calmcar::perception::Signal_Input* mutable_signal_input();
  void set_allocated_signal_input(::calmcar::perception::Signal_Input* signal_input);

  // @@protoc_insertion_point(class_scope:calmcar.perception.AebInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::Signal_Input* signal_input_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsAebInputImpl();
};
// -------------------------------------------------------------------

class AebInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.AebInfo) */ {
 public:
  AebInfo();
  virtual ~AebInfo();

  AebInfo(const AebInfo& from);

  inline AebInfo& operator=(const AebInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AebInfo(AebInfo&& from) noexcept
    : AebInfo() {
    *this = ::std::move(from);
  }

  inline AebInfo& operator=(AebInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AebInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AebInfo* internal_default_instance() {
    return reinterpret_cast<const AebInfo*>(
               &_AebInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(AebInfo* other);
  friend void swap(AebInfo& a, AebInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AebInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  AebInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AebInfo& from);
  void MergeFrom(const AebInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AebInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.AebInput aeb_input = 1;
  bool has_aeb_input() const;
  void clear_aeb_input();
  static const int kAebInputFieldNumber = 1;
  const ::calmcar::perception::AebInput& aeb_input() const;
  ::calmcar::perception::AebInput* release_aeb_input();
  ::calmcar::perception::AebInput* mutable_aeb_input();
  void set_allocated_aeb_input(::calmcar::perception::AebInput* aeb_input);

  // .calmcar.perception.AebOutput aeb_output = 2;
  bool has_aeb_output() const;
  void clear_aeb_output();
  static const int kAebOutputFieldNumber = 2;
  const ::calmcar::perception::AebOutput& aeb_output() const;
  ::calmcar::perception::AebOutput* release_aeb_output();
  ::calmcar::perception::AebOutput* mutable_aeb_output();
  void set_allocated_aeb_output(::calmcar::perception::AebOutput* aeb_output);

  // @@protoc_insertion_point(class_scope:calmcar.perception.AebInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::AebInput* aeb_input_;
  ::calmcar::perception::AebOutput* aeb_output_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsAebInfoImpl();
};
// -------------------------------------------------------------------

class Failsafe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Failsafe) */ {
 public:
  Failsafe();
  virtual ~Failsafe();

  Failsafe(const Failsafe& from);

  inline Failsafe& operator=(const Failsafe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Failsafe(Failsafe&& from) noexcept
    : Failsafe() {
    *this = ::std::move(from);
  }

  inline Failsafe& operator=(Failsafe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Failsafe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Failsafe* internal_default_instance() {
    return reinterpret_cast<const Failsafe*>(
               &_Failsafe_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Failsafe* other);
  friend void swap(Failsafe& a, Failsafe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Failsafe* New() const PROTOBUF_FINAL { return New(NULL); }

  Failsafe* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Failsafe& from);
  void MergeFrom(const Failsafe& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Failsafe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Failsafe_FailSafeBlockage FailSafeBlockage;
  static const FailSafeBlockage BLOCKAGE_UNKNOWN =
    Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN;
  static const FailSafeBlockage BLOCKAGE_FULL =
    Failsafe_FailSafeBlockage_BLOCKAGE_FULL;
  static const FailSafeBlockage BLOCKAGE_PARTICAL =
    Failsafe_FailSafeBlockage_BLOCKAGE_PARTICAL;
  static const FailSafeBlockage BLOCKAGE_NONE =
    Failsafe_FailSafeBlockage_BLOCKAGE_NONE;
  static inline bool FailSafeBlockage_IsValid(int value) {
    return Failsafe_FailSafeBlockage_IsValid(value);
  }
  static const FailSafeBlockage FailSafeBlockage_MIN =
    Failsafe_FailSafeBlockage_FailSafeBlockage_MIN;
  static const FailSafeBlockage FailSafeBlockage_MAX =
    Failsafe_FailSafeBlockage_FailSafeBlockage_MAX;
  static const int FailSafeBlockage_ARRAYSIZE =
    Failsafe_FailSafeBlockage_FailSafeBlockage_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeBlockage_descriptor() {
    return Failsafe_FailSafeBlockage_descriptor();
  }
  static inline const ::std::string& FailSafeBlockage_Name(FailSafeBlockage value) {
    return Failsafe_FailSafeBlockage_Name(value);
  }
  static inline bool FailSafeBlockage_Parse(const ::std::string& name,
      FailSafeBlockage* value) {
    return Failsafe_FailSafeBlockage_Parse(name, value);
  }

  typedef Failsafe_FailSafeWeather FailSafeWeather;
  static const FailSafeWeather WEATHER_UNKNOWN =
    Failsafe_FailSafeWeather_WEATHER_UNKNOWN;
  static const FailSafeWeather WEATHER_FOG =
    Failsafe_FailSafeWeather_WEATHER_FOG;
  static const FailSafeWeather WEATHER_RAIN =
    Failsafe_FailSafeWeather_WEATHER_RAIN;
  static const FailSafeWeather WEATHER_SNOW =
    Failsafe_FailSafeWeather_WEATHER_SNOW;
  static const FailSafeWeather WEATHER_SUNNY =
    Failsafe_FailSafeWeather_WEATHER_SUNNY;
  static inline bool FailSafeWeather_IsValid(int value) {
    return Failsafe_FailSafeWeather_IsValid(value);
  }
  static const FailSafeWeather FailSafeWeather_MIN =
    Failsafe_FailSafeWeather_FailSafeWeather_MIN;
  static const FailSafeWeather FailSafeWeather_MAX =
    Failsafe_FailSafeWeather_FailSafeWeather_MAX;
  static const int FailSafeWeather_ARRAYSIZE =
    Failsafe_FailSafeWeather_FailSafeWeather_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeWeather_descriptor() {
    return Failsafe_FailSafeWeather_descriptor();
  }
  static inline const ::std::string& FailSafeWeather_Name(FailSafeWeather value) {
    return Failsafe_FailSafeWeather_Name(value);
  }
  static inline bool FailSafeWeather_Parse(const ::std::string& name,
      FailSafeWeather* value) {
    return Failsafe_FailSafeWeather_Parse(name, value);
  }

  typedef Failsafe_FailSafeIllumination FailSafeIllumination;
  static const FailSafeIllumination ILLUMINATION_UNKNOWN =
    Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN;
  static const FailSafeIllumination ILLUMINATION_DAY =
    Failsafe_FailSafeIllumination_ILLUMINATION_DAY;
  static const FailSafeIllumination ILLUMINATION_DUSK =
    Failsafe_FailSafeIllumination_ILLUMINATION_DUSK;
  static const FailSafeIllumination ILLUMINATION_NIGHT =
    Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT;
  static inline bool FailSafeIllumination_IsValid(int value) {
    return Failsafe_FailSafeIllumination_IsValid(value);
  }
  static const FailSafeIllumination FailSafeIllumination_MIN =
    Failsafe_FailSafeIllumination_FailSafeIllumination_MIN;
  static const FailSafeIllumination FailSafeIllumination_MAX =
    Failsafe_FailSafeIllumination_FailSafeIllumination_MAX;
  static const int FailSafeIllumination_ARRAYSIZE =
    Failsafe_FailSafeIllumination_FailSafeIllumination_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeIllumination_descriptor() {
    return Failsafe_FailSafeIllumination_descriptor();
  }
  static inline const ::std::string& FailSafeIllumination_Name(FailSafeIllumination value) {
    return Failsafe_FailSafeIllumination_Name(value);
  }
  static inline bool FailSafeIllumination_Parse(const ::std::string& name,
      FailSafeIllumination* value) {
    return Failsafe_FailSafeIllumination_Parse(name, value);
  }

  typedef Failsafe_FailSafeImageLimited FailSafeImageLimited;
  static const FailSafeImageLimited IMAGE_LIMITED_UNKNOWN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN;
  static const FailSafeImageLimited IMAGE_LIMITED_NORMAL =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_NORMAL;
  static const FailSafeImageLimited IMAGE_LIMITED_LOWSUN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_LOWSUN;
  static const FailSafeImageLimited IMAGE_LIMITED_SPALSHES =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SPALSHES;
  static const FailSafeImageLimited IMAGE_LIMITED_BLUR =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_BLUR;
  static const FailSafeImageLimited IMAGE_LIMITED_SUNRAY =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SUNRAY;
  static const FailSafeImageLimited IMAGE_LIMITED_FROZEN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_FROZEN;
  static const FailSafeImageLimited IMAGE_LIMITED_OTHER =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER;
  static inline bool FailSafeImageLimited_IsValid(int value) {
    return Failsafe_FailSafeImageLimited_IsValid(value);
  }
  static const FailSafeImageLimited FailSafeImageLimited_MIN =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_MIN;
  static const FailSafeImageLimited FailSafeImageLimited_MAX =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX;
  static const int FailSafeImageLimited_ARRAYSIZE =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeImageLimited_descriptor() {
    return Failsafe_FailSafeImageLimited_descriptor();
  }
  static inline const ::std::string& FailSafeImageLimited_Name(FailSafeImageLimited value) {
    return Failsafe_FailSafeImageLimited_Name(value);
  }
  static inline bool FailSafeImageLimited_Parse(const ::std::string& name,
      FailSafeImageLimited* value) {
    return Failsafe_FailSafeImageLimited_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string blockage_name = 4;
  void clear_blockage_name();
  static const int kBlockageNameFieldNumber = 4;
  const ::std::string& blockage_name() const;
  void set_blockage_name(const ::std::string& value);
  #if LANG_CXX11
  void set_blockage_name(::std::string&& value);
  #endif
  void set_blockage_name(const char* value);
  void set_blockage_name(const char* value, size_t size);
  ::std::string* mutable_blockage_name();
  ::std::string* release_blockage_name();
  void set_allocated_blockage_name(::std::string* blockage_name);

  // string weather_name = 6;
  void clear_weather_name();
  static const int kWeatherNameFieldNumber = 6;
  const ::std::string& weather_name() const;
  void set_weather_name(const ::std::string& value);
  #if LANG_CXX11
  void set_weather_name(::std::string&& value);
  #endif
  void set_weather_name(const char* value);
  void set_weather_name(const char* value, size_t size);
  ::std::string* mutable_weather_name();
  ::std::string* release_weather_name();
  void set_allocated_weather_name(::std::string* weather_name);

  // string illumination_name = 8;
  void clear_illumination_name();
  static const int kIlluminationNameFieldNumber = 8;
  const ::std::string& illumination_name() const;
  void set_illumination_name(const ::std::string& value);
  #if LANG_CXX11
  void set_illumination_name(::std::string&& value);
  #endif
  void set_illumination_name(const char* value);
  void set_illumination_name(const char* value, size_t size);
  ::std::string* mutable_illumination_name();
  ::std::string* release_illumination_name();
  void set_allocated_illumination_name(::std::string* illumination_name);

  // string image_limited_name = 10;
  void clear_image_limited_name();
  static const int kImageLimitedNameFieldNumber = 10;
  const ::std::string& image_limited_name() const;
  void set_image_limited_name(const ::std::string& value);
  #if LANG_CXX11
  void set_image_limited_name(::std::string&& value);
  #endif
  void set_image_limited_name(const char* value);
  void set_image_limited_name(const char* value, size_t size);
  ::std::string* mutable_image_limited_name();
  ::std::string* release_image_limited_name();
  void set_allocated_image_limited_name(::std::string* image_limited_name);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // .calmcar.perception.Failsafe.FailSafeBlockage blockage_status = 3;
  void clear_blockage_status();
  static const int kBlockageStatusFieldNumber = 3;
  ::calmcar::perception::Failsafe_FailSafeBlockage blockage_status() const;
  void set_blockage_status(::calmcar::perception::Failsafe_FailSafeBlockage value);

  // .calmcar.perception.Failsafe.FailSafeWeather weather_status = 5;
  void clear_weather_status();
  static const int kWeatherStatusFieldNumber = 5;
  ::calmcar::perception::Failsafe_FailSafeWeather weather_status() const;
  void set_weather_status(::calmcar::perception::Failsafe_FailSafeWeather value);

  // .calmcar.perception.Failsafe.FailSafeIllumination illumination_status = 7;
  void clear_illumination_status();
  static const int kIlluminationStatusFieldNumber = 7;
  ::calmcar::perception::Failsafe_FailSafeIllumination illumination_status() const;
  void set_illumination_status(::calmcar::perception::Failsafe_FailSafeIllumination value);

  // .calmcar.perception.Failsafe.FailSafeImageLimited image_limited_status = 9;
  void clear_image_limited_status();
  static const int kImageLimitedStatusFieldNumber = 9;
  ::calmcar::perception::Failsafe_FailSafeImageLimited image_limited_status() const;
  void set_image_limited_status(::calmcar::perception::Failsafe_FailSafeImageLimited value);

  // bool out_of_focus = 11;
  void clear_out_of_focus();
  static const int kOutOfFocusFieldNumber = 11;
  bool out_of_focus() const;
  void set_out_of_focus(bool value);

  // int32 impacted_technologies = 12;
  void clear_impacted_technologies();
  static const int kImpactedTechnologiesFieldNumber = 12;
  ::google::protobuf::int32 impacted_technologies() const;
  void set_impacted_technologies(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Failsafe)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blockage_name_;
  ::google::protobuf::internal::ArenaStringPtr weather_name_;
  ::google::protobuf::internal::ArenaStringPtr illumination_name_;
  ::google::protobuf::internal::ArenaStringPtr image_limited_name_;
  ::google::protobuf::int64 timestamp_;
  int camera_position_;
  int blockage_status_;
  int weather_status_;
  int illumination_status_;
  int image_limited_status_;
  bool out_of_focus_;
  ::google::protobuf::int32 impacted_technologies_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsFailsafeImpl();
};
// -------------------------------------------------------------------

class PerceptionFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.PerceptionFrame) */ {
 public:
  PerceptionFrame();
  virtual ~PerceptionFrame();

  PerceptionFrame(const PerceptionFrame& from);

  inline PerceptionFrame& operator=(const PerceptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionFrame(PerceptionFrame&& from) noexcept
    : PerceptionFrame() {
    *this = ::std::move(from);
  }

  inline PerceptionFrame& operator=(PerceptionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionFrame* internal_default_instance() {
    return reinterpret_cast<const PerceptionFrame*>(
               &_PerceptionFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(PerceptionFrame* other);
  friend void swap(PerceptionFrame& a, PerceptionFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  PerceptionFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerceptionFrame& from);
  void MergeFrom(const PerceptionFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerceptionFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.Object object = 10;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 10;
  const ::calmcar::perception::Object& object(int index) const;
  ::calmcar::perception::Object* mutable_object(int index);
  ::calmcar::perception::Object* add_object();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >*
      mutable_object();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >&
      object() const;

  // repeated .calmcar.perception.RoadMark road_mark = 11;
  int road_mark_size() const;
  void clear_road_mark();
  static const int kRoadMarkFieldNumber = 11;
  const ::calmcar::perception::RoadMark& road_mark(int index) const;
  ::calmcar::perception::RoadMark* mutable_road_mark(int index);
  ::calmcar::perception::RoadMark* add_road_mark();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >*
      mutable_road_mark();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >&
      road_mark() const;

  // repeated .calmcar.perception.TrafficLight tfl_structure = 14;
  int tfl_structure_size() const;
  void clear_tfl_structure();
  static const int kTflStructureFieldNumber = 14;
  const ::calmcar::perception::TrafficLight& tfl_structure(int index) const;
  ::calmcar::perception::TrafficLight* mutable_tfl_structure(int index);
  ::calmcar::perception::TrafficLight* add_tfl_structure();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
      mutable_tfl_structure();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
      tfl_structure() const;

  // repeated .calmcar.perception.TrafficLight tfl_struct_state = 15;
  int tfl_struct_state_size() const;
  void clear_tfl_struct_state();
  static const int kTflStructStateFieldNumber = 15;
  const ::calmcar::perception::TrafficLight& tfl_struct_state(int index) const;
  ::calmcar::perception::TrafficLight* mutable_tfl_struct_state(int index);
  ::calmcar::perception::TrafficLight* add_tfl_struct_state();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
      mutable_tfl_struct_state();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
      tfl_struct_state() const;

  // repeated .calmcar.perception.TrafficSign traffic_sign = 18;
  int traffic_sign_size() const;
  void clear_traffic_sign();
  static const int kTrafficSignFieldNumber = 18;
  const ::calmcar::perception::TrafficSign& traffic_sign(int index) const;
  ::calmcar::perception::TrafficSign* mutable_traffic_sign(int index);
  ::calmcar::perception::TrafficSign* add_traffic_sign();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >*
      mutable_traffic_sign();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >&
      traffic_sign() const;

  // repeated .calmcar.perception.TrafficSignStatus traffic_sign_status = 19;
  int traffic_sign_status_size() const;
  void clear_traffic_sign_status();
  static const int kTrafficSignStatusFieldNumber = 19;
  const ::calmcar::perception::TrafficSignStatus& traffic_sign_status(int index) const;
  ::calmcar::perception::TrafficSignStatus* mutable_traffic_sign_status(int index);
  ::calmcar::perception::TrafficSignStatus* add_traffic_sign_status();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >*
      mutable_traffic_sign_status();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >&
      traffic_sign_status() const;

  // repeated .calmcar.perception.Failsafe failsafe = 20;
  int failsafe_size() const;
  void clear_failsafe();
  static const int kFailsafeFieldNumber = 20;
  const ::calmcar::perception::Failsafe& failsafe(int index) const;
  ::calmcar::perception::Failsafe* mutable_failsafe(int index);
  ::calmcar::perception::Failsafe* add_failsafe();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >*
      mutable_failsafe();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >&
      failsafe() const;

  // repeated .calmcar.perception.Vehicle vehicle_info = 21;
  int vehicle_info_size() const;
  void clear_vehicle_info();
  static const int kVehicleInfoFieldNumber = 21;
  const ::calmcar::perception::Vehicle& vehicle_info(int index) const;
  ::calmcar::perception::Vehicle* mutable_vehicle_info(int index);
  ::calmcar::perception::Vehicle* add_vehicle_info();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >*
      mutable_vehicle_info();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >&
      vehicle_info() const;

  // repeated .calmcar.perception.Barricade barricade_object = 23;
  int barricade_object_size() const;
  void clear_barricade_object();
  static const int kBarricadeObjectFieldNumber = 23;
  const ::calmcar::perception::Barricade& barricade_object(int index) const;
  ::calmcar::perception::Barricade* mutable_barricade_object(int index);
  ::calmcar::perception::Barricade* add_barricade_object();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >*
      mutable_barricade_object();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >&
      barricade_object() const;

  // repeated .calmcar.perception.Point self_lane_center = 24;
  int self_lane_center_size() const;
  void clear_self_lane_center();
  static const int kSelfLaneCenterFieldNumber = 24;
  const ::calmcar::perception::Point& self_lane_center(int index) const;
  ::calmcar::perception::Point* mutable_self_lane_center(int index);
  ::calmcar::perception::Point* add_self_lane_center();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point >*
      mutable_self_lane_center();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point >&
      self_lane_center() const;

  // .calmcar.perception.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::calmcar::perception::Header& header() const;
  ::calmcar::perception::Header* release_header();
  ::calmcar::perception::Header* mutable_header();
  void set_allocated_header(::calmcar::perception::Header* header);

  // .calmcar.perception.Lane lane = 12;
  bool has_lane() const;
  void clear_lane();
  static const int kLaneFieldNumber = 12;
  const ::calmcar::perception::Lane& lane() const;
  ::calmcar::perception::Lane* release_lane();
  ::calmcar::perception::Lane* mutable_lane();
  void set_allocated_lane(::calmcar::perception::Lane* lane);

  // .calmcar.perception.FreeSpace free_space = 13;
  bool has_free_space() const;
  void clear_free_space();
  static const int kFreeSpaceFieldNumber = 13;
  const ::calmcar::perception::FreeSpace& free_space() const;
  ::calmcar::perception::FreeSpace* release_free_space();
  ::calmcar::perception::FreeSpace* mutable_free_space();
  void set_allocated_free_space(::calmcar::perception::FreeSpace* free_space);

  // .calmcar.perception.Diagnose diagnose = 25;
  bool has_diagnose() const;
  void clear_diagnose();
  static const int kDiagnoseFieldNumber = 25;
  const ::calmcar::perception::Diagnose& diagnose() const;
  ::calmcar::perception::Diagnose* release_diagnose();
  ::calmcar::perception::Diagnose* mutable_diagnose();
  void set_allocated_diagnose(::calmcar::perception::Diagnose* diagnose);

  // .calmcar.perception.AebInfo aeb_info = 27;
  bool has_aeb_info() const;
  void clear_aeb_info();
  static const int kAebInfoFieldNumber = 27;
  const ::calmcar::perception::AebInfo& aeb_info() const;
  ::calmcar::perception::AebInfo* release_aeb_info();
  ::calmcar::perception::AebInfo* mutable_aeb_info();
  void set_allocated_aeb_info(::calmcar::perception::AebInfo* aeb_info);

  // int64 vd_count = 2;
  void clear_vd_count();
  static const int kVdCountFieldNumber = 2;
  ::google::protobuf::int64 vd_count() const;
  void set_vd_count(::google::protobuf::int64 value);

  // int64 vru_count = 3;
  void clear_vru_count();
  static const int kVruCountFieldNumber = 3;
  ::google::protobuf::int64 vru_count() const;
  void set_vru_count(::google::protobuf::int64 value);

  // int64 num_of_objects = 4;
  void clear_num_of_objects();
  static const int kNumOfObjectsFieldNumber = 4;
  ::google::protobuf::int64 num_of_objects() const;
  void set_num_of_objects(::google::protobuf::int64 value);

  // int64 cipv_id = 5;
  void clear_cipv_id();
  static const int kCipvIdFieldNumber = 5;
  ::google::protobuf::int64 cipv_id() const;
  void set_cipv_id(::google::protobuf::int64 value);

  // int64 vd_niv_left = 6;
  void clear_vd_niv_left();
  static const int kVdNivLeftFieldNumber = 6;
  ::google::protobuf::int64 vd_niv_left() const;
  void set_vd_niv_left(::google::protobuf::int64 value);

  // int64 vd_niv_right = 7;
  void clear_vd_niv_right();
  static const int kVdNivRightFieldNumber = 7;
  ::google::protobuf::int64 vd_niv_right() const;
  void set_vd_niv_right(::google::protobuf::int64 value);

  // .calmcar.perception.CipvLost cipv_lost = 8;
  void clear_cipv_lost();
  static const int kCipvLostFieldNumber = 8;
  ::calmcar::perception::CipvLost cipv_lost() const;
  void set_cipv_lost(::calmcar::perception::CipvLost value);

  // .calmcar.perception.AllowAcc allow_acc = 9;
  void clear_allow_acc();
  static const int kAllowAccFieldNumber = 9;
  ::calmcar::perception::AllowAcc allow_acc() const;
  void set_allow_acc(::calmcar::perception::AllowAcc value);

  // int64 tfl_struct_count = 16;
  void clear_tfl_struct_count();
  static const int kTflStructCountFieldNumber = 16;
  ::google::protobuf::int64 tfl_struct_count() const;
  void set_tfl_struct_count(::google::protobuf::int64 value);

  // int64 tfl_spot_count = 17;
  void clear_tfl_spot_count();
  static const int kTflSpotCountFieldNumber = 17;
  ::google::protobuf::int64 tfl_spot_count() const;
  void set_tfl_spot_count(::google::protobuf::int64 value);

  // int64 barricade_count = 22;
  void clear_barricade_count();
  static const int kBarricadeCountFieldNumber = 22;
  ::google::protobuf::int64 barricade_count() const;
  void set_barricade_count(::google::protobuf::int64 value);

  // int64 perception_end_timestamp = 26;
  void clear_perception_end_timestamp();
  static const int kPerceptionEndTimestampFieldNumber = 26;
  ::google::protobuf::int64 perception_end_timestamp() const;
  void set_perception_end_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.PerceptionFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object > object_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark > road_mark_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight > tfl_structure_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight > tfl_struct_state_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign > traffic_sign_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus > traffic_sign_status_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe > failsafe_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle > vehicle_info_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade > barricade_object_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point > self_lane_center_;
  ::calmcar::perception::Header* header_;
  ::calmcar::perception::Lane* lane_;
  ::calmcar::perception::FreeSpace* free_space_;
  ::calmcar::perception::Diagnose* diagnose_;
  ::calmcar::perception::AebInfo* aeb_info_;
  ::google::protobuf::int64 vd_count_;
  ::google::protobuf::int64 vru_count_;
  ::google::protobuf::int64 num_of_objects_;
  ::google::protobuf::int64 cipv_id_;
  ::google::protobuf::int64 vd_niv_left_;
  ::google::protobuf::int64 vd_niv_right_;
  int cipv_lost_;
  int allow_acc_;
  ::google::protobuf::int64 tfl_struct_count_;
  ::google::protobuf::int64 tfl_spot_count_;
  ::google::protobuf::int64 barricade_count_;
  ::google::protobuf::int64 perception_end_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
  friend void ::protobuf_perception_2eproto::InitDefaultsPerceptionFrameImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// int64 frame_index = 1;
inline void Header::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.frame_index)
  return frame_index_;
}
inline void Header::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.frame_index)
}

// int64 timestamp = 2;
inline void Header::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.timestamp)
  return timestamp_;
}
inline void Header::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.timestamp)
}

// string perception_version = 3;
inline void Header::clear_perception_version() {
  perception_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::perception_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.perception_version)
  return perception_version_.GetNoArena();
}
inline void Header::set_perception_version(const ::std::string& value) {
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.perception_version)
}
#if LANG_CXX11
inline void Header::set_perception_version(::std::string&& value) {
  
  perception_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Header.perception_version)
}
#endif
inline void Header::set_perception_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Header.perception_version)
}
inline void Header::set_perception_version(const char* value, size_t size) {
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Header.perception_version)
}
inline ::std::string* Header::mutable_perception_version() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Header.perception_version)
  return perception_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_perception_version() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Header.perception_version)
  
  return perception_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_perception_version(::std::string* perception_version) {
  if (perception_version != NULL) {
    
  } else {
    
  }
  perception_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), perception_version);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Header.perception_version)
}

// .calmcar.perception.Header.ProtobufVersion protobuf_version = 4;
inline void Header::clear_protobuf_version() {
  protobuf_version_ = 0;
}
inline ::calmcar::perception::Header_ProtobufVersion Header::protobuf_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.protobuf_version)
  return static_cast< ::calmcar::perception::Header_ProtobufVersion >(protobuf_version_);
}
inline void Header::set_protobuf_version(::calmcar::perception::Header_ProtobufVersion value) {
  
  protobuf_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.protobuf_version)
}

// .calmcar.perception.Header.ObjectVersion object_version = 5;
inline void Header::clear_object_version() {
  object_version_ = 0;
}
inline ::calmcar::perception::Header_ObjectVersion Header::object_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.object_version)
  return static_cast< ::calmcar::perception::Header_ObjectVersion >(object_version_);
}
inline void Header::set_object_version(::calmcar::perception::Header_ObjectVersion value) {
  
  object_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.object_version)
}

// .calmcar.perception.Header.TrafficLightStructVersion tfl_struct_version = 6;
inline void Header::clear_tfl_struct_version() {
  tfl_struct_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficLightStructVersion Header::tfl_struct_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.tfl_struct_version)
  return static_cast< ::calmcar::perception::Header_TrafficLightStructVersion >(tfl_struct_version_);
}
inline void Header::set_tfl_struct_version(::calmcar::perception::Header_TrafficLightStructVersion value) {
  
  tfl_struct_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.tfl_struct_version)
}

// .calmcar.perception.Header.TrafficLightSpotVersion tfl_spot_version = 7;
inline void Header::clear_tfl_spot_version() {
  tfl_spot_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficLightSpotVersion Header::tfl_spot_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.tfl_spot_version)
  return static_cast< ::calmcar::perception::Header_TrafficLightSpotVersion >(tfl_spot_version_);
}
inline void Header::set_tfl_spot_version(::calmcar::perception::Header_TrafficLightSpotVersion value) {
  
  tfl_spot_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.tfl_spot_version)
}

// .calmcar.perception.Header.TrafficSignVersion traffic_sign_version = 8;
inline void Header::clear_traffic_sign_version() {
  traffic_sign_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficSignVersion Header::traffic_sign_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.traffic_sign_version)
  return static_cast< ::calmcar::perception::Header_TrafficSignVersion >(traffic_sign_version_);
}
inline void Header::set_traffic_sign_version(::calmcar::perception::Header_TrafficSignVersion value) {
  
  traffic_sign_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.traffic_sign_version)
}

// .calmcar.perception.Header.FailSafeVersion fail_safe_version = 9;
inline void Header::clear_fail_safe_version() {
  fail_safe_version_ = 0;
}
inline ::calmcar::perception::Header_FailSafeVersion Header::fail_safe_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.fail_safe_version)
  return static_cast< ::calmcar::perception::Header_FailSafeVersion >(fail_safe_version_);
}
inline void Header::set_fail_safe_version(::calmcar::perception::Header_FailSafeVersion value) {
  
  fail_safe_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.fail_safe_version)
}

// .calmcar.perception.Header.LaneVersion lane_version = 10;
inline void Header::clear_lane_version() {
  lane_version_ = 0;
}
inline ::calmcar::perception::Header_LaneVersion Header::lane_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.lane_version)
  return static_cast< ::calmcar::perception::Header_LaneVersion >(lane_version_);
}
inline void Header::set_lane_version(::calmcar::perception::Header_LaneVersion value) {
  
  lane_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.lane_version)
}

// .calmcar.perception.Header.RoadMarkVersion road_mark_version = 11;
inline void Header::clear_road_mark_version() {
  road_mark_version_ = 0;
}
inline ::calmcar::perception::Header_RoadMarkVersion Header::road_mark_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.road_mark_version)
  return static_cast< ::calmcar::perception::Header_RoadMarkVersion >(road_mark_version_);
}
inline void Header::set_road_mark_version(::calmcar::perception::Header_RoadMarkVersion value) {
  
  road_mark_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.road_mark_version)
}

// .calmcar.perception.Header.FreeSpaceVersion free_space_version = 12;
inline void Header::clear_free_space_version() {
  free_space_version_ = 0;
}
inline ::calmcar::perception::Header_FreeSpaceVersion Header::free_space_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.free_space_version)
  return static_cast< ::calmcar::perception::Header_FreeSpaceVersion >(free_space_version_);
}
inline void Header::set_free_space_version(::calmcar::perception::Header_FreeSpaceVersion value) {
  
  free_space_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.free_space_version)
}

// .calmcar.perception.Header.BarricadeVersion barricade_version = 13;
inline void Header::clear_barricade_version() {
  barricade_version_ = 0;
}
inline ::calmcar::perception::Header_BarricadeVersion Header::barricade_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.barricade_version)
  return static_cast< ::calmcar::perception::Header_BarricadeVersion >(barricade_version_);
}
inline void Header::set_barricade_version(::calmcar::perception::Header_BarricadeVersion value) {
  
  barricade_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.barricade_version)
}

// -------------------------------------------------------------------

// MeasuringStatus

// .calmcar.perception.MeasuringStatus0 measuring_status_0 = 1;
inline void MeasuringStatus::clear_measuring_status_0() {
  measuring_status_0_ = 0;
}
inline ::calmcar::perception::MeasuringStatus0 MeasuringStatus::measuring_status_0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_0)
  return static_cast< ::calmcar::perception::MeasuringStatus0 >(measuring_status_0_);
}
inline void MeasuringStatus::set_measuring_status_0(::calmcar::perception::MeasuringStatus0 value) {
  
  measuring_status_0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_0)
}

// .calmcar.perception.MeasuringStatus1 measuring_status_1 = 2;
inline void MeasuringStatus::clear_measuring_status_1() {
  measuring_status_1_ = 0;
}
inline ::calmcar::perception::MeasuringStatus1 MeasuringStatus::measuring_status_1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_1)
  return static_cast< ::calmcar::perception::MeasuringStatus1 >(measuring_status_1_);
}
inline void MeasuringStatus::set_measuring_status_1(::calmcar::perception::MeasuringStatus1 value) {
  
  measuring_status_1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_1)
}

// .calmcar.perception.MeasuringStatus2 measuring_status_2 = 3;
inline void MeasuringStatus::clear_measuring_status_2() {
  measuring_status_2_ = 0;
}
inline ::calmcar::perception::MeasuringStatus2 MeasuringStatus::measuring_status_2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_2)
  return static_cast< ::calmcar::perception::MeasuringStatus2 >(measuring_status_2_);
}
inline void MeasuringStatus::set_measuring_status_2(::calmcar::perception::MeasuringStatus2 value) {
  
  measuring_status_2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_2)
}

// -------------------------------------------------------------------

// Object

// int64 frame_index = 1;
inline void Object::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.frame_index)
  return frame_index_;
}
inline void Object::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.frame_index)
}

// int64 timestamp = 2;
inline void Object::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.timestamp)
  return timestamp_;
}
inline void Object::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.timestamp)
}

// .calmcar.perception.CameraInfo.Position camera_position = 3;
inline void Object::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position Object::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void Object::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.camera_position)
}

// int64 id = 4;
inline void Object::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.id)
  return id_;
}
inline void Object::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.id)
}

// int64 class_ = 5;
inline void Object::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.class_)
  return class__;
}
inline void Object::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.class_)
}

// string class_name = 6;
inline void Object::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.class_name)
  return class_name_.GetNoArena();
}
inline void Object::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.class_name)
}
#if LANG_CXX11
inline void Object::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Object.class_name)
}
#endif
inline void Object::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Object.class_name)
}
inline void Object::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Object.class_name)
}
inline ::std::string* Object::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.class_name)
}

// int64 subclass = 7;
inline void Object::clear_subclass() {
  subclass_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.subclass)
  return subclass_;
}
inline void Object::set_subclass(::google::protobuf::int64 value) {
  
  subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.subclass)
}

// string subclass_name = 8;
inline void Object::clear_subclass_name() {
  subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.subclass_name)
  return subclass_name_.GetNoArena();
}
inline void Object::set_subclass_name(const ::std::string& value) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.subclass_name)
}
#if LANG_CXX11
inline void Object::set_subclass_name(::std::string&& value) {
  
  subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Object.subclass_name)
}
#endif
inline void Object::set_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Object.subclass_name)
}
inline void Object::set_subclass_name(const char* value, size_t size) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Object.subclass_name)
}
inline ::std::string* Object::mutable_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.subclass_name)
  return subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.subclass_name)
  
  return subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_subclass_name(::std::string* subclass_name) {
  if (subclass_name != NULL) {
    
  } else {
    
  }
  subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.subclass_name)
}

// float confidence = 9;
inline void Object::clear_confidence() {
  confidence_ = 0;
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.confidence)
}

// .calmcar.perception.Rect bbox = 10;
inline bool Object::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& Object::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* Object::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* Object::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.bbox)
  return bbox_;
}
inline void Object::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.bbox)
}

// float length = 11;
inline void Object::clear_length() {
  length_ = 0;
}
inline float Object::length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.length)
  return length_;
}
inline void Object::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.length)
}

// float length_std = 12;
inline void Object::clear_length_std() {
  length_std_ = 0;
}
inline float Object::length_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.length_std)
  return length_std_;
}
inline void Object::set_length_std(float value) {
  
  length_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.length_std)
}

// float width = 13;
inline void Object::clear_width() {
  width_ = 0;
}
inline float Object::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.width)
  return width_;
}
inline void Object::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.width)
}

// float width_std = 14;
inline void Object::clear_width_std() {
  width_std_ = 0;
}
inline float Object::width_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.width_std)
  return width_std_;
}
inline void Object::set_width_std(float value) {
  
  width_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.width_std)
}

// float height = 15;
inline void Object::clear_height() {
  height_ = 0;
}
inline float Object::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.height)
  return height_;
}
inline void Object::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.height)
}

// float height_std = 16;
inline void Object::clear_height_std() {
  height_std_ = 0;
}
inline float Object::height_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.height_std)
  return height_std_;
}
inline void Object::set_height_std(float value) {
  
  height_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.height_std)
}

// int64 age_count = 17;
inline void Object::clear_age_count() {
  age_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::age_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.age_count)
  return age_count_;
}
inline void Object::set_age_count(::google::protobuf::int64 value) {
  
  age_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.age_count)
}

// float age_seconds = 18;
inline void Object::clear_age_seconds() {
  age_seconds_ = 0;
}
inline float Object::age_seconds() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.age_seconds)
  return age_seconds_;
}
inline void Object::set_age_seconds(float value) {
  
  age_seconds_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.age_seconds)
}

// .calmcar.perception.VisibilitySide visibility_side = 19;
inline void Object::clear_visibility_side() {
  visibility_side_ = 0;
}
inline ::calmcar::perception::VisibilitySide Object::visibility_side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.visibility_side)
  return static_cast< ::calmcar::perception::VisibilitySide >(visibility_side_);
}
inline void Object::set_visibility_side(::calmcar::perception::VisibilitySide value) {
  
  visibility_side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.visibility_side)
}

// float lat_distance = 20;
inline void Object::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float Object::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lat_distance)
  return lat_distance_;
}
inline void Object::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lat_distance)
}

// float lat_distance_std = 21;
inline void Object::clear_lat_distance_std() {
  lat_distance_std_ = 0;
}
inline float Object::lat_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lat_distance_std)
  return lat_distance_std_;
}
inline void Object::set_lat_distance_std(float value) {
  
  lat_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lat_distance_std)
}

// float long_distance = 22;
inline void Object::clear_long_distance() {
  long_distance_ = 0;
}
inline float Object::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.long_distance)
  return long_distance_;
}
inline void Object::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.long_distance)
}

// float long_distance_std = 23;
inline void Object::clear_long_distance_std() {
  long_distance_std_ = 0;
}
inline float Object::long_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.long_distance_std)
  return long_distance_std_;
}
inline void Object::set_long_distance_std(float value) {
  
  long_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.long_distance_std)
}

// float relative_lat_velocity = 24;
inline void Object::clear_relative_lat_velocity() {
  relative_lat_velocity_ = 0;
}
inline float Object::relative_lat_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_velocity)
  return relative_lat_velocity_;
}
inline void Object::set_relative_lat_velocity(float value) {
  
  relative_lat_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_velocity)
}

// float relative_lat_velocity_std = 25;
inline void Object::clear_relative_lat_velocity_std() {
  relative_lat_velocity_std_ = 0;
}
inline float Object::relative_lat_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_velocity_std)
  return relative_lat_velocity_std_;
}
inline void Object::set_relative_lat_velocity_std(float value) {
  
  relative_lat_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_velocity_std)
}

// float relative_long_velocity = 26;
inline void Object::clear_relative_long_velocity() {
  relative_long_velocity_ = 0;
}
inline float Object::relative_long_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_velocity)
  return relative_long_velocity_;
}
inline void Object::set_relative_long_velocity(float value) {
  
  relative_long_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_velocity)
}

// float relative_long_velocity_std = 27;
inline void Object::clear_relative_long_velocity_std() {
  relative_long_velocity_std_ = 0;
}
inline float Object::relative_long_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_velocity_std)
  return relative_long_velocity_std_;
}
inline void Object::set_relative_long_velocity_std(float value) {
  
  relative_long_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_velocity_std)
}

// float abs_lat_velocity = 28;
inline void Object::clear_abs_lat_velocity() {
  abs_lat_velocity_ = 0;
}
inline float Object::abs_lat_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_velocity)
  return abs_lat_velocity_;
}
inline void Object::set_abs_lat_velocity(float value) {
  
  abs_lat_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_velocity)
}

// float abs_lat_velocity_std = 29;
inline void Object::clear_abs_lat_velocity_std() {
  abs_lat_velocity_std_ = 0;
}
inline float Object::abs_lat_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_velocity_std)
  return abs_lat_velocity_std_;
}
inline void Object::set_abs_lat_velocity_std(float value) {
  
  abs_lat_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_velocity_std)
}

// float abs_long_velocity = 30;
inline void Object::clear_abs_long_velocity() {
  abs_long_velocity_ = 0;
}
inline float Object::abs_long_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_velocity)
  return abs_long_velocity_;
}
inline void Object::set_abs_long_velocity(float value) {
  
  abs_long_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_velocity)
}

// float abs_long_velocity_std = 31;
inline void Object::clear_abs_long_velocity_std() {
  abs_long_velocity_std_ = 0;
}
inline float Object::abs_long_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_velocity_std)
  return abs_long_velocity_std_;
}
inline void Object::set_abs_long_velocity_std(float value) {
  
  abs_long_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_velocity_std)
}

// float relative_lat_acc = 32;
inline void Object::clear_relative_lat_acc() {
  relative_lat_acc_ = 0;
}
inline float Object::relative_lat_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_acc)
  return relative_lat_acc_;
}
inline void Object::set_relative_lat_acc(float value) {
  
  relative_lat_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_acc)
}

// float relative_lat_acc_std = 33;
inline void Object::clear_relative_lat_acc_std() {
  relative_lat_acc_std_ = 0;
}
inline float Object::relative_lat_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_acc_std)
  return relative_lat_acc_std_;
}
inline void Object::set_relative_lat_acc_std(float value) {
  
  relative_lat_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_acc_std)
}

// float relative_long_acc = 34;
inline void Object::clear_relative_long_acc() {
  relative_long_acc_ = 0;
}
inline float Object::relative_long_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_acc)
  return relative_long_acc_;
}
inline void Object::set_relative_long_acc(float value) {
  
  relative_long_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_acc)
}

// float relative_long_acc_std = 35;
inline void Object::clear_relative_long_acc_std() {
  relative_long_acc_std_ = 0;
}
inline float Object::relative_long_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_acc_std)
  return relative_long_acc_std_;
}
inline void Object::set_relative_long_acc_std(float value) {
  
  relative_long_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_acc_std)
}

// float abs_lat_acc = 36;
inline void Object::clear_abs_lat_acc() {
  abs_lat_acc_ = 0;
}
inline float Object::abs_lat_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_acc)
  return abs_lat_acc_;
}
inline void Object::set_abs_lat_acc(float value) {
  
  abs_lat_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_acc)
}

// float abs_lat_acc_std = 37;
inline void Object::clear_abs_lat_acc_std() {
  abs_lat_acc_std_ = 0;
}
inline float Object::abs_lat_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_acc_std)
  return abs_lat_acc_std_;
}
inline void Object::set_abs_lat_acc_std(float value) {
  
  abs_lat_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_acc_std)
}

// float abs_long_acc = 38;
inline void Object::clear_abs_long_acc() {
  abs_long_acc_ = 0;
}
inline float Object::abs_long_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_acc)
  return abs_long_acc_;
}
inline void Object::set_abs_long_acc(float value) {
  
  abs_long_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_acc)
}

// float abs_long_acc_std = 39;
inline void Object::clear_abs_long_acc_std() {
  abs_long_acc_std_ = 0;
}
inline float Object::abs_long_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_acc_std)
  return abs_long_acc_std_;
}
inline void Object::set_abs_long_acc_std(float value) {
  
  abs_long_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_acc_std)
}

// float abs_speed = 40;
inline void Object::clear_abs_speed() {
  abs_speed_ = 0;
}
inline float Object::abs_speed() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_speed)
  return abs_speed_;
}
inline void Object::set_abs_speed(float value) {
  
  abs_speed_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_speed)
}

// float abs_speed_std = 41;
inline void Object::clear_abs_speed_std() {
  abs_speed_std_ = 0;
}
inline float Object::abs_speed_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_speed_std)
  return abs_speed_std_;
}
inline void Object::set_abs_speed_std(float value) {
  
  abs_speed_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_speed_std)
}

// float abs_acceleration = 42;
inline void Object::clear_abs_acceleration() {
  abs_acceleration_ = 0;
}
inline float Object::abs_acceleration() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_acceleration)
  return abs_acceleration_;
}
inline void Object::set_abs_acceleration(float value) {
  
  abs_acceleration_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_acceleration)
}

// float abs_acceleration_std = 43;
inline void Object::clear_abs_acceleration_std() {
  abs_acceleration_std_ = 0;
}
inline float Object::abs_acceleration_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_acceleration_std)
  return abs_acceleration_std_;
}
inline void Object::set_abs_acceleration_std(float value) {
  
  abs_acceleration_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_acceleration_std)
}

// float heading = 44;
inline void Object::clear_heading() {
  heading_ = 0;
}
inline float Object::heading() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.heading)
  return heading_;
}
inline void Object::set_heading(float value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.heading)
}

// float heading_std = 45;
inline void Object::clear_heading_std() {
  heading_std_ = 0;
}
inline float Object::heading_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.heading_std)
  return heading_std_;
}
inline void Object::set_heading_std(float value) {
  
  heading_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.heading_std)
}

// float inverse_ttc = 46;
inline void Object::clear_inverse_ttc() {
  inverse_ttc_ = 0;
}
inline float Object::inverse_ttc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.inverse_ttc)
  return inverse_ttc_;
}
inline void Object::set_inverse_ttc(float value) {
  
  inverse_ttc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.inverse_ttc)
}

// float inverse_ttc_std = 47;
inline void Object::clear_inverse_ttc_std() {
  inverse_ttc_std_ = 0;
}
inline float Object::inverse_ttc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.inverse_ttc_std)
  return inverse_ttc_std_;
}
inline void Object::set_inverse_ttc_std(float value) {
  
  inverse_ttc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.inverse_ttc_std)
}

// float angle_left = 48;
inline void Object::clear_angle_left() {
  angle_left_ = 0;
}
inline float Object::angle_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_left)
  return angle_left_;
}
inline void Object::set_angle_left(float value) {
  
  angle_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_left)
}

// float angle_right = 49;
inline void Object::clear_angle_right() {
  angle_right_ = 0;
}
inline float Object::angle_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_right)
  return angle_right_;
}
inline void Object::set_angle_right(float value) {
  
  angle_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_right)
}

// float angle_rate = 50;
inline void Object::clear_angle_rate() {
  angle_rate_ = 0;
}
inline float Object::angle_rate() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_rate)
  return angle_rate_;
}
inline void Object::set_angle_rate(float value) {
  
  angle_rate_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_rate)
}

// float angle_side = 51;
inline void Object::clear_angle_side() {
  angle_side_ = 0;
}
inline float Object::angle_side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_side)
  return angle_side_;
}
inline void Object::set_angle_side(float value) {
  
  angle_side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_side)
}

// bool top_out_of_image = 52;
inline void Object::clear_top_out_of_image() {
  top_out_of_image_ = false;
}
inline bool Object::top_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.top_out_of_image)
  return top_out_of_image_;
}
inline void Object::set_top_out_of_image(bool value) {
  
  top_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.top_out_of_image)
}

// bool bottom_out_of_image = 53;
inline void Object::clear_bottom_out_of_image() {
  bottom_out_of_image_ = false;
}
inline bool Object::bottom_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.bottom_out_of_image)
  return bottom_out_of_image_;
}
inline void Object::set_bottom_out_of_image(bool value) {
  
  bottom_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.bottom_out_of_image)
}

// bool left_out_of_image = 54;
inline void Object::clear_left_out_of_image() {
  left_out_of_image_ = false;
}
inline bool Object::left_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.left_out_of_image)
  return left_out_of_image_;
}
inline void Object::set_left_out_of_image(bool value) {
  
  left_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.left_out_of_image)
}

// bool right_out_of_image = 55;
inline void Object::clear_right_out_of_image() {
  right_out_of_image_ = false;
}
inline bool Object::right_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.right_out_of_image)
  return right_out_of_image_;
}
inline void Object::set_right_out_of_image(bool value) {
  
  right_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.right_out_of_image)
}

// bool brake_light = 56;
inline void Object::clear_brake_light() {
  brake_light_ = false;
}
inline bool Object::brake_light() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.brake_light)
  return brake_light_;
}
inline void Object::set_brake_light(bool value) {
  
  brake_light_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.brake_light)
}

// bool turn_indicator_left = 57;
inline void Object::clear_turn_indicator_left() {
  turn_indicator_left_ = false;
}
inline bool Object::turn_indicator_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.turn_indicator_left)
  return turn_indicator_left_;
}
inline void Object::set_turn_indicator_left(bool value) {
  
  turn_indicator_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.turn_indicator_left)
}

// bool turn_indicator_right = 58;
inline void Object::clear_turn_indicator_right() {
  turn_indicator_right_ = false;
}
inline bool Object::turn_indicator_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.turn_indicator_right)
  return turn_indicator_right_;
}
inline void Object::set_turn_indicator_right(bool value) {
  
  turn_indicator_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.turn_indicator_right)
}

// .calmcar.perception.MeasuringStatus measuring_status = 59;
inline bool Object::has_measuring_status() const {
  return this != internal_default_instance() && measuring_status_ != NULL;
}
inline void Object::clear_measuring_status() {
  if (GetArenaNoVirtual() == NULL && measuring_status_ != NULL) {
    delete measuring_status_;
  }
  measuring_status_ = NULL;
}
inline const ::calmcar::perception::MeasuringStatus& Object::measuring_status() const {
  const ::calmcar::perception::MeasuringStatus* p = measuring_status_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.measuring_status)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::MeasuringStatus*>(
      &::calmcar::perception::_MeasuringStatus_default_instance_);
}
inline ::calmcar::perception::MeasuringStatus* Object::release_measuring_status() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.measuring_status)
  
  ::calmcar::perception::MeasuringStatus* temp = measuring_status_;
  measuring_status_ = NULL;
  return temp;
}
inline ::calmcar::perception::MeasuringStatus* Object::mutable_measuring_status() {
  
  if (measuring_status_ == NULL) {
    measuring_status_ = new ::calmcar::perception::MeasuringStatus;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.measuring_status)
  return measuring_status_;
}
inline void Object::set_allocated_measuring_status(::calmcar::perception::MeasuringStatus* measuring_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete measuring_status_;
  }
  if (measuring_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      measuring_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, measuring_status, submessage_arena);
    }
    
  } else {
    
  }
  measuring_status_ = measuring_status;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.measuring_status)
}

// .calmcar.perception.MotionOrientation motion_orientation = 60;
inline void Object::clear_motion_orientation() {
  motion_orientation_ = 0;
}
inline ::calmcar::perception::MotionOrientation Object::motion_orientation() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_orientation)
  return static_cast< ::calmcar::perception::MotionOrientation >(motion_orientation_);
}
inline void Object::set_motion_orientation(::calmcar::perception::MotionOrientation value) {
  
  motion_orientation_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_orientation)
}

// .calmcar.perception.MotionCategory motion_category = 61;
inline void Object::clear_motion_category() {
  motion_category_ = 0;
}
inline ::calmcar::perception::MotionCategory Object::motion_category() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_category)
  return static_cast< ::calmcar::perception::MotionCategory >(motion_category_);
}
inline void Object::set_motion_category(::calmcar::perception::MotionCategory value) {
  
  motion_category_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_category)
}

// .calmcar.perception.MotionStatusV2 motion_status = 62;
inline void Object::clear_motion_status() {
  motion_status_ = 0;
}
inline ::calmcar::perception::MotionStatusV2 Object::motion_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_status)
  return static_cast< ::calmcar::perception::MotionStatusV2 >(motion_status_);
}
inline void Object::set_motion_status(::calmcar::perception::MotionStatusV2 value) {
  
  motion_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_status)
}

// .calmcar.perception.CutInCutOut cutin_cutout = 63;
inline void Object::clear_cutin_cutout() {
  cutin_cutout_ = 0;
}
inline ::calmcar::perception::CutInCutOut Object::cutin_cutout() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.cutin_cutout)
  return static_cast< ::calmcar::perception::CutInCutOut >(cutin_cutout_);
}
inline void Object::set_cutin_cutout(::calmcar::perception::CutInCutOut value) {
  
  cutin_cutout_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.cutin_cutout)
}

// int32 lane_assignment = 64;
inline void Object::clear_lane_assignment() {
  lane_assignment_ = 0;
}
inline ::google::protobuf::int32 Object::lane_assignment() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lane_assignment)
  return lane_assignment_;
}
inline void Object::set_lane_assignment(::google::protobuf::int32 value) {
  
  lane_assignment_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lane_assignment)
}

// bool lane_assignment_v = 65;
inline void Object::clear_lane_assignment_v() {
  lane_assignment_v_ = false;
}
inline bool Object::lane_assignment_v() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lane_assignment_v)
  return lane_assignment_v_;
}
inline void Object::set_lane_assignment_v(bool value) {
  
  lane_assignment_v_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lane_assignment_v)
}

// bool is_bev_object = 66;
inline void Object::clear_is_bev_object() {
  is_bev_object_ = false;
}
inline bool Object::is_bev_object() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.is_bev_object)
  return is_bev_object_;
}
inline void Object::set_is_bev_object(bool value) {
  
  is_bev_object_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.is_bev_object)
}

// -------------------------------------------------------------------

// TrafficLightSpot

// .calmcar.perception.TrafficLightSpot.Color color = 1;
inline void TrafficLightSpot::clear_color() {
  color_ = 0;
}
inline ::calmcar::perception::TrafficLightSpot_Color TrafficLightSpot::color() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLightSpot.color)
  return static_cast< ::calmcar::perception::TrafficLightSpot_Color >(color_);
}
inline void TrafficLightSpot::set_color(::calmcar::perception::TrafficLightSpot_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLightSpot.color)
}

// float color_confidence = 2;
inline void TrafficLightSpot::clear_color_confidence() {
  color_confidence_ = 0;
}
inline float TrafficLightSpot::color_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLightSpot.color_confidence)
  return color_confidence_;
}
inline void TrafficLightSpot::set_color_confidence(float value) {
  
  color_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLightSpot.color_confidence)
}

// .calmcar.perception.TrafficLightSpot.Type type = 3;
inline void TrafficLightSpot::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::TrafficLightSpot_Type TrafficLightSpot::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLightSpot.type)
  return static_cast< ::calmcar::perception::TrafficLightSpot_Type >(type_);
}
inline void TrafficLightSpot::set_type(::calmcar::perception::TrafficLightSpot_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLightSpot.type)
}

// float dir_confidence = 4;
inline void TrafficLightSpot::clear_dir_confidence() {
  dir_confidence_ = 0;
}
inline float TrafficLightSpot::dir_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLightSpot.dir_confidence)
  return dir_confidence_;
}
inline void TrafficLightSpot::set_dir_confidence(float value) {
  
  dir_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLightSpot.dir_confidence)
}

// .calmcar.perception.Rect bbox = 5;
inline bool TrafficLightSpot::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficLightSpot::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLightSpot.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficLightSpot::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficLightSpot.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficLightSpot::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLightSpot.bbox)
  return bbox_;
}
inline void TrafficLightSpot::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficLightSpot.bbox)
}

// -------------------------------------------------------------------

// TrafficLight

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void TrafficLight::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position TrafficLight::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void TrafficLight::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.camera_position)
}

// int64 timestamp = 2;
inline void TrafficLight::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.timestamp)
  return timestamp_;
}
inline void TrafficLight::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.timestamp)
}

// int64 struct_id = 3;
inline void TrafficLight::clear_struct_id() {
  struct_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::struct_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.struct_id)
  return struct_id_;
}
inline void TrafficLight::set_struct_id(::google::protobuf::int64 value) {
  
  struct_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.struct_id)
}

// int64 spot_id = 4;
inline void TrafficLight::clear_spot_id() {
  spot_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::spot_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.spot_id)
  return spot_id_;
}
inline void TrafficLight::set_spot_id(::google::protobuf::int64 value) {
  
  spot_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.spot_id)
}

// int64 class_ = 5;
inline void TrafficLight::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.class_)
  return class__;
}
inline void TrafficLight::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.class_)
}

// string class_name = 6;
inline void TrafficLight::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficLight::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.class_name)
  return class_name_.GetNoArena();
}
inline void TrafficLight::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.class_name)
}
#if LANG_CXX11
inline void TrafficLight::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficLight.class_name)
}
#endif
inline void TrafficLight::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficLight.class_name)
}
inline void TrafficLight::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficLight.class_name)
}
inline ::std::string* TrafficLight::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLight.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLight::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficLight.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLight::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficLight.class_name)
}

// int64 tracking_age = 7;
inline void TrafficLight::clear_tracking_age() {
  tracking_age_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::tracking_age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.tracking_age)
  return tracking_age_;
}
inline void TrafficLight::set_tracking_age(::google::protobuf::int64 value) {
  
  tracking_age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.tracking_age)
}

// .calmcar.perception.Rect bbox = 8;
inline bool TrafficLight::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficLight::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficLight::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficLight.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficLight::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLight.bbox)
  return bbox_;
}
inline void TrafficLight::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficLight.bbox)
}

// float height = 9;
inline void TrafficLight::clear_height() {
  height_ = 0;
}
inline float TrafficLight::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.height)
  return height_;
}
inline void TrafficLight::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.height)
}

// float width = 10;
inline void TrafficLight::clear_width() {
  width_ = 0;
}
inline float TrafficLight::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.width)
  return width_;
}
inline void TrafficLight::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.width)
}

// float lat_distance = 11;
inline void TrafficLight::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficLight::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.lat_distance)
  return lat_distance_;
}
inline void TrafficLight::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.lat_distance)
}

// float lat_distance_std = 12;
inline void TrafficLight::clear_lat_distance_std() {
  lat_distance_std_ = 0;
}
inline float TrafficLight::lat_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.lat_distance_std)
  return lat_distance_std_;
}
inline void TrafficLight::set_lat_distance_std(float value) {
  
  lat_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.lat_distance_std)
}

// float long_distance = 13;
inline void TrafficLight::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficLight::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.long_distance)
  return long_distance_;
}
inline void TrafficLight::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.long_distance)
}

// float long_distance_std = 14;
inline void TrafficLight::clear_long_distance_std() {
  long_distance_std_ = 0;
}
inline float TrafficLight::long_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.long_distance_std)
  return long_distance_std_;
}
inline void TrafficLight::set_long_distance_std(float value) {
  
  long_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.long_distance_std)
}

// float rel_height = 15;
inline void TrafficLight::clear_rel_height() {
  rel_height_ = 0;
}
inline float TrafficLight::rel_height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.rel_height)
  return rel_height_;
}
inline void TrafficLight::set_rel_height(float value) {
  
  rel_height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.rel_height)
}

// float rel_height_std = 16;
inline void TrafficLight::clear_rel_height_std() {
  rel_height_std_ = 0;
}
inline float TrafficLight::rel_height_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.rel_height_std)
  return rel_height_std_;
}
inline void TrafficLight::set_rel_height_std(float value) {
  
  rel_height_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.rel_height_std)
}

// .calmcar.perception.TrafficLight.Color color = 17;
inline void TrafficLight::clear_color() {
  color_ = 0;
}
inline ::calmcar::perception::TrafficLight_Color TrafficLight::color() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.color)
  return static_cast< ::calmcar::perception::TrafficLight_Color >(color_);
}
inline void TrafficLight::set_color(::calmcar::perception::TrafficLight_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.color)
}

// float color_confidence = 18;
inline void TrafficLight::clear_color_confidence() {
  color_confidence_ = 0;
}
inline float TrafficLight::color_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.color_confidence)
  return color_confidence_;
}
inline void TrafficLight::set_color_confidence(float value) {
  
  color_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.color_confidence)
}

// .calmcar.perception.TrafficLight.Type type = 19;
inline void TrafficLight::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::TrafficLight_Type TrafficLight::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.type)
  return static_cast< ::calmcar::perception::TrafficLight_Type >(type_);
}
inline void TrafficLight::set_type(::calmcar::perception::TrafficLight_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.type)
}

// float type_confidence = 20;
inline void TrafficLight::clear_type_confidence() {
  type_confidence_ = 0;
}
inline float TrafficLight::type_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.type_confidence)
  return type_confidence_;
}
inline void TrafficLight::set_type_confidence(float value) {
  
  type_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.type_confidence)
}

// .calmcar.perception.TrafficLight.Mode mode = 21;
inline void TrafficLight::clear_mode() {
  mode_ = 0;
}
inline ::calmcar::perception::TrafficLight_Mode TrafficLight::mode() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.mode)
  return static_cast< ::calmcar::perception::TrafficLight_Mode >(mode_);
}
inline void TrafficLight::set_mode(::calmcar::perception::TrafficLight_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.mode)
}

// repeated .calmcar.perception.TrafficLightSpot spots = 22;
inline int TrafficLight::spots_size() const {
  return spots_.size();
}
inline void TrafficLight::clear_spots() {
  spots_.Clear();
}
inline const ::calmcar::perception::TrafficLightSpot& TrafficLight::spots(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.spots)
  return spots_.Get(index);
}
inline ::calmcar::perception::TrafficLightSpot* TrafficLight::mutable_spots(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLight.spots)
  return spots_.Mutable(index);
}
inline ::calmcar::perception::TrafficLightSpot* TrafficLight::add_spots() {
  // @@protoc_insertion_point(field_add:calmcar.perception.TrafficLight.spots)
  return spots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLightSpot >*
TrafficLight::mutable_spots() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.TrafficLight.spots)
  return &spots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLightSpot >&
TrafficLight::spots() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.TrafficLight.spots)
  return spots_;
}

// -------------------------------------------------------------------

// TrafficSign

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void TrafficSign::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position TrafficSign::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void TrafficSign::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.camera_position)
}

// int64 timestamp = 2;
inline void TrafficSign::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.timestamp)
  return timestamp_;
}
inline void TrafficSign::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.timestamp)
}

// int64 id = 3;
inline void TrafficSign::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.id)
  return id_;
}
inline void TrafficSign::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.id)
}

// int64 class_ = 4;
inline void TrafficSign::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.class_)
  return class__;
}
inline void TrafficSign::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.class_)
}

// int64 subclass = 5;
inline void TrafficSign::clear_subclass() {
  subclass_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.subclass)
  return subclass_;
}
inline void TrafficSign::set_subclass(::google::protobuf::int64 value) {
  
  subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.subclass)
}

// string class_name = 6;
inline void TrafficSign::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficSign::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.class_name)
  return class_name_.GetNoArena();
}
inline void TrafficSign::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.class_name)
}
#if LANG_CXX11
inline void TrafficSign::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficSign.class_name)
}
#endif
inline void TrafficSign::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficSign.class_name)
}
inline void TrafficSign::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficSign.class_name)
}
inline ::std::string* TrafficSign::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficSign::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.class_name)
}

// string subclass_name = 7;
inline void TrafficSign::clear_subclass_name() {
  subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficSign::subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.subclass_name)
  return subclass_name_.GetNoArena();
}
inline void TrafficSign::set_subclass_name(const ::std::string& value) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.subclass_name)
}
#if LANG_CXX11
inline void TrafficSign::set_subclass_name(::std::string&& value) {
  
  subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficSign.subclass_name)
}
#endif
inline void TrafficSign::set_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficSign.subclass_name)
}
inline void TrafficSign::set_subclass_name(const char* value, size_t size) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficSign.subclass_name)
}
inline ::std::string* TrafficSign::mutable_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.subclass_name)
  return subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficSign::release_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.subclass_name)
  
  return subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign::set_allocated_subclass_name(::std::string* subclass_name) {
  if (subclass_name != NULL) {
    
  } else {
    
  }
  subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.subclass_name)
}

// .calmcar.perception.Rect bbox = 8;
inline bool TrafficSign::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficSign::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficSign::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficSign::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.bbox)
  return bbox_;
}
inline void TrafficSign::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.bbox)
}

// float height = 9;
inline void TrafficSign::clear_height() {
  height_ = 0;
}
inline float TrafficSign::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.height)
  return height_;
}
inline void TrafficSign::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.height)
}

// float width = 10;
inline void TrafficSign::clear_width() {
  width_ = 0;
}
inline float TrafficSign::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.width)
  return width_;
}
inline void TrafficSign::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.width)
}

// float lat_distance = 11;
inline void TrafficSign::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficSign::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.lat_distance)
  return lat_distance_;
}
inline void TrafficSign::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.lat_distance)
}

// float long_distance = 12;
inline void TrafficSign::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficSign::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.long_distance)
  return long_distance_;
}
inline void TrafficSign::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.long_distance)
}

// int64 tracking_age = 13;
inline void TrafficSign::clear_tracking_age() {
  tracking_age_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::tracking_age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.tracking_age)
  return tracking_age_;
}
inline void TrafficSign::set_tracking_age(::google::protobuf::int64 value) {
  
  tracking_age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.tracking_age)
}

// .calmcar.perception.TrafficSign.TrafficSIgnRelevancy relevance = 14;
inline void TrafficSign::clear_relevance() {
  relevance_ = 0;
}
inline ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy TrafficSign::relevance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.relevance)
  return static_cast< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy >(relevance_);
}
inline void TrafficSign::set_relevance(::calmcar::perception::TrafficSign_TrafficSIgnRelevancy value) {
  
  relevance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.relevance)
}

// -------------------------------------------------------------------

// TrafficSignType

// .calmcar.perception.TrafficSignType.Type type = 1;
inline void TrafficSignType::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::TrafficSignType_Type TrafficSignType::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignType.type)
  return static_cast< ::calmcar::perception::TrafficSignType_Type >(type_);
}
inline void TrafficSignType::set_type(::calmcar::perception::TrafficSignType_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignType.type)
}

// .google.protobuf.Int32Value sign = 2;
inline bool TrafficSignType::has_sign() const {
  return this != internal_default_instance() && sign_ != NULL;
}
inline const ::google::protobuf::Int32Value& TrafficSignType::sign() const {
  const ::google::protobuf::Int32Value* p = sign_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignType.sign)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* TrafficSignType::release_sign() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignType.sign)
  
  ::google::protobuf::Int32Value* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* TrafficSignType::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::google::protobuf::Int32Value;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignType.sign)
  return sign_;
}
inline void TrafficSignType::set_allocated_sign(::google::protobuf::Int32Value* sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sign_);
  }
  if (sign) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(sign)->GetArena();
    if (message_arena != submessage_arena) {
      sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignType.sign)
}

// -------------------------------------------------------------------

// TrafficSignStatus

// .calmcar.perception.TrafficSignType sign = 1;
inline bool TrafficSignStatus::has_sign() const {
  return this != internal_default_instance() && sign_ != NULL;
}
inline void TrafficSignStatus::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) {
    delete sign_;
  }
  sign_ = NULL;
}
inline const ::calmcar::perception::TrafficSignType& TrafficSignStatus::sign() const {
  const ::calmcar::perception::TrafficSignType* p = sign_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.sign)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::TrafficSignType*>(
      &::calmcar::perception::_TrafficSignType_default_instance_);
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::release_sign() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.sign)
  
  ::calmcar::perception::TrafficSignType* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::mutable_sign() {
  
  if (sign_ == NULL) {
    sign_ = new ::calmcar::perception::TrafficSignType;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.sign)
  return sign_;
}
inline void TrafficSignStatus::set_allocated_sign(::calmcar::perception::TrafficSignType* sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sign_;
  }
  if (sign) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.sign)
}

// repeated .calmcar.perception.TrafficSignType derived_signs = 2;
inline int TrafficSignStatus::derived_signs_size() const {
  return derived_signs_.size();
}
inline void TrafficSignStatus::clear_derived_signs() {
  derived_signs_.Clear();
}
inline const ::calmcar::perception::TrafficSignType& TrafficSignStatus::derived_signs(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Get(index);
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::mutable_derived_signs(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Mutable(index);
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::add_derived_signs() {
  // @@protoc_insertion_point(field_add:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >*
TrafficSignStatus::mutable_derived_signs() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.TrafficSignStatus.derived_signs)
  return &derived_signs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >&
TrafficSignStatus::derived_signs() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_;
}

// .calmcar.perception.Rect bbox = 3;
inline bool TrafficSignStatus::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficSignStatus::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficSignStatus::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficSignStatus::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.bbox)
  return bbox_;
}
inline void TrafficSignStatus::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.bbox)
}

// float lat_distance = 4;
inline void TrafficSignStatus::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficSignStatus::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.lat_distance)
  return lat_distance_;
}
inline void TrafficSignStatus::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.lat_distance)
}

// float long_distance = 5;
inline void TrafficSignStatus::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficSignStatus::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.long_distance)
  return long_distance_;
}
inline void TrafficSignStatus::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.long_distance)
}

// float panel_width = 6;
inline void TrafficSignStatus::clear_panel_width() {
  panel_width_ = 0;
}
inline float TrafficSignStatus::panel_width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.panel_width)
  return panel_width_;
}
inline void TrafficSignStatus::set_panel_width(float value) {
  
  panel_width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.panel_width)
}

// float panel_height = 7;
inline void TrafficSignStatus::clear_panel_height() {
  panel_height_ = 0;
}
inline float TrafficSignStatus::panel_height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.panel_height)
  return panel_height_;
}
inline void TrafficSignStatus::set_panel_height(float value) {
  
  panel_height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.panel_height)
}

// float height = 8;
inline void TrafficSignStatus::clear_height() {
  height_ = 0;
}
inline float TrafficSignStatus::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.height)
  return height_;
}
inline void TrafficSignStatus::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.height)
}

// .google.protobuf.FloatValue speed_limit = 9;
inline bool TrafficSignStatus::has_speed_limit() const {
  return this != internal_default_instance() && speed_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::speed_limit() const {
  const ::google::protobuf::FloatValue* p = speed_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.speed_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_speed_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.speed_limit)
  
  ::google::protobuf::FloatValue* temp = speed_limit_;
  speed_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_speed_limit() {
  
  if (speed_limit_ == NULL) {
    speed_limit_ = new ::google::protobuf::FloatValue;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.speed_limit)
  return speed_limit_;
}
inline void TrafficSignStatus::set_allocated_speed_limit(::google::protobuf::FloatValue* speed_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(speed_limit_);
  }
  if (speed_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(speed_limit)->GetArena();
    if (message_arena != submessage_arena) {
      speed_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  speed_limit_ = speed_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.speed_limit)
}

// .google.protobuf.FloatValue height_limit = 10;
inline bool TrafficSignStatus::has_height_limit() const {
  return this != internal_default_instance() && height_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::height_limit() const {
  const ::google::protobuf::FloatValue* p = height_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.height_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_height_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.height_limit)
  
  ::google::protobuf::FloatValue* temp = height_limit_;
  height_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_height_limit() {
  
  if (height_limit_ == NULL) {
    height_limit_ = new ::google::protobuf::FloatValue;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.height_limit)
  return height_limit_;
}
inline void TrafficSignStatus::set_allocated_height_limit(::google::protobuf::FloatValue* height_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_limit_);
  }
  if (height_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(height_limit)->GetArena();
    if (message_arena != submessage_arena) {
      height_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_limit, submessage_arena);
    }
    
  } else {
    
  }
  height_limit_ = height_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.height_limit)
}

// .google.protobuf.FloatValue weight_limit = 11;
inline bool TrafficSignStatus::has_weight_limit() const {
  return this != internal_default_instance() && weight_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::weight_limit() const {
  const ::google::protobuf::FloatValue* p = weight_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.weight_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_weight_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.weight_limit)
  
  ::google::protobuf::FloatValue* temp = weight_limit_;
  weight_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_weight_limit() {
  
  if (weight_limit_ == NULL) {
    weight_limit_ = new ::google::protobuf::FloatValue;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.weight_limit)
  return weight_limit_;
}
inline void TrafficSignStatus::set_allocated_weight_limit(::google::protobuf::FloatValue* weight_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(weight_limit_);
  }
  if (weight_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(weight_limit)->GetArena();
    if (message_arena != submessage_arena) {
      weight_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, weight_limit, submessage_arena);
    }
    
  } else {
    
  }
  weight_limit_ = weight_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.weight_limit)
}

// -------------------------------------------------------------------

// AebObject

// int64 id = 1;
inline void AebObject::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AebObject::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.id)
  return id_;
}
inline void AebObject::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.id)
}

// int32 appear_count = 2;
inline void AebObject::clear_appear_count() {
  appear_count_ = 0;
}
inline ::google::protobuf::int32 AebObject::appear_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.appear_count)
  return appear_count_;
}
inline void AebObject::set_appear_count(::google::protobuf::int32 value) {
  
  appear_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.appear_count)
}

// uint64 type = 3;
inline void AebObject::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AebObject::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.type)
  return type_;
}
inline void AebObject::set_type(::google::protobuf::uint64 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.type)
}

// float width = 4;
inline void AebObject::clear_width() {
  width_ = 0;
}
inline float AebObject::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.width)
  return width_;
}
inline void AebObject::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.width)
}

// float length = 5;
inline void AebObject::clear_length() {
  length_ = 0;
}
inline float AebObject::length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.length)
  return length_;
}
inline void AebObject::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.length)
}

// float speed_x = 6;
inline void AebObject::clear_speed_x() {
  speed_x_ = 0;
}
inline float AebObject::speed_x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.speed_x)
  return speed_x_;
}
inline void AebObject::set_speed_x(float value) {
  
  speed_x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.speed_x)
}

// float speed_y = 7;
inline void AebObject::clear_speed_y() {
  speed_y_ = 0;
}
inline float AebObject::speed_y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.speed_y)
  return speed_y_;
}
inline void AebObject::set_speed_y(float value) {
  
  speed_y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.speed_y)
}

// float cur_distance_x = 8;
inline void AebObject::clear_cur_distance_x() {
  cur_distance_x_ = 0;
}
inline float AebObject::cur_distance_x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.cur_distance_x)
  return cur_distance_x_;
}
inline void AebObject::set_cur_distance_x(float value) {
  
  cur_distance_x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.cur_distance_x)
}

// float cur_distance_y = 9;
inline void AebObject::clear_cur_distance_y() {
  cur_distance_y_ = 0;
}
inline float AebObject::cur_distance_y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.cur_distance_y)
  return cur_distance_y_;
}
inline void AebObject::set_cur_distance_y(float value) {
  
  cur_distance_y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.cur_distance_y)
}

// repeated float last_1s_x = 10;
inline int AebObject::last_1s_x_size() const {
  return last_1s_x_.size();
}
inline void AebObject::clear_last_1s_x() {
  last_1s_x_.Clear();
}
inline float AebObject::last_1s_x(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.last_1s_x)
  return last_1s_x_.Get(index);
}
inline void AebObject::set_last_1s_x(int index, float value) {
  last_1s_x_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.last_1s_x)
}
inline void AebObject::add_last_1s_x(float value) {
  last_1s_x_.Add(value);
  // @@protoc_insertion_point(field_add:calmcar.perception.AebObject.last_1s_x)
}
inline const ::google::protobuf::RepeatedField< float >&
AebObject::last_1s_x() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebObject.last_1s_x)
  return last_1s_x_;
}
inline ::google::protobuf::RepeatedField< float >*
AebObject::mutable_last_1s_x() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebObject.last_1s_x)
  return &last_1s_x_;
}

// repeated float last_1s_y = 11;
inline int AebObject::last_1s_y_size() const {
  return last_1s_y_.size();
}
inline void AebObject::clear_last_1s_y() {
  last_1s_y_.Clear();
}
inline float AebObject::last_1s_y(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.last_1s_y)
  return last_1s_y_.Get(index);
}
inline void AebObject::set_last_1s_y(int index, float value) {
  last_1s_y_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.last_1s_y)
}
inline void AebObject::add_last_1s_y(float value) {
  last_1s_y_.Add(value);
  // @@protoc_insertion_point(field_add:calmcar.perception.AebObject.last_1s_y)
}
inline const ::google::protobuf::RepeatedField< float >&
AebObject::last_1s_y() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebObject.last_1s_y)
  return last_1s_y_;
}
inline ::google::protobuf::RepeatedField< float >*
AebObject::mutable_last_1s_y() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebObject.last_1s_y)
  return &last_1s_y_;
}

// repeated float last_1s_heading = 12;
inline int AebObject::last_1s_heading_size() const {
  return last_1s_heading_.size();
}
inline void AebObject::clear_last_1s_heading() {
  last_1s_heading_.Clear();
}
inline float AebObject::last_1s_heading(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.last_1s_heading)
  return last_1s_heading_.Get(index);
}
inline void AebObject::set_last_1s_heading(int index, float value) {
  last_1s_heading_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.last_1s_heading)
}
inline void AebObject::add_last_1s_heading(float value) {
  last_1s_heading_.Add(value);
  // @@protoc_insertion_point(field_add:calmcar.perception.AebObject.last_1s_heading)
}
inline const ::google::protobuf::RepeatedField< float >&
AebObject::last_1s_heading() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebObject.last_1s_heading)
  return last_1s_heading_;
}
inline ::google::protobuf::RepeatedField< float >*
AebObject::mutable_last_1s_heading() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebObject.last_1s_heading)
  return &last_1s_heading_;
}

// repeated int32 last_record_counter = 13;
inline int AebObject::last_record_counter_size() const {
  return last_record_counter_.size();
}
inline void AebObject::clear_last_record_counter() {
  last_record_counter_.Clear();
}
inline ::google::protobuf::int32 AebObject::last_record_counter(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.last_record_counter)
  return last_record_counter_.Get(index);
}
inline void AebObject::set_last_record_counter(int index, ::google::protobuf::int32 value) {
  last_record_counter_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.last_record_counter)
}
inline void AebObject::add_last_record_counter(::google::protobuf::int32 value) {
  last_record_counter_.Add(value);
  // @@protoc_insertion_point(field_add:calmcar.perception.AebObject.last_record_counter)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AebObject::last_record_counter() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebObject.last_record_counter)
  return last_record_counter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AebObject::mutable_last_record_counter() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebObject.last_record_counter)
  return &last_record_counter_;
}

// .calmcar.perception.AebFollowObjectState state = 14;
inline void AebObject::clear_state() {
  state_ = 0;
}
inline ::calmcar::perception::AebFollowObjectState AebObject::state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebObject.state)
  return static_cast< ::calmcar::perception::AebFollowObjectState >(state_);
}
inline void AebObject::set_state(::calmcar::perception::AebFollowObjectState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebObject.state)
}

// -------------------------------------------------------------------

// VehiclePredictPoint

// float x = 1;
inline void VehiclePredictPoint::clear_x() {
  x_ = 0;
}
inline float VehiclePredictPoint::x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.VehiclePredictPoint.x)
  return x_;
}
inline void VehiclePredictPoint::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.VehiclePredictPoint.x)
}

// float y = 2;
inline void VehiclePredictPoint::clear_y() {
  y_ = 0;
}
inline float VehiclePredictPoint::y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.VehiclePredictPoint.y)
  return y_;
}
inline void VehiclePredictPoint::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.VehiclePredictPoint.y)
}

// float t = 3;
inline void VehiclePredictPoint::clear_t() {
  t_ = 0;
}
inline float VehiclePredictPoint::t() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.VehiclePredictPoint.t)
  return t_;
}
inline void VehiclePredictPoint::set_t(float value) {
  
  t_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.VehiclePredictPoint.t)
}

// .calmcar.perception.AebFollowObjectState status = 4;
inline void VehiclePredictPoint::clear_status() {
  status_ = 0;
}
inline ::calmcar::perception::AebFollowObjectState VehiclePredictPoint::status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.VehiclePredictPoint.status)
  return static_cast< ::calmcar::perception::AebFollowObjectState >(status_);
}
inline void VehiclePredictPoint::set_status(::calmcar::perception::AebFollowObjectState value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.VehiclePredictPoint.status)
}

// -------------------------------------------------------------------

// Vehicle_State

// float vehicle_spd = 1;
inline void Vehicle_State::clear_vehicle_spd() {
  vehicle_spd_ = 0;
}
inline float Vehicle_State::vehicle_spd() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.vehicle_spd)
  return vehicle_spd_;
}
inline void Vehicle_State::set_vehicle_spd(float value) {
  
  vehicle_spd_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.vehicle_spd)
}

// float vehicle_yaw_rate = 2;
inline void Vehicle_State::clear_vehicle_yaw_rate() {
  vehicle_yaw_rate_ = 0;
}
inline float Vehicle_State::vehicle_yaw_rate() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.vehicle_yaw_rate)
  return vehicle_yaw_rate_;
}
inline void Vehicle_State::set_vehicle_yaw_rate(float value) {
  
  vehicle_yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.vehicle_yaw_rate)
}

// float lateral_acce = 3;
inline void Vehicle_State::clear_lateral_acce() {
  lateral_acce_ = 0;
}
inline float Vehicle_State::lateral_acce() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.lateral_acce)
  return lateral_acce_;
}
inline void Vehicle_State::set_lateral_acce(float value) {
  
  lateral_acce_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.lateral_acce)
}

// float longitude_acce = 4;
inline void Vehicle_State::clear_longitude_acce() {
  longitude_acce_ = 0;
}
inline float Vehicle_State::longitude_acce() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.longitude_acce)
  return longitude_acce_;
}
inline void Vehicle_State::set_longitude_acce(float value) {
  
  longitude_acce_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.longitude_acce)
}

// bool throttle_report_driver = 5;
inline void Vehicle_State::clear_throttle_report_driver() {
  throttle_report_driver_ = false;
}
inline bool Vehicle_State::throttle_report_driver() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.throttle_report_driver)
  return throttle_report_driver_;
}
inline void Vehicle_State::set_throttle_report_driver(bool value) {
  
  throttle_report_driver_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.throttle_report_driver)
}

// float steering_torque_nm = 6;
inline void Vehicle_State::clear_steering_torque_nm() {
  steering_torque_nm_ = 0;
}
inline float Vehicle_State::steering_torque_nm() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.steering_torque_nm)
  return steering_torque_nm_;
}
inline void Vehicle_State::set_steering_torque_nm(float value) {
  
  steering_torque_nm_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.steering_torque_nm)
}

// float steer_angle = 7;
inline void Vehicle_State::clear_steer_angle() {
  steer_angle_ = 0;
}
inline float Vehicle_State::steer_angle() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_State.steer_angle)
  return steer_angle_;
}
inline void Vehicle_State::set_steer_angle(float value) {
  
  steer_angle_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Vehicle_State.steer_angle)
}

// -------------------------------------------------------------------

// Signal_Input

// bool FCW_Enable = 1;
inline void Signal_Input::clear_fcw_enable() {
  fcw_enable_ = false;
}
inline bool Signal_Input::fcw_enable() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.FCW_Enable)
  return fcw_enable_;
}
inline void Signal_Input::set_fcw_enable(bool value) {
  
  fcw_enable_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.FCW_Enable)
}

// bool AEB_Enable = 2;
inline void Signal_Input::clear_aeb_enable() {
  aeb_enable_ = false;
}
inline bool Signal_Input::aeb_enable() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.AEB_Enable)
  return aeb_enable_;
}
inline void Signal_Input::set_aeb_enable(bool value) {
  
  aeb_enable_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.AEB_Enable)
}

// uint32 FCWSensitiveLevel = 3;
inline void Signal_Input::clear_fcwsensitivelevel() {
  fcwsensitivelevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Input::fcwsensitivelevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.FCWSensitiveLevel)
  return fcwsensitivelevel_;
}
inline void Signal_Input::set_fcwsensitivelevel(::google::protobuf::uint32 value) {
  
  fcwsensitivelevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.FCWSensitiveLevel)
}

// uint32 AEBSensitiveLevel = 4;
inline void Signal_Input::clear_aebsensitivelevel() {
  aebsensitivelevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Input::aebsensitivelevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.AEBSensitiveLevel)
  return aebsensitivelevel_;
}
inline void Signal_Input::set_aebsensitivelevel(::google::protobuf::uint32 value) {
  
  aebsensitivelevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.AEBSensitiveLevel)
}

// uint32 TireComplexityLevel = 5;
inline void Signal_Input::clear_tirecomplexitylevel() {
  tirecomplexitylevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Input::tirecomplexitylevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.TireComplexityLevel)
  return tirecomplexitylevel_;
}
inline void Signal_Input::set_tirecomplexitylevel(::google::protobuf::uint32 value) {
  
  tirecomplexitylevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.TireComplexityLevel)
}

// float EnvTemperature = 6;
inline void Signal_Input::clear_envtemperature() {
  envtemperature_ = 0;
}
inline float Signal_Input::envtemperature() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.EnvTemperature)
  return envtemperature_;
}
inline void Signal_Input::set_envtemperature(float value) {
  
  envtemperature_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.EnvTemperature)
}

// float EnvHumidity = 7;
inline void Signal_Input::clear_envhumidity() {
  envhumidity_ = 0;
}
inline float Signal_Input::envhumidity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.EnvHumidity)
  return envhumidity_;
}
inline void Signal_Input::set_envhumidity(float value) {
  
  envhumidity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Input.EnvHumidity)
}

// .calmcar.perception.Vehicle_State vehicle_state = 8;
inline bool Signal_Input::has_vehicle_state() const {
  return this != internal_default_instance() && vehicle_state_ != NULL;
}
inline void Signal_Input::clear_vehicle_state() {
  if (GetArenaNoVirtual() == NULL && vehicle_state_ != NULL) {
    delete vehicle_state_;
  }
  vehicle_state_ = NULL;
}
inline const ::calmcar::perception::Vehicle_State& Signal_Input::vehicle_state() const {
  const ::calmcar::perception::Vehicle_State* p = vehicle_state_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Input.vehicle_state)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Vehicle_State*>(
      &::calmcar::perception::_Vehicle_State_default_instance_);
}
inline ::calmcar::perception::Vehicle_State* Signal_Input::release_vehicle_state() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Signal_Input.vehicle_state)
  
  ::calmcar::perception::Vehicle_State* temp = vehicle_state_;
  vehicle_state_ = NULL;
  return temp;
}
inline ::calmcar::perception::Vehicle_State* Signal_Input::mutable_vehicle_state() {
  
  if (vehicle_state_ == NULL) {
    vehicle_state_ = new ::calmcar::perception::Vehicle_State;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Signal_Input.vehicle_state)
  return vehicle_state_;
}
inline void Signal_Input::set_allocated_vehicle_state(::calmcar::perception::Vehicle_State* vehicle_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_state_;
  }
  if (vehicle_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_state, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_state_ = vehicle_state;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Signal_Input.vehicle_state)
}

// -------------------------------------------------------------------

// Signal_Output

// bool FCW_Active = 1;
inline void Signal_Output::clear_fcw_active() {
  fcw_active_ = false;
}
inline bool Signal_Output::fcw_active() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.FCW_Active)
  return fcw_active_;
}
inline void Signal_Output::set_fcw_active(bool value) {
  
  fcw_active_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.FCW_Active)
}

// bool AEB_Active = 2;
inline void Signal_Output::clear_aeb_active() {
  aeb_active_ = false;
}
inline bool Signal_Output::aeb_active() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEB_Active)
  return aeb_active_;
}
inline void Signal_Output::set_aeb_active(bool value) {
  
  aeb_active_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEB_Active)
}

// uint32 FCWStatus = 3;
inline void Signal_Output::clear_fcwstatus() {
  fcwstatus_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::fcwstatus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.FCWStatus)
  return fcwstatus_;
}
inline void Signal_Output::set_fcwstatus(::google::protobuf::uint32 value) {
  
  fcwstatus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.FCWStatus)
}

// uint32 FCWSensitiveLevel = 4;
inline void Signal_Output::clear_fcwsensitivelevel() {
  fcwsensitivelevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::fcwsensitivelevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.FCWSensitiveLevel)
  return fcwsensitivelevel_;
}
inline void Signal_Output::set_fcwsensitivelevel(::google::protobuf::uint32 value) {
  
  fcwsensitivelevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.FCWSensitiveLevel)
}

// uint32 FCW_State = 5;
inline void Signal_Output::clear_fcw_state() {
  fcw_state_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::fcw_state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.FCW_State)
  return fcw_state_;
}
inline void Signal_Output::set_fcw_state(::google::protobuf::uint32 value) {
  
  fcw_state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.FCW_State)
}

// uint32 AEBStatus = 6;
inline void Signal_Output::clear_aebstatus() {
  aebstatus_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebstatus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBStatus)
  return aebstatus_;
}
inline void Signal_Output::set_aebstatus(::google::protobuf::uint32 value) {
  
  aebstatus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBStatus)
}

// uint32 AEBSensitiveLevel = 7;
inline void Signal_Output::clear_aebsensitivelevel() {
  aebsensitivelevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebsensitivelevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBSensitiveLevel)
  return aebsensitivelevel_;
}
inline void Signal_Output::set_aebsensitivelevel(::google::protobuf::uint32 value) {
  
  aebsensitivelevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBSensitiveLevel)
}

// uint32 AEB_State = 8;
inline void Signal_Output::clear_aeb_state() {
  aeb_state_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aeb_state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEB_State)
  return aeb_state_;
}
inline void Signal_Output::set_aeb_state(::google::protobuf::uint32 value) {
  
  aeb_state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEB_State)
}

// uint32 AEBVehicleHoldReq = 9;
inline void Signal_Output::clear_aebvehicleholdreq() {
  aebvehicleholdreq_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebvehicleholdreq() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBVehicleHoldReq)
  return aebvehicleholdreq_;
}
inline void Signal_Output::set_aebvehicleholdreq(::google::protobuf::uint32 value) {
  
  aebvehicleholdreq_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBVehicleHoldReq)
}

// uint32 AEBFullBrake = 10;
inline void Signal_Output::clear_aebfullbrake() {
  aebfullbrake_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebfullbrake() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBFullBrake)
  return aebfullbrake_;
}
inline void Signal_Output::set_aebfullbrake(::google::protobuf::uint32 value) {
  
  aebfullbrake_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBFullBrake)
}

// uint32 AEBDBSLevel = 11;
inline void Signal_Output::clear_aebdbslevel() {
  aebdbslevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebdbslevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBDBSLevel)
  return aebdbslevel_;
}
inline void Signal_Output::set_aebdbslevel(::google::protobuf::uint32 value) {
  
  aebdbslevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBDBSLevel)
}

// uint32 AEBPrefillReq = 12;
inline void Signal_Output::clear_aebprefillreq() {
  aebprefillreq_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebprefillreq() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBPrefillReq)
  return aebprefillreq_;
}
inline void Signal_Output::set_aebprefillreq(::google::protobuf::uint32 value) {
  
  aebprefillreq_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBPrefillReq)
}

// uint32 AEBJerkReq = 13;
inline void Signal_Output::clear_aebjerkreq() {
  aebjerkreq_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebjerkreq() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBJerkReq)
  return aebjerkreq_;
}
inline void Signal_Output::set_aebjerkreq(::google::protobuf::uint32 value) {
  
  aebjerkreq_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBJerkReq)
}

// float AEBTargetDeceleration = 14;
inline void Signal_Output::clear_aebtargetdeceleration() {
  aebtargetdeceleration_ = 0;
}
inline float Signal_Output::aebtargetdeceleration() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBTargetDeceleration)
  return aebtargetdeceleration_;
}
inline void Signal_Output::set_aebtargetdeceleration(float value) {
  
  aebtargetdeceleration_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBTargetDeceleration)
}

// uint32 AEBJerkLevel = 15;
inline void Signal_Output::clear_aebjerklevel() {
  aebjerklevel_ = 0u;
}
inline ::google::protobuf::uint32 Signal_Output::aebjerklevel() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Signal_Output.AEBJerkLevel)
  return aebjerklevel_;
}
inline void Signal_Output::set_aebjerklevel(::google::protobuf::uint32 value) {
  
  aebjerklevel_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Signal_Output.AEBJerkLevel)
}

// -------------------------------------------------------------------

// Fault_Signal

// uint32 FCWSystemFaultStatus = 1;
inline void Fault_Signal::clear_fcwsystemfaultstatus() {
  fcwsystemfaultstatus_ = 0u;
}
inline ::google::protobuf::uint32 Fault_Signal::fcwsystemfaultstatus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Fault_Signal.FCWSystemFaultStatus)
  return fcwsystemfaultstatus_;
}
inline void Fault_Signal::set_fcwsystemfaultstatus(::google::protobuf::uint32 value) {
  
  fcwsystemfaultstatus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Fault_Signal.FCWSystemFaultStatus)
}

// uint32 AEBSystemFaultStatus = 2;
inline void Fault_Signal::clear_aebsystemfaultstatus() {
  aebsystemfaultstatus_ = 0u;
}
inline ::google::protobuf::uint32 Fault_Signal::aebsystemfaultstatus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Fault_Signal.AEBSystemFaultStatus)
  return aebsystemfaultstatus_;
}
inline void Fault_Signal::set_aebsystemfaultstatus(::google::protobuf::uint32 value) {
  
  aebsystemfaultstatus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Fault_Signal.AEBSystemFaultStatus)
}

// -------------------------------------------------------------------

// Vehicle_Signal

// .calmcar.perception.Signal_Output signal_output = 1;
inline bool Vehicle_Signal::has_signal_output() const {
  return this != internal_default_instance() && signal_output_ != NULL;
}
inline void Vehicle_Signal::clear_signal_output() {
  if (GetArenaNoVirtual() == NULL && signal_output_ != NULL) {
    delete signal_output_;
  }
  signal_output_ = NULL;
}
inline const ::calmcar::perception::Signal_Output& Vehicle_Signal::signal_output() const {
  const ::calmcar::perception::Signal_Output* p = signal_output_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_Signal.signal_output)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Signal_Output*>(
      &::calmcar::perception::_Signal_Output_default_instance_);
}
inline ::calmcar::perception::Signal_Output* Vehicle_Signal::release_signal_output() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Vehicle_Signal.signal_output)
  
  ::calmcar::perception::Signal_Output* temp = signal_output_;
  signal_output_ = NULL;
  return temp;
}
inline ::calmcar::perception::Signal_Output* Vehicle_Signal::mutable_signal_output() {
  
  if (signal_output_ == NULL) {
    signal_output_ = new ::calmcar::perception::Signal_Output;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Vehicle_Signal.signal_output)
  return signal_output_;
}
inline void Vehicle_Signal::set_allocated_signal_output(::calmcar::perception::Signal_Output* signal_output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_output_;
  }
  if (signal_output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal_output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal_output, submessage_arena);
    }
    
  } else {
    
  }
  signal_output_ = signal_output;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Vehicle_Signal.signal_output)
}

// .calmcar.perception.Fault_Signal fault_signal = 2;
inline bool Vehicle_Signal::has_fault_signal() const {
  return this != internal_default_instance() && fault_signal_ != NULL;
}
inline void Vehicle_Signal::clear_fault_signal() {
  if (GetArenaNoVirtual() == NULL && fault_signal_ != NULL) {
    delete fault_signal_;
  }
  fault_signal_ = NULL;
}
inline const ::calmcar::perception::Fault_Signal& Vehicle_Signal::fault_signal() const {
  const ::calmcar::perception::Fault_Signal* p = fault_signal_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Vehicle_Signal.fault_signal)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Fault_Signal*>(
      &::calmcar::perception::_Fault_Signal_default_instance_);
}
inline ::calmcar::perception::Fault_Signal* Vehicle_Signal::release_fault_signal() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Vehicle_Signal.fault_signal)
  
  ::calmcar::perception::Fault_Signal* temp = fault_signal_;
  fault_signal_ = NULL;
  return temp;
}
inline ::calmcar::perception::Fault_Signal* Vehicle_Signal::mutable_fault_signal() {
  
  if (fault_signal_ == NULL) {
    fault_signal_ = new ::calmcar::perception::Fault_Signal;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Vehicle_Signal.fault_signal)
  return fault_signal_;
}
inline void Vehicle_Signal::set_allocated_fault_signal(::calmcar::perception::Fault_Signal* fault_signal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fault_signal_;
  }
  if (fault_signal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fault_signal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fault_signal, submessage_arena);
    }
    
  } else {
    
  }
  fault_signal_ = fault_signal;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Vehicle_Signal.fault_signal)
}

// -------------------------------------------------------------------

// AebOutput

// bool is_valid = 1;
inline void AebOutput::clear_is_valid() {
  is_valid_ = false;
}
inline bool AebOutput::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.is_valid)
  return is_valid_;
}
inline void AebOutput::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebOutput.is_valid)
}

// .calmcar.perception.AebOutput.AebOut aeb_out = 2;
inline void AebOutput::clear_aeb_out() {
  aeb_out_ = 0;
}
inline ::calmcar::perception::AebOutput_AebOut AebOutput::aeb_out() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.aeb_out)
  return static_cast< ::calmcar::perception::AebOutput_AebOut >(aeb_out_);
}
inline void AebOutput::set_aeb_out(::calmcar::perception::AebOutput_AebOut value) {
  
  aeb_out_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebOutput.aeb_out)
}

// .calmcar.perception.AebOutput.AebDecision aeb_decision = 3;
inline void AebOutput::clear_aeb_decision() {
  aeb_decision_ = 0;
}
inline ::calmcar::perception::AebOutput_AebDecision AebOutput::aeb_decision() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.aeb_decision)
  return static_cast< ::calmcar::perception::AebOutput_AebDecision >(aeb_decision_);
}
inline void AebOutput::set_aeb_decision(::calmcar::perception::AebOutput_AebDecision value) {
  
  aeb_decision_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.AebOutput.aeb_decision)
}

// repeated .calmcar.perception.AebObject follow_objects = 4;
inline int AebOutput::follow_objects_size() const {
  return follow_objects_.size();
}
inline void AebOutput::clear_follow_objects() {
  follow_objects_.Clear();
}
inline const ::calmcar::perception::AebObject& AebOutput::follow_objects(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.follow_objects)
  return follow_objects_.Get(index);
}
inline ::calmcar::perception::AebObject* AebOutput::mutable_follow_objects(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebOutput.follow_objects)
  return follow_objects_.Mutable(index);
}
inline ::calmcar::perception::AebObject* AebOutput::add_follow_objects() {
  // @@protoc_insertion_point(field_add:calmcar.perception.AebOutput.follow_objects)
  return follow_objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::AebObject >*
AebOutput::mutable_follow_objects() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebOutput.follow_objects)
  return &follow_objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::AebObject >&
AebOutput::follow_objects() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebOutput.follow_objects)
  return follow_objects_;
}

// repeated .calmcar.perception.VehiclePredictPoint predict_pts = 5;
inline int AebOutput::predict_pts_size() const {
  return predict_pts_.size();
}
inline void AebOutput::clear_predict_pts() {
  predict_pts_.Clear();
}
inline const ::calmcar::perception::VehiclePredictPoint& AebOutput::predict_pts(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.predict_pts)
  return predict_pts_.Get(index);
}
inline ::calmcar::perception::VehiclePredictPoint* AebOutput::mutable_predict_pts(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebOutput.predict_pts)
  return predict_pts_.Mutable(index);
}
inline ::calmcar::perception::VehiclePredictPoint* AebOutput::add_predict_pts() {
  // @@protoc_insertion_point(field_add:calmcar.perception.AebOutput.predict_pts)
  return predict_pts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::VehiclePredictPoint >*
AebOutput::mutable_predict_pts() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.AebOutput.predict_pts)
  return &predict_pts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::VehiclePredictPoint >&
AebOutput::predict_pts() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.AebOutput.predict_pts)
  return predict_pts_;
}

// .calmcar.perception.Vehicle_Signal vehicle_signal = 6;
inline bool AebOutput::has_vehicle_signal() const {
  return this != internal_default_instance() && vehicle_signal_ != NULL;
}
inline void AebOutput::clear_vehicle_signal() {
  if (GetArenaNoVirtual() == NULL && vehicle_signal_ != NULL) {
    delete vehicle_signal_;
  }
  vehicle_signal_ = NULL;
}
inline const ::calmcar::perception::Vehicle_Signal& AebOutput::vehicle_signal() const {
  const ::calmcar::perception::Vehicle_Signal* p = vehicle_signal_;
  // @@protoc_insertion_point(field_get:calmcar.perception.AebOutput.vehicle_signal)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Vehicle_Signal*>(
      &::calmcar::perception::_Vehicle_Signal_default_instance_);
}
inline ::calmcar::perception::Vehicle_Signal* AebOutput::release_vehicle_signal() {
  // @@protoc_insertion_point(field_release:calmcar.perception.AebOutput.vehicle_signal)
  
  ::calmcar::perception::Vehicle_Signal* temp = vehicle_signal_;
  vehicle_signal_ = NULL;
  return temp;
}
inline ::calmcar::perception::Vehicle_Signal* AebOutput::mutable_vehicle_signal() {
  
  if (vehicle_signal_ == NULL) {
    vehicle_signal_ = new ::calmcar::perception::Vehicle_Signal;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebOutput.vehicle_signal)
  return vehicle_signal_;
}
inline void AebOutput::set_allocated_vehicle_signal(::calmcar::perception::Vehicle_Signal* vehicle_signal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_signal_;
  }
  if (vehicle_signal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_signal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_signal, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_signal_ = vehicle_signal;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.AebOutput.vehicle_signal)
}

// -------------------------------------------------------------------

// AebInput

// .calmcar.perception.Signal_Input signal_input = 1;
inline bool AebInput::has_signal_input() const {
  return this != internal_default_instance() && signal_input_ != NULL;
}
inline void AebInput::clear_signal_input() {
  if (GetArenaNoVirtual() == NULL && signal_input_ != NULL) {
    delete signal_input_;
  }
  signal_input_ = NULL;
}
inline const ::calmcar::perception::Signal_Input& AebInput::signal_input() const {
  const ::calmcar::perception::Signal_Input* p = signal_input_;
  // @@protoc_insertion_point(field_get:calmcar.perception.AebInput.signal_input)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Signal_Input*>(
      &::calmcar::perception::_Signal_Input_default_instance_);
}
inline ::calmcar::perception::Signal_Input* AebInput::release_signal_input() {
  // @@protoc_insertion_point(field_release:calmcar.perception.AebInput.signal_input)
  
  ::calmcar::perception::Signal_Input* temp = signal_input_;
  signal_input_ = NULL;
  return temp;
}
inline ::calmcar::perception::Signal_Input* AebInput::mutable_signal_input() {
  
  if (signal_input_ == NULL) {
    signal_input_ = new ::calmcar::perception::Signal_Input;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebInput.signal_input)
  return signal_input_;
}
inline void AebInput::set_allocated_signal_input(::calmcar::perception::Signal_Input* signal_input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_input_;
  }
  if (signal_input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal_input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal_input, submessage_arena);
    }
    
  } else {
    
  }
  signal_input_ = signal_input;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.AebInput.signal_input)
}

// -------------------------------------------------------------------

// AebInfo

// .calmcar.perception.AebInput aeb_input = 1;
inline bool AebInfo::has_aeb_input() const {
  return this != internal_default_instance() && aeb_input_ != NULL;
}
inline void AebInfo::clear_aeb_input() {
  if (GetArenaNoVirtual() == NULL && aeb_input_ != NULL) {
    delete aeb_input_;
  }
  aeb_input_ = NULL;
}
inline const ::calmcar::perception::AebInput& AebInfo::aeb_input() const {
  const ::calmcar::perception::AebInput* p = aeb_input_;
  // @@protoc_insertion_point(field_get:calmcar.perception.AebInfo.aeb_input)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::AebInput*>(
      &::calmcar::perception::_AebInput_default_instance_);
}
inline ::calmcar::perception::AebInput* AebInfo::release_aeb_input() {
  // @@protoc_insertion_point(field_release:calmcar.perception.AebInfo.aeb_input)
  
  ::calmcar::perception::AebInput* temp = aeb_input_;
  aeb_input_ = NULL;
  return temp;
}
inline ::calmcar::perception::AebInput* AebInfo::mutable_aeb_input() {
  
  if (aeb_input_ == NULL) {
    aeb_input_ = new ::calmcar::perception::AebInput;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebInfo.aeb_input)
  return aeb_input_;
}
inline void AebInfo::set_allocated_aeb_input(::calmcar::perception::AebInput* aeb_input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aeb_input_;
  }
  if (aeb_input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aeb_input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aeb_input, submessage_arena);
    }
    
  } else {
    
  }
  aeb_input_ = aeb_input;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.AebInfo.aeb_input)
}

// .calmcar.perception.AebOutput aeb_output = 2;
inline bool AebInfo::has_aeb_output() const {
  return this != internal_default_instance() && aeb_output_ != NULL;
}
inline void AebInfo::clear_aeb_output() {
  if (GetArenaNoVirtual() == NULL && aeb_output_ != NULL) {
    delete aeb_output_;
  }
  aeb_output_ = NULL;
}
inline const ::calmcar::perception::AebOutput& AebInfo::aeb_output() const {
  const ::calmcar::perception::AebOutput* p = aeb_output_;
  // @@protoc_insertion_point(field_get:calmcar.perception.AebInfo.aeb_output)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::AebOutput*>(
      &::calmcar::perception::_AebOutput_default_instance_);
}
inline ::calmcar::perception::AebOutput* AebInfo::release_aeb_output() {
  // @@protoc_insertion_point(field_release:calmcar.perception.AebInfo.aeb_output)
  
  ::calmcar::perception::AebOutput* temp = aeb_output_;
  aeb_output_ = NULL;
  return temp;
}
inline ::calmcar::perception::AebOutput* AebInfo::mutable_aeb_output() {
  
  if (aeb_output_ == NULL) {
    aeb_output_ = new ::calmcar::perception::AebOutput;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.AebInfo.aeb_output)
  return aeb_output_;
}
inline void AebInfo::set_allocated_aeb_output(::calmcar::perception::AebOutput* aeb_output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aeb_output_;
  }
  if (aeb_output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aeb_output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aeb_output, submessage_arena);
    }
    
  } else {
    
  }
  aeb_output_ = aeb_output;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.AebInfo.aeb_output)
}

// -------------------------------------------------------------------

// Failsafe

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void Failsafe::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position Failsafe::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void Failsafe::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.camera_position)
}

// int64 timestamp = 2;
inline void Failsafe::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Failsafe::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.timestamp)
  return timestamp_;
}
inline void Failsafe::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.timestamp)
}

// .calmcar.perception.Failsafe.FailSafeBlockage blockage_status = 3;
inline void Failsafe::clear_blockage_status() {
  blockage_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeBlockage Failsafe::blockage_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.blockage_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeBlockage >(blockage_status_);
}
inline void Failsafe::set_blockage_status(::calmcar::perception::Failsafe_FailSafeBlockage value) {
  
  blockage_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.blockage_status)
}

// string blockage_name = 4;
inline void Failsafe::clear_blockage_name() {
  blockage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::blockage_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.blockage_name)
  return blockage_name_.GetNoArena();
}
inline void Failsafe::set_blockage_name(const ::std::string& value) {
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.blockage_name)
}
#if LANG_CXX11
inline void Failsafe::set_blockage_name(::std::string&& value) {
  
  blockage_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.blockage_name)
}
#endif
inline void Failsafe::set_blockage_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.blockage_name)
}
inline void Failsafe::set_blockage_name(const char* value, size_t size) {
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.blockage_name)
}
inline ::std::string* Failsafe::mutable_blockage_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.blockage_name)
  return blockage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_blockage_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.blockage_name)
  
  return blockage_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_blockage_name(::std::string* blockage_name) {
  if (blockage_name != NULL) {
    
  } else {
    
  }
  blockage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockage_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.blockage_name)
}

// .calmcar.perception.Failsafe.FailSafeWeather weather_status = 5;
inline void Failsafe::clear_weather_status() {
  weather_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeWeather Failsafe::weather_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.weather_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeWeather >(weather_status_);
}
inline void Failsafe::set_weather_status(::calmcar::perception::Failsafe_FailSafeWeather value) {
  
  weather_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.weather_status)
}

// string weather_name = 6;
inline void Failsafe::clear_weather_name() {
  weather_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::weather_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.weather_name)
  return weather_name_.GetNoArena();
}
inline void Failsafe::set_weather_name(const ::std::string& value) {
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.weather_name)
}
#if LANG_CXX11
inline void Failsafe::set_weather_name(::std::string&& value) {
  
  weather_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.weather_name)
}
#endif
inline void Failsafe::set_weather_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.weather_name)
}
inline void Failsafe::set_weather_name(const char* value, size_t size) {
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.weather_name)
}
inline ::std::string* Failsafe::mutable_weather_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.weather_name)
  return weather_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_weather_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.weather_name)
  
  return weather_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_weather_name(::std::string* weather_name) {
  if (weather_name != NULL) {
    
  } else {
    
  }
  weather_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weather_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.weather_name)
}

// .calmcar.perception.Failsafe.FailSafeIllumination illumination_status = 7;
inline void Failsafe::clear_illumination_status() {
  illumination_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeIllumination Failsafe::illumination_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.illumination_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeIllumination >(illumination_status_);
}
inline void Failsafe::set_illumination_status(::calmcar::perception::Failsafe_FailSafeIllumination value) {
  
  illumination_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.illumination_status)
}

// string illumination_name = 8;
inline void Failsafe::clear_illumination_name() {
  illumination_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::illumination_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.illumination_name)
  return illumination_name_.GetNoArena();
}
inline void Failsafe::set_illumination_name(const ::std::string& value) {
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.illumination_name)
}
#if LANG_CXX11
inline void Failsafe::set_illumination_name(::std::string&& value) {
  
  illumination_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.illumination_name)
}
#endif
inline void Failsafe::set_illumination_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.illumination_name)
}
inline void Failsafe::set_illumination_name(const char* value, size_t size) {
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.illumination_name)
}
inline ::std::string* Failsafe::mutable_illumination_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.illumination_name)
  return illumination_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_illumination_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.illumination_name)
  
  return illumination_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_illumination_name(::std::string* illumination_name) {
  if (illumination_name != NULL) {
    
  } else {
    
  }
  illumination_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), illumination_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.illumination_name)
}

// .calmcar.perception.Failsafe.FailSafeImageLimited image_limited_status = 9;
inline void Failsafe::clear_image_limited_status() {
  image_limited_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeImageLimited Failsafe::image_limited_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.image_limited_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeImageLimited >(image_limited_status_);
}
inline void Failsafe::set_image_limited_status(::calmcar::perception::Failsafe_FailSafeImageLimited value) {
  
  image_limited_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.image_limited_status)
}

// string image_limited_name = 10;
inline void Failsafe::clear_image_limited_name() {
  image_limited_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::image_limited_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.image_limited_name)
  return image_limited_name_.GetNoArena();
}
inline void Failsafe::set_image_limited_name(const ::std::string& value) {
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.image_limited_name)
}
#if LANG_CXX11
inline void Failsafe::set_image_limited_name(::std::string&& value) {
  
  image_limited_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.image_limited_name)
}
#endif
inline void Failsafe::set_image_limited_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.image_limited_name)
}
inline void Failsafe::set_image_limited_name(const char* value, size_t size) {
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.image_limited_name)
}
inline ::std::string* Failsafe::mutable_image_limited_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.image_limited_name)
  return image_limited_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_image_limited_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.image_limited_name)
  
  return image_limited_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_image_limited_name(::std::string* image_limited_name) {
  if (image_limited_name != NULL) {
    
  } else {
    
  }
  image_limited_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_limited_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.image_limited_name)
}

// bool out_of_focus = 11;
inline void Failsafe::clear_out_of_focus() {
  out_of_focus_ = false;
}
inline bool Failsafe::out_of_focus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.out_of_focus)
  return out_of_focus_;
}
inline void Failsafe::set_out_of_focus(bool value) {
  
  out_of_focus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.out_of_focus)
}

// int32 impacted_technologies = 12;
inline void Failsafe::clear_impacted_technologies() {
  impacted_technologies_ = 0;
}
inline ::google::protobuf::int32 Failsafe::impacted_technologies() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.impacted_technologies)
  return impacted_technologies_;
}
inline void Failsafe::set_impacted_technologies(::google::protobuf::int32 value) {
  
  impacted_technologies_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.impacted_technologies)
}

// -------------------------------------------------------------------

// PerceptionFrame

// .calmcar.perception.Header header = 1;
inline bool PerceptionFrame::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PerceptionFrame::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::calmcar::perception::Header& PerceptionFrame::header() const {
  const ::calmcar::perception::Header* p = header_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Header*>(
      &::calmcar::perception::_Header_default_instance_);
}
inline ::calmcar::perception::Header* PerceptionFrame::release_header() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.header)
  
  ::calmcar::perception::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::calmcar::perception::Header* PerceptionFrame::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::calmcar::perception::Header;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.header)
  return header_;
}
inline void PerceptionFrame::set_allocated_header(::calmcar::perception::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.header)
}

// int64 vd_count = 2;
inline void PerceptionFrame::clear_vd_count() {
  vd_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_count)
  return vd_count_;
}
inline void PerceptionFrame::set_vd_count(::google::protobuf::int64 value) {
  
  vd_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_count)
}

// int64 vru_count = 3;
inline void PerceptionFrame::clear_vru_count() {
  vru_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vru_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vru_count)
  return vru_count_;
}
inline void PerceptionFrame::set_vru_count(::google::protobuf::int64 value) {
  
  vru_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vru_count)
}

// int64 num_of_objects = 4;
inline void PerceptionFrame::clear_num_of_objects() {
  num_of_objects_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::num_of_objects() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.num_of_objects)
  return num_of_objects_;
}
inline void PerceptionFrame::set_num_of_objects(::google::protobuf::int64 value) {
  
  num_of_objects_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.num_of_objects)
}

// int64 cipv_id = 5;
inline void PerceptionFrame::clear_cipv_id() {
  cipv_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::cipv_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.cipv_id)
  return cipv_id_;
}
inline void PerceptionFrame::set_cipv_id(::google::protobuf::int64 value) {
  
  cipv_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.cipv_id)
}

// int64 vd_niv_left = 6;
inline void PerceptionFrame::clear_vd_niv_left() {
  vd_niv_left_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_niv_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_niv_left)
  return vd_niv_left_;
}
inline void PerceptionFrame::set_vd_niv_left(::google::protobuf::int64 value) {
  
  vd_niv_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_niv_left)
}

// int64 vd_niv_right = 7;
inline void PerceptionFrame::clear_vd_niv_right() {
  vd_niv_right_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_niv_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_niv_right)
  return vd_niv_right_;
}
inline void PerceptionFrame::set_vd_niv_right(::google::protobuf::int64 value) {
  
  vd_niv_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_niv_right)
}

// .calmcar.perception.CipvLost cipv_lost = 8;
inline void PerceptionFrame::clear_cipv_lost() {
  cipv_lost_ = 0;
}
inline ::calmcar::perception::CipvLost PerceptionFrame::cipv_lost() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.cipv_lost)
  return static_cast< ::calmcar::perception::CipvLost >(cipv_lost_);
}
inline void PerceptionFrame::set_cipv_lost(::calmcar::perception::CipvLost value) {
  
  cipv_lost_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.cipv_lost)
}

// .calmcar.perception.AllowAcc allow_acc = 9;
inline void PerceptionFrame::clear_allow_acc() {
  allow_acc_ = 0;
}
inline ::calmcar::perception::AllowAcc PerceptionFrame::allow_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.allow_acc)
  return static_cast< ::calmcar::perception::AllowAcc >(allow_acc_);
}
inline void PerceptionFrame::set_allow_acc(::calmcar::perception::AllowAcc value) {
  
  allow_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.allow_acc)
}

// repeated .calmcar.perception.Object object = 10;
inline int PerceptionFrame::object_size() const {
  return object_.size();
}
inline void PerceptionFrame::clear_object() {
  object_.Clear();
}
inline const ::calmcar::perception::Object& PerceptionFrame::object(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.object)
  return object_.Get(index);
}
inline ::calmcar::perception::Object* PerceptionFrame::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.object)
  return object_.Mutable(index);
}
inline ::calmcar::perception::Object* PerceptionFrame::add_object() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.object)
  return object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >*
PerceptionFrame::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.object)
  return &object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >&
PerceptionFrame::object() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.object)
  return object_;
}

// repeated .calmcar.perception.RoadMark road_mark = 11;
inline int PerceptionFrame::road_mark_size() const {
  return road_mark_.size();
}
inline const ::calmcar::perception::RoadMark& PerceptionFrame::road_mark(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Get(index);
}
inline ::calmcar::perception::RoadMark* PerceptionFrame::mutable_road_mark(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Mutable(index);
}
inline ::calmcar::perception::RoadMark* PerceptionFrame::add_road_mark() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >*
PerceptionFrame::mutable_road_mark() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.road_mark)
  return &road_mark_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >&
PerceptionFrame::road_mark() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_;
}

// .calmcar.perception.Lane lane = 12;
inline bool PerceptionFrame::has_lane() const {
  return this != internal_default_instance() && lane_ != NULL;
}
inline const ::calmcar::perception::Lane& PerceptionFrame::lane() const {
  const ::calmcar::perception::Lane* p = lane_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.lane)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Lane*>(
      &::calmcar::perception::_Lane_default_instance_);
}
inline ::calmcar::perception::Lane* PerceptionFrame::release_lane() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.lane)
  
  ::calmcar::perception::Lane* temp = lane_;
  lane_ = NULL;
  return temp;
}
inline ::calmcar::perception::Lane* PerceptionFrame::mutable_lane() {
  
  if (lane_ == NULL) {
    lane_ = new ::calmcar::perception::Lane;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.lane)
  return lane_;
}
inline void PerceptionFrame::set_allocated_lane(::calmcar::perception::Lane* lane) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lane_);
  }
  if (lane) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane, submessage_arena);
    }
    
  } else {
    
  }
  lane_ = lane;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.lane)
}

// .calmcar.perception.FreeSpace free_space = 13;
inline bool PerceptionFrame::has_free_space() const {
  return this != internal_default_instance() && free_space_ != NULL;
}
inline const ::calmcar::perception::FreeSpace& PerceptionFrame::free_space() const {
  const ::calmcar::perception::FreeSpace* p = free_space_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.free_space)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::FreeSpace*>(
      &::calmcar::perception::_FreeSpace_default_instance_);
}
inline ::calmcar::perception::FreeSpace* PerceptionFrame::release_free_space() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.free_space)
  
  ::calmcar::perception::FreeSpace* temp = free_space_;
  free_space_ = NULL;
  return temp;
}
inline ::calmcar::perception::FreeSpace* PerceptionFrame::mutable_free_space() {
  
  if (free_space_ == NULL) {
    free_space_ = new ::calmcar::perception::FreeSpace;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.free_space)
  return free_space_;
}
inline void PerceptionFrame::set_allocated_free_space(::calmcar::perception::FreeSpace* free_space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(free_space_);
  }
  if (free_space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      free_space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, free_space, submessage_arena);
    }
    
  } else {
    
  }
  free_space_ = free_space;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.free_space)
}

// repeated .calmcar.perception.TrafficLight tfl_structure = 14;
inline int PerceptionFrame::tfl_structure_size() const {
  return tfl_structure_.size();
}
inline void PerceptionFrame::clear_tfl_structure() {
  tfl_structure_.Clear();
}
inline const ::calmcar::perception::TrafficLight& PerceptionFrame::tfl_structure(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Get(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::mutable_tfl_structure(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Mutable(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::add_tfl_structure() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
PerceptionFrame::mutable_tfl_structure() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.tfl_structure)
  return &tfl_structure_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
PerceptionFrame::tfl_structure() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_;
}

// repeated .calmcar.perception.TrafficLight tfl_struct_state = 15;
inline int PerceptionFrame::tfl_struct_state_size() const {
  return tfl_struct_state_.size();
}
inline void PerceptionFrame::clear_tfl_struct_state() {
  tfl_struct_state_.Clear();
}
inline const ::calmcar::perception::TrafficLight& PerceptionFrame::tfl_struct_state(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Get(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::mutable_tfl_struct_state(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Mutable(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::add_tfl_struct_state() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
PerceptionFrame::mutable_tfl_struct_state() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return &tfl_struct_state_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
PerceptionFrame::tfl_struct_state() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_;
}

// int64 tfl_struct_count = 16;
inline void PerceptionFrame::clear_tfl_struct_count() {
  tfl_struct_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::tfl_struct_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_struct_count)
  return tfl_struct_count_;
}
inline void PerceptionFrame::set_tfl_struct_count(::google::protobuf::int64 value) {
  
  tfl_struct_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.tfl_struct_count)
}

// int64 tfl_spot_count = 17;
inline void PerceptionFrame::clear_tfl_spot_count() {
  tfl_spot_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::tfl_spot_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_spot_count)
  return tfl_spot_count_;
}
inline void PerceptionFrame::set_tfl_spot_count(::google::protobuf::int64 value) {
  
  tfl_spot_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.tfl_spot_count)
}

// repeated .calmcar.perception.TrafficSign traffic_sign = 18;
inline int PerceptionFrame::traffic_sign_size() const {
  return traffic_sign_.size();
}
inline void PerceptionFrame::clear_traffic_sign() {
  traffic_sign_.Clear();
}
inline const ::calmcar::perception::TrafficSign& PerceptionFrame::traffic_sign(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Get(index);
}
inline ::calmcar::perception::TrafficSign* PerceptionFrame::mutable_traffic_sign(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Mutable(index);
}
inline ::calmcar::perception::TrafficSign* PerceptionFrame::add_traffic_sign() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >*
PerceptionFrame::mutable_traffic_sign() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.traffic_sign)
  return &traffic_sign_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >&
PerceptionFrame::traffic_sign() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_;
}

// repeated .calmcar.perception.TrafficSignStatus traffic_sign_status = 19;
inline int PerceptionFrame::traffic_sign_status_size() const {
  return traffic_sign_status_.size();
}
inline void PerceptionFrame::clear_traffic_sign_status() {
  traffic_sign_status_.Clear();
}
inline const ::calmcar::perception::TrafficSignStatus& PerceptionFrame::traffic_sign_status(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Get(index);
}
inline ::calmcar::perception::TrafficSignStatus* PerceptionFrame::mutable_traffic_sign_status(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Mutable(index);
}
inline ::calmcar::perception::TrafficSignStatus* PerceptionFrame::add_traffic_sign_status() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >*
PerceptionFrame::mutable_traffic_sign_status() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return &traffic_sign_status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >&
PerceptionFrame::traffic_sign_status() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_;
}

// repeated .calmcar.perception.Failsafe failsafe = 20;
inline int PerceptionFrame::failsafe_size() const {
  return failsafe_.size();
}
inline void PerceptionFrame::clear_failsafe() {
  failsafe_.Clear();
}
inline const ::calmcar::perception::Failsafe& PerceptionFrame::failsafe(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Get(index);
}
inline ::calmcar::perception::Failsafe* PerceptionFrame::mutable_failsafe(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Mutable(index);
}
inline ::calmcar::perception::Failsafe* PerceptionFrame::add_failsafe() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >*
PerceptionFrame::mutable_failsafe() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.failsafe)
  return &failsafe_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >&
PerceptionFrame::failsafe() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_;
}

// repeated .calmcar.perception.Vehicle vehicle_info = 21;
inline int PerceptionFrame::vehicle_info_size() const {
  return vehicle_info_.size();
}
inline const ::calmcar::perception::Vehicle& PerceptionFrame::vehicle_info(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Get(index);
}
inline ::calmcar::perception::Vehicle* PerceptionFrame::mutable_vehicle_info(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Mutable(index);
}
inline ::calmcar::perception::Vehicle* PerceptionFrame::add_vehicle_info() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >*
PerceptionFrame::mutable_vehicle_info() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.vehicle_info)
  return &vehicle_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >&
PerceptionFrame::vehicle_info() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_;
}

// int64 barricade_count = 22;
inline void PerceptionFrame::clear_barricade_count() {
  barricade_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::barricade_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.barricade_count)
  return barricade_count_;
}
inline void PerceptionFrame::set_barricade_count(::google::protobuf::int64 value) {
  
  barricade_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.barricade_count)
}

// repeated .calmcar.perception.Barricade barricade_object = 23;
inline int PerceptionFrame::barricade_object_size() const {
  return barricade_object_.size();
}
inline const ::calmcar::perception::Barricade& PerceptionFrame::barricade_object(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Get(index);
}
inline ::calmcar::perception::Barricade* PerceptionFrame::mutable_barricade_object(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Mutable(index);
}
inline ::calmcar::perception::Barricade* PerceptionFrame::add_barricade_object() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >*
PerceptionFrame::mutable_barricade_object() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.barricade_object)
  return &barricade_object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >&
PerceptionFrame::barricade_object() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_;
}

// repeated .calmcar.perception.Point self_lane_center = 24;
inline int PerceptionFrame::self_lane_center_size() const {
  return self_lane_center_.size();
}
inline const ::calmcar::perception::Point& PerceptionFrame::self_lane_center(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.self_lane_center)
  return self_lane_center_.Get(index);
}
inline ::calmcar::perception::Point* PerceptionFrame::mutable_self_lane_center(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.self_lane_center)
  return self_lane_center_.Mutable(index);
}
inline ::calmcar::perception::Point* PerceptionFrame::add_self_lane_center() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.self_lane_center)
  return self_lane_center_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point >*
PerceptionFrame::mutable_self_lane_center() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.self_lane_center)
  return &self_lane_center_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point >&
PerceptionFrame::self_lane_center() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.self_lane_center)
  return self_lane_center_;
}

// .calmcar.perception.Diagnose diagnose = 25;
inline bool PerceptionFrame::has_diagnose() const {
  return this != internal_default_instance() && diagnose_ != NULL;
}
inline const ::calmcar::perception::Diagnose& PerceptionFrame::diagnose() const {
  const ::calmcar::perception::Diagnose* p = diagnose_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.diagnose)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Diagnose*>(
      &::calmcar::perception::_Diagnose_default_instance_);
}
inline ::calmcar::perception::Diagnose* PerceptionFrame::release_diagnose() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.diagnose)
  
  ::calmcar::perception::Diagnose* temp = diagnose_;
  diagnose_ = NULL;
  return temp;
}
inline ::calmcar::perception::Diagnose* PerceptionFrame::mutable_diagnose() {
  
  if (diagnose_ == NULL) {
    diagnose_ = new ::calmcar::perception::Diagnose;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.diagnose)
  return diagnose_;
}
inline void PerceptionFrame::set_allocated_diagnose(::calmcar::perception::Diagnose* diagnose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(diagnose_);
  }
  if (diagnose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      diagnose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, diagnose, submessage_arena);
    }
    
  } else {
    
  }
  diagnose_ = diagnose;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.diagnose)
}

// int64 perception_end_timestamp = 26;
inline void PerceptionFrame::clear_perception_end_timestamp() {
  perception_end_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::perception_end_timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.perception_end_timestamp)
  return perception_end_timestamp_;
}
inline void PerceptionFrame::set_perception_end_timestamp(::google::protobuf::int64 value) {
  
  perception_end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.perception_end_timestamp)
}

// .calmcar.perception.AebInfo aeb_info = 27;
inline bool PerceptionFrame::has_aeb_info() const {
  return this != internal_default_instance() && aeb_info_ != NULL;
}
inline void PerceptionFrame::clear_aeb_info() {
  if (GetArenaNoVirtual() == NULL && aeb_info_ != NULL) {
    delete aeb_info_;
  }
  aeb_info_ = NULL;
}
inline const ::calmcar::perception::AebInfo& PerceptionFrame::aeb_info() const {
  const ::calmcar::perception::AebInfo* p = aeb_info_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.aeb_info)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::AebInfo*>(
      &::calmcar::perception::_AebInfo_default_instance_);
}
inline ::calmcar::perception::AebInfo* PerceptionFrame::release_aeb_info() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.aeb_info)
  
  ::calmcar::perception::AebInfo* temp = aeb_info_;
  aeb_info_ = NULL;
  return temp;
}
inline ::calmcar::perception::AebInfo* PerceptionFrame::mutable_aeb_info() {
  
  if (aeb_info_ == NULL) {
    aeb_info_ = new ::calmcar::perception::AebInfo;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.aeb_info)
  return aeb_info_;
}
inline void PerceptionFrame::set_allocated_aeb_info(::calmcar::perception::AebInfo* aeb_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aeb_info_;
  }
  if (aeb_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aeb_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aeb_info, submessage_arena);
    }
    
  } else {
    
  }
  aeb_info_ = aeb_info;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.aeb_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace calmcar

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmcar::perception::Header_ProtobufVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_ProtobufVersion>() {
  return ::calmcar::perception::Header_ProtobufVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_ObjectVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_ObjectVersion>() {
  return ::calmcar::perception::Header_ObjectVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficLightStructVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficLightStructVersion>() {
  return ::calmcar::perception::Header_TrafficLightStructVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficLightSpotVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficLightSpotVersion>() {
  return ::calmcar::perception::Header_TrafficLightSpotVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficSignVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficSignVersion>() {
  return ::calmcar::perception::Header_TrafficSignVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_FailSafeVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_FailSafeVersion>() {
  return ::calmcar::perception::Header_FailSafeVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_LaneVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_LaneVersion>() {
  return ::calmcar::perception::Header_LaneVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_RoadMarkVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_RoadMarkVersion>() {
  return ::calmcar::perception::Header_RoadMarkVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_FreeSpaceVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_FreeSpaceVersion>() {
  return ::calmcar::perception::Header_FreeSpaceVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_BarricadeVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_BarricadeVersion>() {
  return ::calmcar::perception::Header_BarricadeVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLightSpot_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLightSpot_Color>() {
  return ::calmcar::perception::TrafficLightSpot_Color_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLightSpot_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLightSpot_Type>() {
  return ::calmcar::perception::TrafficLightSpot_Type_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Color> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Color>() {
  return ::calmcar::perception::TrafficLight_Color_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Type>() {
  return ::calmcar::perception::TrafficLight_Type_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Mode>() {
  return ::calmcar::perception::TrafficLight_Mode_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy>() {
  return ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_Type>() {
  return ::calmcar::perception::TrafficSignType_Type_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_ProhibitionSign> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_ProhibitionSign>() {
  return ::calmcar::perception::TrafficSignType_ProhibitionSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_WarningSign> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_WarningSign>() {
  return ::calmcar::perception::TrafficSignType_WarningSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_SupplementSign> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_SupplementSign>() {
  return ::calmcar::perception::TrafficSignType_SupplementSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::AebOutput_AebOut> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::AebOutput_AebOut>() {
  return ::calmcar::perception::AebOutput_AebOut_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::AebOutput_AebDecision> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::AebOutput_AebDecision>() {
  return ::calmcar::perception::AebOutput_AebDecision_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeBlockage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeBlockage>() {
  return ::calmcar::perception::Failsafe_FailSafeBlockage_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeWeather> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeWeather>() {
  return ::calmcar::perception::Failsafe_FailSafeWeather_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeIllumination> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeIllumination>() {
  return ::calmcar::perception::Failsafe_FailSafeIllumination_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeImageLimited> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeImageLimited>() {
  return ::calmcar::perception::Failsafe_FailSafeImageLimited_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus0> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus0>() {
  return ::calmcar::perception::MeasuringStatus0_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus1> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus1>() {
  return ::calmcar::perception::MeasuringStatus1_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus2> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus2>() {
  return ::calmcar::perception::MeasuringStatus2_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionCategory> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionCategory>() {
  return ::calmcar::perception::MotionCategory_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionOrientation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionOrientation>() {
  return ::calmcar::perception::MotionOrientation_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::VisibilitySide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::VisibilitySide>() {
  return ::calmcar::perception::VisibilitySide_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionStatusV2> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionStatusV2>() {
  return ::calmcar::perception::MotionStatusV2_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::CutInCutOut> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::CutInCutOut>() {
  return ::calmcar::perception::CutInCutOut_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::AebFollowObjectState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::AebFollowObjectState>() {
  return ::calmcar::perception::AebFollowObjectState_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::CipvLost> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::CipvLost>() {
  return ::calmcar::perception::CipvLost_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::AllowAcc> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::AllowAcc>() {
  return ::calmcar::perception::AllowAcc_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_2eproto__INCLUDED
