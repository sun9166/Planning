// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: decision_config.proto

#ifndef PROTOBUF_decision_5fconfig_2eproto__INCLUDED
#define PROTOBUF_decision_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_decision_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsIntentionDeciderConfigImpl();
void InitDefaultsIntentionDeciderConfig();
void InitDefaultsReferenceLineDeciderConfigImpl();
void InitDefaultsReferenceLineDeciderConfig();
void InitDefaultsObjectDeciderConfigImpl();
void InitDefaultsObjectDeciderConfig();
void InitDefaultsParkingDeciderConfigImpl();
void InitDefaultsParkingDeciderConfig();
void InitDefaultsDeciderConfigImpl();
void InitDefaultsDeciderConfig();
inline void InitDefaults() {
  InitDefaultsIntentionDeciderConfig();
  InitDefaultsReferenceLineDeciderConfig();
  InitDefaultsObjectDeciderConfig();
  InitDefaultsParkingDeciderConfig();
  InitDefaultsDeciderConfig();
}
}  // namespace protobuf_decision_5fconfig_2eproto
namespace acu {
namespace planning {
class DeciderConfig;
class DeciderConfigDefaultTypeInternal;
extern DeciderConfigDefaultTypeInternal _DeciderConfig_default_instance_;
class IntentionDeciderConfig;
class IntentionDeciderConfigDefaultTypeInternal;
extern IntentionDeciderConfigDefaultTypeInternal _IntentionDeciderConfig_default_instance_;
class ObjectDeciderConfig;
class ObjectDeciderConfigDefaultTypeInternal;
extern ObjectDeciderConfigDefaultTypeInternal _ObjectDeciderConfig_default_instance_;
class ParkingDeciderConfig;
class ParkingDeciderConfigDefaultTypeInternal;
extern ParkingDeciderConfigDefaultTypeInternal _ParkingDeciderConfig_default_instance_;
class ReferenceLineDeciderConfig;
class ReferenceLineDeciderConfigDefaultTypeInternal;
extern ReferenceLineDeciderConfigDefaultTypeInternal _ReferenceLineDeciderConfig_default_instance_;
}  // namespace planning
}  // namespace acu
namespace acu {
namespace planning {

// ===================================================================

class IntentionDeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.IntentionDeciderConfig) */ {
 public:
  IntentionDeciderConfig();
  virtual ~IntentionDeciderConfig();

  IntentionDeciderConfig(const IntentionDeciderConfig& from);

  inline IntentionDeciderConfig& operator=(const IntentionDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntentionDeciderConfig(IntentionDeciderConfig&& from) noexcept
    : IntentionDeciderConfig() {
    *this = ::std::move(from);
  }

  inline IntentionDeciderConfig& operator=(IntentionDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntentionDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntentionDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const IntentionDeciderConfig*>(
               &_IntentionDeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(IntentionDeciderConfig* other);
  friend void swap(IntentionDeciderConfig& a, IntentionDeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntentionDeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  IntentionDeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IntentionDeciderConfig& from);
  void MergeFrom(const IntentionDeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IntentionDeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool offset_enable = 1;
  bool has_offset_enable() const;
  void clear_offset_enable();
  static const int kOffsetEnableFieldNumber = 1;
  bool offset_enable() const;
  void set_offset_enable(bool value);

  // optional bool abandon_lc_enable = 2;
  bool has_abandon_lc_enable() const;
  void clear_abandon_lc_enable();
  static const int kAbandonLcEnableFieldNumber = 2;
  bool abandon_lc_enable() const;
  void set_abandon_lc_enable(bool value);

  // optional bool mission_lc_enable = 3;
  bool has_mission_lc_enable() const;
  void clear_mission_lc_enable();
  static const int kMissionLcEnableFieldNumber = 3;
  bool mission_lc_enable() const;
  void set_mission_lc_enable(bool value);

  // optional bool speed_lc_enable = 4;
  bool has_speed_lc_enable() const;
  void clear_speed_lc_enable();
  static const int kSpeedLcEnableFieldNumber = 4;
  bool speed_lc_enable() const;
  void set_speed_lc_enable(bool value);

  // optional bool obstacle_enable = 5;
  bool has_obstacle_enable() const;
  void clear_obstacle_enable();
  static const int kObstacleEnableFieldNumber = 5;
  bool obstacle_enable() const;
  void set_obstacle_enable(bool value);

  // optional bool pull_over_enable = 6;
  bool has_pull_over_enable() const;
  void clear_pull_over_enable();
  static const int kPullOverEnableFieldNumber = 6;
  bool pull_over_enable() const;
  void set_pull_over_enable(bool value);

  // optional bool meeting_enable = 7;
  bool has_meeting_enable() const;
  void clear_meeting_enable();
  static const int kMeetingEnableFieldNumber = 7;
  bool meeting_enable() const;
  void set_meeting_enable(bool value);

  // optional bool command_lc_enable = 8;
  bool has_command_lc_enable() const;
  void clear_command_lc_enable();
  static const int kCommandLcEnableFieldNumber = 8;
  bool command_lc_enable() const;
  void set_command_lc_enable(bool value);

  // optional bool departure_enable = 9;
  bool has_departure_enable() const;
  void clear_departure_enable();
  static const int kDepartureEnableFieldNumber = 9;
  bool departure_enable() const;
  void set_departure_enable(bool value);

  // @@protoc_insertion_point(class_scope:acu.planning.IntentionDeciderConfig)
 private:
  void set_has_offset_enable();
  void clear_has_offset_enable();
  void set_has_abandon_lc_enable();
  void clear_has_abandon_lc_enable();
  void set_has_mission_lc_enable();
  void clear_has_mission_lc_enable();
  void set_has_speed_lc_enable();
  void clear_has_speed_lc_enable();
  void set_has_obstacle_enable();
  void clear_has_obstacle_enable();
  void set_has_pull_over_enable();
  void clear_has_pull_over_enable();
  void set_has_meeting_enable();
  void clear_has_meeting_enable();
  void set_has_command_lc_enable();
  void clear_has_command_lc_enable();
  void set_has_departure_enable();
  void clear_has_departure_enable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool offset_enable_;
  bool abandon_lc_enable_;
  bool mission_lc_enable_;
  bool speed_lc_enable_;
  bool obstacle_enable_;
  bool pull_over_enable_;
  bool meeting_enable_;
  bool command_lc_enable_;
  bool departure_enable_;
  friend struct ::protobuf_decision_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_decision_5fconfig_2eproto::InitDefaultsIntentionDeciderConfigImpl();
};
// -------------------------------------------------------------------

class ReferenceLineDeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.ReferenceLineDeciderConfig) */ {
 public:
  ReferenceLineDeciderConfig();
  virtual ~ReferenceLineDeciderConfig();

  ReferenceLineDeciderConfig(const ReferenceLineDeciderConfig& from);

  inline ReferenceLineDeciderConfig& operator=(const ReferenceLineDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceLineDeciderConfig(ReferenceLineDeciderConfig&& from) noexcept
    : ReferenceLineDeciderConfig() {
    *this = ::std::move(from);
  }

  inline ReferenceLineDeciderConfig& operator=(ReferenceLineDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceLineDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceLineDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineDeciderConfig*>(
               &_ReferenceLineDeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ReferenceLineDeciderConfig* other);
  friend void swap(ReferenceLineDeciderConfig& a, ReferenceLineDeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceLineDeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ReferenceLineDeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReferenceLineDeciderConfig& from);
  void MergeFrom(const ReferenceLineDeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReferenceLineDeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double dis_to_line = 3;
  bool has_dis_to_line() const;
  void clear_dis_to_line();
  static const int kDisToLineFieldNumber = 3;
  double dis_to_line() const;
  void set_dis_to_line(double value);

  // optional double dis_to_curb = 4;
  bool has_dis_to_curb() const;
  void clear_dis_to_curb();
  static const int kDisToCurbFieldNumber = 4;
  double dis_to_curb() const;
  void set_dis_to_curb(double value);

  // optional bool borrow_lane_enable = 1;
  bool has_borrow_lane_enable() const;
  void clear_borrow_lane_enable();
  static const int kBorrowLaneEnableFieldNumber = 1;
  bool borrow_lane_enable() const;
  void set_borrow_lane_enable(bool value);

  // optional bool borrow_road_enable = 2;
  bool has_borrow_road_enable() const;
  void clear_borrow_road_enable();
  static const int kBorrowRoadEnableFieldNumber = 2;
  bool borrow_road_enable() const;
  void set_borrow_road_enable(bool value);

  // @@protoc_insertion_point(class_scope:acu.planning.ReferenceLineDeciderConfig)
 private:
  void set_has_borrow_lane_enable();
  void clear_has_borrow_lane_enable();
  void set_has_borrow_road_enable();
  void clear_has_borrow_road_enable();
  void set_has_dis_to_line();
  void clear_has_dis_to_line();
  void set_has_dis_to_curb();
  void clear_has_dis_to_curb();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double dis_to_line_;
  double dis_to_curb_;
  bool borrow_lane_enable_;
  bool borrow_road_enable_;
  friend struct ::protobuf_decision_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_decision_5fconfig_2eproto::InitDefaultsReferenceLineDeciderConfigImpl();
};
// -------------------------------------------------------------------

class ObjectDeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.ObjectDeciderConfig) */ {
 public:
  ObjectDeciderConfig();
  virtual ~ObjectDeciderConfig();

  ObjectDeciderConfig(const ObjectDeciderConfig& from);

  inline ObjectDeciderConfig& operator=(const ObjectDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectDeciderConfig(ObjectDeciderConfig&& from) noexcept
    : ObjectDeciderConfig() {
    *this = ::std::move(from);
  }

  inline ObjectDeciderConfig& operator=(ObjectDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const ObjectDeciderConfig*>(
               &_ObjectDeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ObjectDeciderConfig* other);
  friend void swap(ObjectDeciderConfig& a, ObjectDeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectDeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectDeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObjectDeciderConfig& from);
  void MergeFrom(const ObjectDeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObjectDeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double dis_to_stop = 1;
  bool has_dis_to_stop() const;
  void clear_dis_to_stop();
  static const int kDisToStopFieldNumber = 1;
  double dis_to_stop() const;
  void set_dis_to_stop(double value);

  // optional double replan_speed_limit = 4;
  bool has_replan_speed_limit() const;
  void clear_replan_speed_limit();
  static const int kReplanSpeedLimitFieldNumber = 4;
  double replan_speed_limit() const;
  void set_replan_speed_limit(double value);

  // optional bool yield_enable = 2;
  bool has_yield_enable() const;
  void clear_yield_enable();
  static const int kYieldEnableFieldNumber = 2;
  bool yield_enable() const;
  void set_yield_enable(bool value);

  // optional bool replan_slow_enable = 3;
  bool has_replan_slow_enable() const;
  void clear_replan_slow_enable();
  static const int kReplanSlowEnableFieldNumber = 3;
  bool replan_slow_enable() const;
  void set_replan_slow_enable(bool value);

  // @@protoc_insertion_point(class_scope:acu.planning.ObjectDeciderConfig)
 private:
  void set_has_dis_to_stop();
  void clear_has_dis_to_stop();
  void set_has_yield_enable();
  void clear_has_yield_enable();
  void set_has_replan_slow_enable();
  void clear_has_replan_slow_enable();
  void set_has_replan_speed_limit();
  void clear_has_replan_speed_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double dis_to_stop_;
  double replan_speed_limit_;
  bool yield_enable_;
  bool replan_slow_enable_;
  friend struct ::protobuf_decision_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_decision_5fconfig_2eproto::InitDefaultsObjectDeciderConfigImpl();
};
// -------------------------------------------------------------------

class ParkingDeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.ParkingDeciderConfig) */ {
 public:
  ParkingDeciderConfig();
  virtual ~ParkingDeciderConfig();

  ParkingDeciderConfig(const ParkingDeciderConfig& from);

  inline ParkingDeciderConfig& operator=(const ParkingDeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingDeciderConfig(ParkingDeciderConfig&& from) noexcept
    : ParkingDeciderConfig() {
    *this = ::std::move(from);
  }

  inline ParkingDeciderConfig& operator=(ParkingDeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingDeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingDeciderConfig* internal_default_instance() {
    return reinterpret_cast<const ParkingDeciderConfig*>(
               &_ParkingDeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ParkingDeciderConfig* other);
  friend void swap(ParkingDeciderConfig& a, ParkingDeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingDeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingDeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingDeciderConfig& from);
  void MergeFrom(const ParkingDeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingDeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double cruise_speed = 1;
  bool has_cruise_speed() const;
  void clear_cruise_speed();
  static const int kCruiseSpeedFieldNumber = 1;
  double cruise_speed() const;
  void set_cruise_speed(double value);

  // optional double allowable_offset = 2;
  bool has_allowable_offset() const;
  void clear_allowable_offset();
  static const int kAllowableOffsetFieldNumber = 2;
  double allowable_offset() const;
  void set_allowable_offset(double value);

  // optional double front_space = 3;
  bool has_front_space() const;
  void clear_front_space();
  static const int kFrontSpaceFieldNumber = 3;
  double front_space() const;
  void set_front_space(double value);

  // optional double back_space = 4;
  bool has_back_space() const;
  void clear_back_space();
  static const int kBackSpaceFieldNumber = 4;
  double back_space() const;
  void set_back_space(double value);

  // @@protoc_insertion_point(class_scope:acu.planning.ParkingDeciderConfig)
 private:
  void set_has_cruise_speed();
  void clear_has_cruise_speed();
  void set_has_allowable_offset();
  void clear_has_allowable_offset();
  void set_has_front_space();
  void clear_has_front_space();
  void set_has_back_space();
  void clear_has_back_space();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double cruise_speed_;
  double allowable_offset_;
  double front_space_;
  double back_space_;
  friend struct ::protobuf_decision_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_decision_5fconfig_2eproto::InitDefaultsParkingDeciderConfigImpl();
};
// -------------------------------------------------------------------

class DeciderConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.planning.DeciderConfig) */ {
 public:
  DeciderConfig();
  virtual ~DeciderConfig();

  DeciderConfig(const DeciderConfig& from);

  inline DeciderConfig& operator=(const DeciderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeciderConfig(DeciderConfig&& from) noexcept
    : DeciderConfig() {
    *this = ::std::move(from);
  }

  inline DeciderConfig& operator=(DeciderConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeciderConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeciderConfig* internal_default_instance() {
    return reinterpret_cast<const DeciderConfig*>(
               &_DeciderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DeciderConfig* other);
  friend void swap(DeciderConfig& a, DeciderConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeciderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DeciderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeciderConfig& from);
  void MergeFrom(const DeciderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeciderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.planning.IntentionDeciderConfig intention = 1;
  bool has_intention() const;
  void clear_intention();
  static const int kIntentionFieldNumber = 1;
  const ::acu::planning::IntentionDeciderConfig& intention() const;
  ::acu::planning::IntentionDeciderConfig* release_intention();
  ::acu::planning::IntentionDeciderConfig* mutable_intention();
  void set_allocated_intention(::acu::planning::IntentionDeciderConfig* intention);

  // optional .acu.planning.ReferenceLineDeciderConfig reference_line = 2;
  bool has_reference_line() const;
  void clear_reference_line();
  static const int kReferenceLineFieldNumber = 2;
  const ::acu::planning::ReferenceLineDeciderConfig& reference_line() const;
  ::acu::planning::ReferenceLineDeciderConfig* release_reference_line();
  ::acu::planning::ReferenceLineDeciderConfig* mutable_reference_line();
  void set_allocated_reference_line(::acu::planning::ReferenceLineDeciderConfig* reference_line);

  // optional .acu.planning.ObjectDeciderConfig object = 3;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 3;
  const ::acu::planning::ObjectDeciderConfig& object() const;
  ::acu::planning::ObjectDeciderConfig* release_object();
  ::acu::planning::ObjectDeciderConfig* mutable_object();
  void set_allocated_object(::acu::planning::ObjectDeciderConfig* object);

  // optional .acu.planning.ParkingDeciderConfig parking = 4;
  bool has_parking() const;
  void clear_parking();
  static const int kParkingFieldNumber = 4;
  const ::acu::planning::ParkingDeciderConfig& parking() const;
  ::acu::planning::ParkingDeciderConfig* release_parking();
  ::acu::planning::ParkingDeciderConfig* mutable_parking();
  void set_allocated_parking(::acu::planning::ParkingDeciderConfig* parking);

  // @@protoc_insertion_point(class_scope:acu.planning.DeciderConfig)
 private:
  void set_has_intention();
  void clear_has_intention();
  void set_has_reference_line();
  void clear_has_reference_line();
  void set_has_object();
  void clear_has_object();
  void set_has_parking();
  void clear_has_parking();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::planning::IntentionDeciderConfig* intention_;
  ::acu::planning::ReferenceLineDeciderConfig* reference_line_;
  ::acu::planning::ObjectDeciderConfig* object_;
  ::acu::planning::ParkingDeciderConfig* parking_;
  friend struct ::protobuf_decision_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_decision_5fconfig_2eproto::InitDefaultsDeciderConfigImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IntentionDeciderConfig

// optional bool offset_enable = 1;
inline bool IntentionDeciderConfig::has_offset_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntentionDeciderConfig::set_has_offset_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntentionDeciderConfig::clear_has_offset_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntentionDeciderConfig::clear_offset_enable() {
  offset_enable_ = false;
  clear_has_offset_enable();
}
inline bool IntentionDeciderConfig::offset_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.offset_enable)
  return offset_enable_;
}
inline void IntentionDeciderConfig::set_offset_enable(bool value) {
  set_has_offset_enable();
  offset_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.offset_enable)
}

// optional bool abandon_lc_enable = 2;
inline bool IntentionDeciderConfig::has_abandon_lc_enable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntentionDeciderConfig::set_has_abandon_lc_enable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntentionDeciderConfig::clear_has_abandon_lc_enable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntentionDeciderConfig::clear_abandon_lc_enable() {
  abandon_lc_enable_ = false;
  clear_has_abandon_lc_enable();
}
inline bool IntentionDeciderConfig::abandon_lc_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.abandon_lc_enable)
  return abandon_lc_enable_;
}
inline void IntentionDeciderConfig::set_abandon_lc_enable(bool value) {
  set_has_abandon_lc_enable();
  abandon_lc_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.abandon_lc_enable)
}

// optional bool mission_lc_enable = 3;
inline bool IntentionDeciderConfig::has_mission_lc_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntentionDeciderConfig::set_has_mission_lc_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntentionDeciderConfig::clear_has_mission_lc_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntentionDeciderConfig::clear_mission_lc_enable() {
  mission_lc_enable_ = false;
  clear_has_mission_lc_enable();
}
inline bool IntentionDeciderConfig::mission_lc_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.mission_lc_enable)
  return mission_lc_enable_;
}
inline void IntentionDeciderConfig::set_mission_lc_enable(bool value) {
  set_has_mission_lc_enable();
  mission_lc_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.mission_lc_enable)
}

// optional bool speed_lc_enable = 4;
inline bool IntentionDeciderConfig::has_speed_lc_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntentionDeciderConfig::set_has_speed_lc_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntentionDeciderConfig::clear_has_speed_lc_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntentionDeciderConfig::clear_speed_lc_enable() {
  speed_lc_enable_ = false;
  clear_has_speed_lc_enable();
}
inline bool IntentionDeciderConfig::speed_lc_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.speed_lc_enable)
  return speed_lc_enable_;
}
inline void IntentionDeciderConfig::set_speed_lc_enable(bool value) {
  set_has_speed_lc_enable();
  speed_lc_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.speed_lc_enable)
}

// optional bool obstacle_enable = 5;
inline bool IntentionDeciderConfig::has_obstacle_enable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IntentionDeciderConfig::set_has_obstacle_enable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IntentionDeciderConfig::clear_has_obstacle_enable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IntentionDeciderConfig::clear_obstacle_enable() {
  obstacle_enable_ = false;
  clear_has_obstacle_enable();
}
inline bool IntentionDeciderConfig::obstacle_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.obstacle_enable)
  return obstacle_enable_;
}
inline void IntentionDeciderConfig::set_obstacle_enable(bool value) {
  set_has_obstacle_enable();
  obstacle_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.obstacle_enable)
}

// optional bool pull_over_enable = 6;
inline bool IntentionDeciderConfig::has_pull_over_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IntentionDeciderConfig::set_has_pull_over_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IntentionDeciderConfig::clear_has_pull_over_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IntentionDeciderConfig::clear_pull_over_enable() {
  pull_over_enable_ = false;
  clear_has_pull_over_enable();
}
inline bool IntentionDeciderConfig::pull_over_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.pull_over_enable)
  return pull_over_enable_;
}
inline void IntentionDeciderConfig::set_pull_over_enable(bool value) {
  set_has_pull_over_enable();
  pull_over_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.pull_over_enable)
}

// optional bool meeting_enable = 7;
inline bool IntentionDeciderConfig::has_meeting_enable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IntentionDeciderConfig::set_has_meeting_enable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IntentionDeciderConfig::clear_has_meeting_enable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IntentionDeciderConfig::clear_meeting_enable() {
  meeting_enable_ = false;
  clear_has_meeting_enable();
}
inline bool IntentionDeciderConfig::meeting_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.meeting_enable)
  return meeting_enable_;
}
inline void IntentionDeciderConfig::set_meeting_enable(bool value) {
  set_has_meeting_enable();
  meeting_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.meeting_enable)
}

// optional bool command_lc_enable = 8;
inline bool IntentionDeciderConfig::has_command_lc_enable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IntentionDeciderConfig::set_has_command_lc_enable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IntentionDeciderConfig::clear_has_command_lc_enable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IntentionDeciderConfig::clear_command_lc_enable() {
  command_lc_enable_ = false;
  clear_has_command_lc_enable();
}
inline bool IntentionDeciderConfig::command_lc_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.command_lc_enable)
  return command_lc_enable_;
}
inline void IntentionDeciderConfig::set_command_lc_enable(bool value) {
  set_has_command_lc_enable();
  command_lc_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.command_lc_enable)
}

// optional bool departure_enable = 9;
inline bool IntentionDeciderConfig::has_departure_enable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IntentionDeciderConfig::set_has_departure_enable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IntentionDeciderConfig::clear_has_departure_enable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IntentionDeciderConfig::clear_departure_enable() {
  departure_enable_ = false;
  clear_has_departure_enable();
}
inline bool IntentionDeciderConfig::departure_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.IntentionDeciderConfig.departure_enable)
  return departure_enable_;
}
inline void IntentionDeciderConfig::set_departure_enable(bool value) {
  set_has_departure_enable();
  departure_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.IntentionDeciderConfig.departure_enable)
}

// -------------------------------------------------------------------

// ReferenceLineDeciderConfig

// optional bool borrow_lane_enable = 1;
inline bool ReferenceLineDeciderConfig::has_borrow_lane_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReferenceLineDeciderConfig::set_has_borrow_lane_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReferenceLineDeciderConfig::clear_has_borrow_lane_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReferenceLineDeciderConfig::clear_borrow_lane_enable() {
  borrow_lane_enable_ = false;
  clear_has_borrow_lane_enable();
}
inline bool ReferenceLineDeciderConfig::borrow_lane_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.ReferenceLineDeciderConfig.borrow_lane_enable)
  return borrow_lane_enable_;
}
inline void ReferenceLineDeciderConfig::set_borrow_lane_enable(bool value) {
  set_has_borrow_lane_enable();
  borrow_lane_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ReferenceLineDeciderConfig.borrow_lane_enable)
}

// optional bool borrow_road_enable = 2;
inline bool ReferenceLineDeciderConfig::has_borrow_road_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReferenceLineDeciderConfig::set_has_borrow_road_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReferenceLineDeciderConfig::clear_has_borrow_road_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReferenceLineDeciderConfig::clear_borrow_road_enable() {
  borrow_road_enable_ = false;
  clear_has_borrow_road_enable();
}
inline bool ReferenceLineDeciderConfig::borrow_road_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.ReferenceLineDeciderConfig.borrow_road_enable)
  return borrow_road_enable_;
}
inline void ReferenceLineDeciderConfig::set_borrow_road_enable(bool value) {
  set_has_borrow_road_enable();
  borrow_road_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ReferenceLineDeciderConfig.borrow_road_enable)
}

// optional double dis_to_line = 3;
inline bool ReferenceLineDeciderConfig::has_dis_to_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceLineDeciderConfig::set_has_dis_to_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceLineDeciderConfig::clear_has_dis_to_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceLineDeciderConfig::clear_dis_to_line() {
  dis_to_line_ = 0;
  clear_has_dis_to_line();
}
inline double ReferenceLineDeciderConfig::dis_to_line() const {
  // @@protoc_insertion_point(field_get:acu.planning.ReferenceLineDeciderConfig.dis_to_line)
  return dis_to_line_;
}
inline void ReferenceLineDeciderConfig::set_dis_to_line(double value) {
  set_has_dis_to_line();
  dis_to_line_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ReferenceLineDeciderConfig.dis_to_line)
}

// optional double dis_to_curb = 4;
inline bool ReferenceLineDeciderConfig::has_dis_to_curb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceLineDeciderConfig::set_has_dis_to_curb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceLineDeciderConfig::clear_has_dis_to_curb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceLineDeciderConfig::clear_dis_to_curb() {
  dis_to_curb_ = 0;
  clear_has_dis_to_curb();
}
inline double ReferenceLineDeciderConfig::dis_to_curb() const {
  // @@protoc_insertion_point(field_get:acu.planning.ReferenceLineDeciderConfig.dis_to_curb)
  return dis_to_curb_;
}
inline void ReferenceLineDeciderConfig::set_dis_to_curb(double value) {
  set_has_dis_to_curb();
  dis_to_curb_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ReferenceLineDeciderConfig.dis_to_curb)
}

// -------------------------------------------------------------------

// ObjectDeciderConfig

// optional double dis_to_stop = 1;
inline bool ObjectDeciderConfig::has_dis_to_stop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectDeciderConfig::set_has_dis_to_stop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectDeciderConfig::clear_has_dis_to_stop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectDeciderConfig::clear_dis_to_stop() {
  dis_to_stop_ = 0;
  clear_has_dis_to_stop();
}
inline double ObjectDeciderConfig::dis_to_stop() const {
  // @@protoc_insertion_point(field_get:acu.planning.ObjectDeciderConfig.dis_to_stop)
  return dis_to_stop_;
}
inline void ObjectDeciderConfig::set_dis_to_stop(double value) {
  set_has_dis_to_stop();
  dis_to_stop_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ObjectDeciderConfig.dis_to_stop)
}

// optional bool yield_enable = 2;
inline bool ObjectDeciderConfig::has_yield_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectDeciderConfig::set_has_yield_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectDeciderConfig::clear_has_yield_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectDeciderConfig::clear_yield_enable() {
  yield_enable_ = false;
  clear_has_yield_enable();
}
inline bool ObjectDeciderConfig::yield_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.ObjectDeciderConfig.yield_enable)
  return yield_enable_;
}
inline void ObjectDeciderConfig::set_yield_enable(bool value) {
  set_has_yield_enable();
  yield_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ObjectDeciderConfig.yield_enable)
}

// optional bool replan_slow_enable = 3;
inline bool ObjectDeciderConfig::has_replan_slow_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectDeciderConfig::set_has_replan_slow_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectDeciderConfig::clear_has_replan_slow_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectDeciderConfig::clear_replan_slow_enable() {
  replan_slow_enable_ = false;
  clear_has_replan_slow_enable();
}
inline bool ObjectDeciderConfig::replan_slow_enable() const {
  // @@protoc_insertion_point(field_get:acu.planning.ObjectDeciderConfig.replan_slow_enable)
  return replan_slow_enable_;
}
inline void ObjectDeciderConfig::set_replan_slow_enable(bool value) {
  set_has_replan_slow_enable();
  replan_slow_enable_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ObjectDeciderConfig.replan_slow_enable)
}

// optional double replan_speed_limit = 4;
inline bool ObjectDeciderConfig::has_replan_speed_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectDeciderConfig::set_has_replan_speed_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectDeciderConfig::clear_has_replan_speed_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectDeciderConfig::clear_replan_speed_limit() {
  replan_speed_limit_ = 0;
  clear_has_replan_speed_limit();
}
inline double ObjectDeciderConfig::replan_speed_limit() const {
  // @@protoc_insertion_point(field_get:acu.planning.ObjectDeciderConfig.replan_speed_limit)
  return replan_speed_limit_;
}
inline void ObjectDeciderConfig::set_replan_speed_limit(double value) {
  set_has_replan_speed_limit();
  replan_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ObjectDeciderConfig.replan_speed_limit)
}

// -------------------------------------------------------------------

// ParkingDeciderConfig

// optional double cruise_speed = 1;
inline bool ParkingDeciderConfig::has_cruise_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkingDeciderConfig::set_has_cruise_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkingDeciderConfig::clear_has_cruise_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkingDeciderConfig::clear_cruise_speed() {
  cruise_speed_ = 0;
  clear_has_cruise_speed();
}
inline double ParkingDeciderConfig::cruise_speed() const {
  // @@protoc_insertion_point(field_get:acu.planning.ParkingDeciderConfig.cruise_speed)
  return cruise_speed_;
}
inline void ParkingDeciderConfig::set_cruise_speed(double value) {
  set_has_cruise_speed();
  cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ParkingDeciderConfig.cruise_speed)
}

// optional double allowable_offset = 2;
inline bool ParkingDeciderConfig::has_allowable_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkingDeciderConfig::set_has_allowable_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkingDeciderConfig::clear_has_allowable_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkingDeciderConfig::clear_allowable_offset() {
  allowable_offset_ = 0;
  clear_has_allowable_offset();
}
inline double ParkingDeciderConfig::allowable_offset() const {
  // @@protoc_insertion_point(field_get:acu.planning.ParkingDeciderConfig.allowable_offset)
  return allowable_offset_;
}
inline void ParkingDeciderConfig::set_allowable_offset(double value) {
  set_has_allowable_offset();
  allowable_offset_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ParkingDeciderConfig.allowable_offset)
}

// optional double front_space = 3;
inline bool ParkingDeciderConfig::has_front_space() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParkingDeciderConfig::set_has_front_space() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParkingDeciderConfig::clear_has_front_space() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParkingDeciderConfig::clear_front_space() {
  front_space_ = 0;
  clear_has_front_space();
}
inline double ParkingDeciderConfig::front_space() const {
  // @@protoc_insertion_point(field_get:acu.planning.ParkingDeciderConfig.front_space)
  return front_space_;
}
inline void ParkingDeciderConfig::set_front_space(double value) {
  set_has_front_space();
  front_space_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ParkingDeciderConfig.front_space)
}

// optional double back_space = 4;
inline bool ParkingDeciderConfig::has_back_space() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParkingDeciderConfig::set_has_back_space() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParkingDeciderConfig::clear_has_back_space() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParkingDeciderConfig::clear_back_space() {
  back_space_ = 0;
  clear_has_back_space();
}
inline double ParkingDeciderConfig::back_space() const {
  // @@protoc_insertion_point(field_get:acu.planning.ParkingDeciderConfig.back_space)
  return back_space_;
}
inline void ParkingDeciderConfig::set_back_space(double value) {
  set_has_back_space();
  back_space_ = value;
  // @@protoc_insertion_point(field_set:acu.planning.ParkingDeciderConfig.back_space)
}

// -------------------------------------------------------------------

// DeciderConfig

// optional .acu.planning.IntentionDeciderConfig intention = 1;
inline bool DeciderConfig::has_intention() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeciderConfig::set_has_intention() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeciderConfig::clear_has_intention() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeciderConfig::clear_intention() {
  if (intention_ != NULL) intention_->Clear();
  clear_has_intention();
}
inline const ::acu::planning::IntentionDeciderConfig& DeciderConfig::intention() const {
  const ::acu::planning::IntentionDeciderConfig* p = intention_;
  // @@protoc_insertion_point(field_get:acu.planning.DeciderConfig.intention)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::IntentionDeciderConfig*>(
      &::acu::planning::_IntentionDeciderConfig_default_instance_);
}
inline ::acu::planning::IntentionDeciderConfig* DeciderConfig::release_intention() {
  // @@protoc_insertion_point(field_release:acu.planning.DeciderConfig.intention)
  clear_has_intention();
  ::acu::planning::IntentionDeciderConfig* temp = intention_;
  intention_ = NULL;
  return temp;
}
inline ::acu::planning::IntentionDeciderConfig* DeciderConfig::mutable_intention() {
  set_has_intention();
  if (intention_ == NULL) {
    intention_ = new ::acu::planning::IntentionDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.DeciderConfig.intention)
  return intention_;
}
inline void DeciderConfig::set_allocated_intention(::acu::planning::IntentionDeciderConfig* intention) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete intention_;
  }
  if (intention) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intention = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intention, submessage_arena);
    }
    set_has_intention();
  } else {
    clear_has_intention();
  }
  intention_ = intention;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.DeciderConfig.intention)
}

// optional .acu.planning.ReferenceLineDeciderConfig reference_line = 2;
inline bool DeciderConfig::has_reference_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeciderConfig::set_has_reference_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeciderConfig::clear_has_reference_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeciderConfig::clear_reference_line() {
  if (reference_line_ != NULL) reference_line_->Clear();
  clear_has_reference_line();
}
inline const ::acu::planning::ReferenceLineDeciderConfig& DeciderConfig::reference_line() const {
  const ::acu::planning::ReferenceLineDeciderConfig* p = reference_line_;
  // @@protoc_insertion_point(field_get:acu.planning.DeciderConfig.reference_line)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::ReferenceLineDeciderConfig*>(
      &::acu::planning::_ReferenceLineDeciderConfig_default_instance_);
}
inline ::acu::planning::ReferenceLineDeciderConfig* DeciderConfig::release_reference_line() {
  // @@protoc_insertion_point(field_release:acu.planning.DeciderConfig.reference_line)
  clear_has_reference_line();
  ::acu::planning::ReferenceLineDeciderConfig* temp = reference_line_;
  reference_line_ = NULL;
  return temp;
}
inline ::acu::planning::ReferenceLineDeciderConfig* DeciderConfig::mutable_reference_line() {
  set_has_reference_line();
  if (reference_line_ == NULL) {
    reference_line_ = new ::acu::planning::ReferenceLineDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.DeciderConfig.reference_line)
  return reference_line_;
}
inline void DeciderConfig::set_allocated_reference_line(::acu::planning::ReferenceLineDeciderConfig* reference_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reference_line_;
  }
  if (reference_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reference_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference_line, submessage_arena);
    }
    set_has_reference_line();
  } else {
    clear_has_reference_line();
  }
  reference_line_ = reference_line;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.DeciderConfig.reference_line)
}

// optional .acu.planning.ObjectDeciderConfig object = 3;
inline bool DeciderConfig::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeciderConfig::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeciderConfig::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeciderConfig::clear_object() {
  if (object_ != NULL) object_->Clear();
  clear_has_object();
}
inline const ::acu::planning::ObjectDeciderConfig& DeciderConfig::object() const {
  const ::acu::planning::ObjectDeciderConfig* p = object_;
  // @@protoc_insertion_point(field_get:acu.planning.DeciderConfig.object)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::ObjectDeciderConfig*>(
      &::acu::planning::_ObjectDeciderConfig_default_instance_);
}
inline ::acu::planning::ObjectDeciderConfig* DeciderConfig::release_object() {
  // @@protoc_insertion_point(field_release:acu.planning.DeciderConfig.object)
  clear_has_object();
  ::acu::planning::ObjectDeciderConfig* temp = object_;
  object_ = NULL;
  return temp;
}
inline ::acu::planning::ObjectDeciderConfig* DeciderConfig::mutable_object() {
  set_has_object();
  if (object_ == NULL) {
    object_ = new ::acu::planning::ObjectDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.DeciderConfig.object)
  return object_;
}
inline void DeciderConfig::set_allocated_object(::acu::planning::ObjectDeciderConfig* object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete object_;
  }
  if (object) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    set_has_object();
  } else {
    clear_has_object();
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.DeciderConfig.object)
}

// optional .acu.planning.ParkingDeciderConfig parking = 4;
inline bool DeciderConfig::has_parking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeciderConfig::set_has_parking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeciderConfig::clear_has_parking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeciderConfig::clear_parking() {
  if (parking_ != NULL) parking_->Clear();
  clear_has_parking();
}
inline const ::acu::planning::ParkingDeciderConfig& DeciderConfig::parking() const {
  const ::acu::planning::ParkingDeciderConfig* p = parking_;
  // @@protoc_insertion_point(field_get:acu.planning.DeciderConfig.parking)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::planning::ParkingDeciderConfig*>(
      &::acu::planning::_ParkingDeciderConfig_default_instance_);
}
inline ::acu::planning::ParkingDeciderConfig* DeciderConfig::release_parking() {
  // @@protoc_insertion_point(field_release:acu.planning.DeciderConfig.parking)
  clear_has_parking();
  ::acu::planning::ParkingDeciderConfig* temp = parking_;
  parking_ = NULL;
  return temp;
}
inline ::acu::planning::ParkingDeciderConfig* DeciderConfig::mutable_parking() {
  set_has_parking();
  if (parking_ == NULL) {
    parking_ = new ::acu::planning::ParkingDeciderConfig;
  }
  // @@protoc_insertion_point(field_mutable:acu.planning.DeciderConfig.parking)
  return parking_;
}
inline void DeciderConfig::set_allocated_parking(::acu::planning::ParkingDeciderConfig* parking) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parking_;
  }
  if (parking) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking, submessage_arena);
    }
    set_has_parking();
  } else {
    clear_has_parking();
  }
  parking_ = parking;
  // @@protoc_insertion_point(field_set_allocated:acu.planning.DeciderConfig.parking)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace acu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_decision_5fconfig_2eproto__INCLUDED
