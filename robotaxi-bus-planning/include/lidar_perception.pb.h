// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lidar_perception.proto

#ifndef PROTOBUF_lidar_5fperception_2eproto__INCLUDED
#define PROTOBUF_lidar_5fperception_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "perception_types.pb.h"
#include "perception.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_lidar_5fperception_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLidarObjectsImpl();
void InitDefaultsLidarObjects();
void InitDefaultsFreespaceSetImpl();
void InitDefaultsFreespaceSet();
void InitDefaultsLidarFreespaceImpl();
void InitDefaultsLidarFreespace();
void InitDefaultsLidarPerceptionFrameImpl();
void InitDefaultsLidarPerceptionFrame();
inline void InitDefaults() {
  InitDefaultsLidarObjects();
  InitDefaultsFreespaceSet();
  InitDefaultsLidarFreespace();
  InitDefaultsLidarPerceptionFrame();
}
}  // namespace protobuf_lidar_5fperception_2eproto
namespace calmcar {
namespace perception {
class FreespaceSet;
class FreespaceSetDefaultTypeInternal;
extern FreespaceSetDefaultTypeInternal _FreespaceSet_default_instance_;
class LidarFreespace;
class LidarFreespaceDefaultTypeInternal;
extern LidarFreespaceDefaultTypeInternal _LidarFreespace_default_instance_;
class LidarObjects;
class LidarObjectsDefaultTypeInternal;
extern LidarObjectsDefaultTypeInternal _LidarObjects_default_instance_;
class LidarPerceptionFrame;
class LidarPerceptionFrameDefaultTypeInternal;
extern LidarPerceptionFrameDefaultTypeInternal _LidarPerceptionFrame_default_instance_;
}  // namespace perception
}  // namespace calmcar
namespace calmcar {
namespace perception {

enum LidarObjects_MotionStatus {
  LidarObjects_MotionStatus_MOTION_STATUS_UNKNOWN = 0,
  LidarObjects_MotionStatus_MOTION_STATUS_PARKED = 1,
  LidarObjects_MotionStatus_MOTION_STATUS_STOPPED = 2,
  LidarObjects_MotionStatus_MOTION_STATUS_MOVING = 3,
  LidarObjects_MotionStatus_MOTION_STATUS_ONCOMING = 4,
  LidarObjects_MotionStatus_MOTION_STATUS_CROSSING = 5,
  LidarObjects_MotionStatus_LidarObjects_MotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LidarObjects_MotionStatus_LidarObjects_MotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LidarObjects_MotionStatus_IsValid(int value);
const LidarObjects_MotionStatus LidarObjects_MotionStatus_MotionStatus_MIN = LidarObjects_MotionStatus_MOTION_STATUS_UNKNOWN;
const LidarObjects_MotionStatus LidarObjects_MotionStatus_MotionStatus_MAX = LidarObjects_MotionStatus_MOTION_STATUS_CROSSING;
const int LidarObjects_MotionStatus_MotionStatus_ARRAYSIZE = LidarObjects_MotionStatus_MotionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* LidarObjects_MotionStatus_descriptor();
inline const ::std::string& LidarObjects_MotionStatus_Name(LidarObjects_MotionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    LidarObjects_MotionStatus_descriptor(), value);
}
inline bool LidarObjects_MotionStatus_Parse(
    const ::std::string& name, LidarObjects_MotionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LidarObjects_MotionStatus>(
    LidarObjects_MotionStatus_descriptor(), name, value);
}
// ===================================================================

class LidarObjects : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LidarObjects) */ {
 public:
  LidarObjects();
  virtual ~LidarObjects();

  LidarObjects(const LidarObjects& from);

  inline LidarObjects& operator=(const LidarObjects& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarObjects(LidarObjects&& from) noexcept
    : LidarObjects() {
    *this = ::std::move(from);
  }

  inline LidarObjects& operator=(LidarObjects&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarObjects& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarObjects* internal_default_instance() {
    return reinterpret_cast<const LidarObjects*>(
               &_LidarObjects_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LidarObjects* other);
  friend void swap(LidarObjects& a, LidarObjects& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarObjects* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarObjects* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarObjects& from);
  void MergeFrom(const LidarObjects& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarObjects* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LidarObjects_MotionStatus MotionStatus;
  static const MotionStatus MOTION_STATUS_UNKNOWN =
    LidarObjects_MotionStatus_MOTION_STATUS_UNKNOWN;
  static const MotionStatus MOTION_STATUS_PARKED =
    LidarObjects_MotionStatus_MOTION_STATUS_PARKED;
  static const MotionStatus MOTION_STATUS_STOPPED =
    LidarObjects_MotionStatus_MOTION_STATUS_STOPPED;
  static const MotionStatus MOTION_STATUS_MOVING =
    LidarObjects_MotionStatus_MOTION_STATUS_MOVING;
  static const MotionStatus MOTION_STATUS_ONCOMING =
    LidarObjects_MotionStatus_MOTION_STATUS_ONCOMING;
  static const MotionStatus MOTION_STATUS_CROSSING =
    LidarObjects_MotionStatus_MOTION_STATUS_CROSSING;
  static inline bool MotionStatus_IsValid(int value) {
    return LidarObjects_MotionStatus_IsValid(value);
  }
  static const MotionStatus MotionStatus_MIN =
    LidarObjects_MotionStatus_MotionStatus_MIN;
  static const MotionStatus MotionStatus_MAX =
    LidarObjects_MotionStatus_MotionStatus_MAX;
  static const int MotionStatus_ARRAYSIZE =
    LidarObjects_MotionStatus_MotionStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotionStatus_descriptor() {
    return LidarObjects_MotionStatus_descriptor();
  }
  static inline const ::std::string& MotionStatus_Name(MotionStatus value) {
    return LidarObjects_MotionStatus_Name(value);
  }
  static inline bool MotionStatus_Parse(const ::std::string& name,
      MotionStatus* value) {
    return LidarObjects_MotionStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // string subclass_name = 8;
  void clear_subclass_name();
  static const int kSubclassNameFieldNumber = 8;
  const ::std::string& subclass_name() const;
  void set_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subclass_name(::std::string&& value);
  #endif
  void set_subclass_name(const char* value);
  void set_subclass_name(const char* value, size_t size);
  ::std::string* mutable_subclass_name();
  ::std::string* release_subclass_name();
  void set_allocated_subclass_name(::std::string* subclass_name);

  // .calmcar.perception.Point relative_velocity = 13;
  bool has_relative_velocity() const;
  void clear_relative_velocity();
  static const int kRelativeVelocityFieldNumber = 13;
  const ::calmcar::perception::Point& relative_velocity() const;
  ::calmcar::perception::Point* release_relative_velocity();
  ::calmcar::perception::Point* mutable_relative_velocity();
  void set_allocated_relative_velocity(::calmcar::perception::Point* relative_velocity);

  // .calmcar.perception.Point relative_acceleration = 14;
  bool has_relative_acceleration() const;
  void clear_relative_acceleration();
  static const int kRelativeAccelerationFieldNumber = 14;
  const ::calmcar::perception::Point& relative_acceleration() const;
  ::calmcar::perception::Point* release_relative_acceleration();
  ::calmcar::perception::Point* mutable_relative_acceleration();
  void set_allocated_relative_acceleration(::calmcar::perception::Point* relative_acceleration);

  // .calmcar.perception.Point absolute_velocity = 15;
  bool has_absolute_velocity() const;
  void clear_absolute_velocity();
  static const int kAbsoluteVelocityFieldNumber = 15;
  const ::calmcar::perception::Point& absolute_velocity() const;
  ::calmcar::perception::Point* release_absolute_velocity();
  ::calmcar::perception::Point* mutable_absolute_velocity();
  void set_allocated_absolute_velocity(::calmcar::perception::Point* absolute_velocity);

  // .calmcar.perception.Point absolute_acceleration = 16;
  bool has_absolute_acceleration() const;
  void clear_absolute_acceleration();
  static const int kAbsoluteAccelerationFieldNumber = 16;
  const ::calmcar::perception::Point& absolute_acceleration() const;
  ::calmcar::perception::Point* release_absolute_acceleration();
  ::calmcar::perception::Point* mutable_absolute_acceleration();
  void set_allocated_absolute_acceleration(::calmcar::perception::Point* absolute_acceleration);

  // .calmcar.perception.Point closest_distance = 22;
  bool has_closest_distance() const;
  void clear_closest_distance();
  static const int kClosestDistanceFieldNumber = 22;
  const ::calmcar::perception::Point& closest_distance() const;
  ::calmcar::perception::Point* release_closest_distance();
  ::calmcar::perception::Point* mutable_closest_distance();
  void set_allocated_closest_distance(::calmcar::perception::Point* closest_distance);

  // .calmcar.perception.Point closest_surface_center = 23;
  bool has_closest_surface_center() const;
  void clear_closest_surface_center();
  static const int kClosestSurfaceCenterFieldNumber = 23;
  const ::calmcar::perception::Point& closest_surface_center() const;
  ::calmcar::perception::Point* release_closest_surface_center();
  ::calmcar::perception::Point* mutable_closest_surface_center();
  void set_allocated_closest_surface_center(::calmcar::perception::Point* closest_surface_center);

  // int64 frame_index = 1;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 class_ = 5;
  void clear_class_();
  static const int kClassFieldNumber = 5;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // uint32 lidar_index = 3;
  void clear_lidar_index();
  static const int kLidarIndexFieldNumber = 3;
  ::google::protobuf::uint32 lidar_index() const;
  void set_lidar_index(::google::protobuf::uint32 value);

  // float confidence = 9;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 9;
  float confidence() const;
  void set_confidence(float value);

  // int64 subclass = 7;
  void clear_subclass();
  static const int kSubclassFieldNumber = 7;
  ::google::protobuf::int64 subclass() const;
  void set_subclass(::google::protobuf::int64 value);

  // float lat_distance = 10;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 10;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float long_distance = 11;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 11;
  float long_distance() const;
  void set_long_distance(float value);

  // float vertical_distance = 12;
  void clear_vertical_distance();
  static const int kVerticalDistanceFieldNumber = 12;
  float vertical_distance() const;
  void set_vertical_distance(float value);

  // float heading = 17;
  void clear_heading();
  static const int kHeadingFieldNumber = 17;
  float heading() const;
  void set_heading(float value);

  // .calmcar.perception.LidarObjects.MotionStatus motion_status = 18;
  void clear_motion_status();
  static const int kMotionStatusFieldNumber = 18;
  ::calmcar::perception::LidarObjects_MotionStatus motion_status() const;
  void set_motion_status(::calmcar::perception::LidarObjects_MotionStatus value);

  // float width = 19;
  void clear_width();
  static const int kWidthFieldNumber = 19;
  float width() const;
  void set_width(float value);

  // float height = 20;
  void clear_height();
  static const int kHeightFieldNumber = 20;
  float height() const;
  void set_height(float value);

  // float length = 21;
  void clear_length();
  static const int kLengthFieldNumber = 21;
  float length() const;
  void set_length(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LidarObjects)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::internal::ArenaStringPtr subclass_name_;
  ::calmcar::perception::Point* relative_velocity_;
  ::calmcar::perception::Point* relative_acceleration_;
  ::calmcar::perception::Point* absolute_velocity_;
  ::calmcar::perception::Point* absolute_acceleration_;
  ::calmcar::perception::Point* closest_distance_;
  ::calmcar::perception::Point* closest_surface_center_;
  ::google::protobuf::int64 frame_index_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 class__;
  ::google::protobuf::uint32 lidar_index_;
  float confidence_;
  ::google::protobuf::int64 subclass_;
  float lat_distance_;
  float long_distance_;
  float vertical_distance_;
  float heading_;
  int motion_status_;
  float width_;
  float height_;
  float length_;
  mutable int _cached_size_;
  friend struct ::protobuf_lidar_5fperception_2eproto::TableStruct;
  friend void ::protobuf_lidar_5fperception_2eproto::InitDefaultsLidarObjectsImpl();
};
// -------------------------------------------------------------------

class FreespaceSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.FreespaceSet) */ {
 public:
  FreespaceSet();
  virtual ~FreespaceSet();

  FreespaceSet(const FreespaceSet& from);

  inline FreespaceSet& operator=(const FreespaceSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreespaceSet(FreespaceSet&& from) noexcept
    : FreespaceSet() {
    *this = ::std::move(from);
  }

  inline FreespaceSet& operator=(FreespaceSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreespaceSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreespaceSet* internal_default_instance() {
    return reinterpret_cast<const FreespaceSet*>(
               &_FreespaceSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FreespaceSet* other);
  friend void swap(FreespaceSet& a, FreespaceSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreespaceSet* New() const PROTOBUF_FINAL { return New(NULL); }

  FreespaceSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FreespaceSet& from);
  void MergeFrom(const FreespaceSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FreespaceSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // uint32 class_type = 3;
  void clear_class_type();
  static const int kClassTypeFieldNumber = 3;
  ::google::protobuf::uint32 class_type() const;
  void set_class_type(::google::protobuf::uint32 value);

  // uint32 edge = 4;
  void clear_edge();
  static const int kEdgeFieldNumber = 4;
  ::google::protobuf::uint32 edge() const;
  void set_edge(::google::protobuf::uint32 value);

  // uint32 id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // bool is_valid = 6;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 6;
  bool is_valid() const;
  void set_is_valid(bool value);

  // int64 timestamp = 8;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // float z = 7;
  void clear_z();
  static const int kZFieldNumber = 7;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.FreespaceSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  ::google::protobuf::uint32 class_type_;
  ::google::protobuf::uint32 edge_;
  ::google::protobuf::uint32 id_;
  bool is_valid_;
  ::google::protobuf::int64 timestamp_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_lidar_5fperception_2eproto::TableStruct;
  friend void ::protobuf_lidar_5fperception_2eproto::InitDefaultsFreespaceSetImpl();
};
// -------------------------------------------------------------------

class LidarFreespace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LidarFreespace) */ {
 public:
  LidarFreespace();
  virtual ~LidarFreespace();

  LidarFreespace(const LidarFreespace& from);

  inline LidarFreespace& operator=(const LidarFreespace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarFreespace(LidarFreespace&& from) noexcept
    : LidarFreespace() {
    *this = ::std::move(from);
  }

  inline LidarFreespace& operator=(LidarFreespace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarFreespace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarFreespace* internal_default_instance() {
    return reinterpret_cast<const LidarFreespace*>(
               &_LidarFreespace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LidarFreespace* other);
  friend void swap(LidarFreespace& a, LidarFreespace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarFreespace* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarFreespace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarFreespace& from);
  void MergeFrom(const LidarFreespace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarFreespace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.FreespaceSet freespace_set = 3;
  int freespace_set_size() const;
  void clear_freespace_set();
  static const int kFreespaceSetFieldNumber = 3;
  const ::calmcar::perception::FreespaceSet& freespace_set(int index) const;
  ::calmcar::perception::FreespaceSet* mutable_freespace_set(int index);
  ::calmcar::perception::FreespaceSet* add_freespace_set();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreespaceSet >*
      mutable_freespace_set();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreespaceSet >&
      freespace_set() const;

  // uint32 point_num = 1;
  void clear_point_num();
  static const int kPointNumFieldNumber = 1;
  ::google::protobuf::uint32 point_num() const;
  void set_point_num(::google::protobuf::uint32 value);

  // uint32 closed_contour = 2;
  void clear_closed_contour();
  static const int kClosedContourFieldNumber = 2;
  ::google::protobuf::uint32 closed_contour() const;
  void set_closed_contour(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LidarFreespace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreespaceSet > freespace_set_;
  ::google::protobuf::uint32 point_num_;
  ::google::protobuf::uint32 closed_contour_;
  mutable int _cached_size_;
  friend struct ::protobuf_lidar_5fperception_2eproto::TableStruct;
  friend void ::protobuf_lidar_5fperception_2eproto::InitDefaultsLidarFreespaceImpl();
};
// -------------------------------------------------------------------

class LidarPerceptionFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LidarPerceptionFrame) */ {
 public:
  LidarPerceptionFrame();
  virtual ~LidarPerceptionFrame();

  LidarPerceptionFrame(const LidarPerceptionFrame& from);

  inline LidarPerceptionFrame& operator=(const LidarPerceptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarPerceptionFrame(LidarPerceptionFrame&& from) noexcept
    : LidarPerceptionFrame() {
    *this = ::std::move(from);
  }

  inline LidarPerceptionFrame& operator=(LidarPerceptionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarPerceptionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarPerceptionFrame* internal_default_instance() {
    return reinterpret_cast<const LidarPerceptionFrame*>(
               &_LidarPerceptionFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LidarPerceptionFrame* other);
  friend void swap(LidarPerceptionFrame& a, LidarPerceptionFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarPerceptionFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarPerceptionFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarPerceptionFrame& from);
  void MergeFrom(const LidarPerceptionFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarPerceptionFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.LidarObjects lidar_object = 1;
  int lidar_object_size() const;
  void clear_lidar_object();
  static const int kLidarObjectFieldNumber = 1;
  const ::calmcar::perception::LidarObjects& lidar_object(int index) const;
  ::calmcar::perception::LidarObjects* mutable_lidar_object(int index);
  ::calmcar::perception::LidarObjects* add_lidar_object();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LidarObjects >*
      mutable_lidar_object();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LidarObjects >&
      lidar_object() const;

  // .calmcar.perception.LidarFreespace lidar_fsd = 2;
  bool has_lidar_fsd() const;
  void clear_lidar_fsd();
  static const int kLidarFsdFieldNumber = 2;
  const ::calmcar::perception::LidarFreespace& lidar_fsd() const;
  ::calmcar::perception::LidarFreespace* release_lidar_fsd();
  ::calmcar::perception::LidarFreespace* mutable_lidar_fsd();
  void set_allocated_lidar_fsd(::calmcar::perception::LidarFreespace* lidar_fsd);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LidarPerceptionFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LidarObjects > lidar_object_;
  ::calmcar::perception::LidarFreespace* lidar_fsd_;
  mutable int _cached_size_;
  friend struct ::protobuf_lidar_5fperception_2eproto::TableStruct;
  friend void ::protobuf_lidar_5fperception_2eproto::InitDefaultsLidarPerceptionFrameImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LidarObjects

// int64 frame_index = 1;
inline void LidarObjects::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LidarObjects::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.frame_index)
  return frame_index_;
}
inline void LidarObjects::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.frame_index)
}

// int64 timestamp = 2;
inline void LidarObjects::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LidarObjects::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.timestamp)
  return timestamp_;
}
inline void LidarObjects::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.timestamp)
}

// uint32 lidar_index = 3;
inline void LidarObjects::clear_lidar_index() {
  lidar_index_ = 0u;
}
inline ::google::protobuf::uint32 LidarObjects::lidar_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.lidar_index)
  return lidar_index_;
}
inline void LidarObjects::set_lidar_index(::google::protobuf::uint32 value) {
  
  lidar_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.lidar_index)
}

// int64 id = 4;
inline void LidarObjects::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LidarObjects::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.id)
  return id_;
}
inline void LidarObjects::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.id)
}

// int64 class_ = 5;
inline void LidarObjects::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LidarObjects::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.class_)
  return class__;
}
inline void LidarObjects::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.class_)
}

// string class_name = 6;
inline void LidarObjects::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarObjects::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.class_name)
  return class_name_.GetNoArena();
}
inline void LidarObjects::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.class_name)
}
#if LANG_CXX11
inline void LidarObjects::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.LidarObjects.class_name)
}
#endif
inline void LidarObjects::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.LidarObjects.class_name)
}
inline void LidarObjects::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.LidarObjects.class_name)
}
inline ::std::string* LidarObjects::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarObjects::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarObjects::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.class_name)
}

// int64 subclass = 7;
inline void LidarObjects::clear_subclass() {
  subclass_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LidarObjects::subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.subclass)
  return subclass_;
}
inline void LidarObjects::set_subclass(::google::protobuf::int64 value) {
  
  subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.subclass)
}

// string subclass_name = 8;
inline void LidarObjects::clear_subclass_name() {
  subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarObjects::subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.subclass_name)
  return subclass_name_.GetNoArena();
}
inline void LidarObjects::set_subclass_name(const ::std::string& value) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.subclass_name)
}
#if LANG_CXX11
inline void LidarObjects::set_subclass_name(::std::string&& value) {
  
  subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.LidarObjects.subclass_name)
}
#endif
inline void LidarObjects::set_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.LidarObjects.subclass_name)
}
inline void LidarObjects::set_subclass_name(const char* value, size_t size) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.LidarObjects.subclass_name)
}
inline ::std::string* LidarObjects::mutable_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.subclass_name)
  return subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarObjects::release_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.subclass_name)
  
  return subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarObjects::set_allocated_subclass_name(::std::string* subclass_name) {
  if (subclass_name != NULL) {
    
  } else {
    
  }
  subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.subclass_name)
}

// float confidence = 9;
inline void LidarObjects::clear_confidence() {
  confidence_ = 0;
}
inline float LidarObjects::confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.confidence)
  return confidence_;
}
inline void LidarObjects::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.confidence)
}

// float lat_distance = 10;
inline void LidarObjects::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float LidarObjects::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.lat_distance)
  return lat_distance_;
}
inline void LidarObjects::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.lat_distance)
}

// float long_distance = 11;
inline void LidarObjects::clear_long_distance() {
  long_distance_ = 0;
}
inline float LidarObjects::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.long_distance)
  return long_distance_;
}
inline void LidarObjects::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.long_distance)
}

// float vertical_distance = 12;
inline void LidarObjects::clear_vertical_distance() {
  vertical_distance_ = 0;
}
inline float LidarObjects::vertical_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.vertical_distance)
  return vertical_distance_;
}
inline void LidarObjects::set_vertical_distance(float value) {
  
  vertical_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.vertical_distance)
}

// .calmcar.perception.Point relative_velocity = 13;
inline bool LidarObjects::has_relative_velocity() const {
  return this != internal_default_instance() && relative_velocity_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::relative_velocity() const {
  const ::calmcar::perception::Point* p = relative_velocity_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.relative_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_relative_velocity() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.relative_velocity)
  
  ::calmcar::perception::Point* temp = relative_velocity_;
  relative_velocity_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_relative_velocity() {
  
  if (relative_velocity_ == NULL) {
    relative_velocity_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.relative_velocity)
  return relative_velocity_;
}
inline void LidarObjects::set_allocated_relative_velocity(::calmcar::perception::Point* relative_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(relative_velocity_);
  }
  if (relative_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_velocity, submessage_arena);
    }
    
  } else {
    
  }
  relative_velocity_ = relative_velocity;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.relative_velocity)
}

// .calmcar.perception.Point relative_acceleration = 14;
inline bool LidarObjects::has_relative_acceleration() const {
  return this != internal_default_instance() && relative_acceleration_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::relative_acceleration() const {
  const ::calmcar::perception::Point* p = relative_acceleration_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.relative_acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_relative_acceleration() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.relative_acceleration)
  
  ::calmcar::perception::Point* temp = relative_acceleration_;
  relative_acceleration_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_relative_acceleration() {
  
  if (relative_acceleration_ == NULL) {
    relative_acceleration_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.relative_acceleration)
  return relative_acceleration_;
}
inline void LidarObjects::set_allocated_relative_acceleration(::calmcar::perception::Point* relative_acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(relative_acceleration_);
  }
  if (relative_acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  relative_acceleration_ = relative_acceleration;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.relative_acceleration)
}

// .calmcar.perception.Point absolute_velocity = 15;
inline bool LidarObjects::has_absolute_velocity() const {
  return this != internal_default_instance() && absolute_velocity_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::absolute_velocity() const {
  const ::calmcar::perception::Point* p = absolute_velocity_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.absolute_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_absolute_velocity() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.absolute_velocity)
  
  ::calmcar::perception::Point* temp = absolute_velocity_;
  absolute_velocity_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_absolute_velocity() {
  
  if (absolute_velocity_ == NULL) {
    absolute_velocity_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.absolute_velocity)
  return absolute_velocity_;
}
inline void LidarObjects::set_allocated_absolute_velocity(::calmcar::perception::Point* absolute_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(absolute_velocity_);
  }
  if (absolute_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      absolute_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, absolute_velocity, submessage_arena);
    }
    
  } else {
    
  }
  absolute_velocity_ = absolute_velocity;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.absolute_velocity)
}

// .calmcar.perception.Point absolute_acceleration = 16;
inline bool LidarObjects::has_absolute_acceleration() const {
  return this != internal_default_instance() && absolute_acceleration_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::absolute_acceleration() const {
  const ::calmcar::perception::Point* p = absolute_acceleration_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.absolute_acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_absolute_acceleration() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.absolute_acceleration)
  
  ::calmcar::perception::Point* temp = absolute_acceleration_;
  absolute_acceleration_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_absolute_acceleration() {
  
  if (absolute_acceleration_ == NULL) {
    absolute_acceleration_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.absolute_acceleration)
  return absolute_acceleration_;
}
inline void LidarObjects::set_allocated_absolute_acceleration(::calmcar::perception::Point* absolute_acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(absolute_acceleration_);
  }
  if (absolute_acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      absolute_acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, absolute_acceleration, submessage_arena);
    }
    
  } else {
    
  }
  absolute_acceleration_ = absolute_acceleration;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.absolute_acceleration)
}

// float heading = 17;
inline void LidarObjects::clear_heading() {
  heading_ = 0;
}
inline float LidarObjects::heading() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.heading)
  return heading_;
}
inline void LidarObjects::set_heading(float value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.heading)
}

// .calmcar.perception.LidarObjects.MotionStatus motion_status = 18;
inline void LidarObjects::clear_motion_status() {
  motion_status_ = 0;
}
inline ::calmcar::perception::LidarObjects_MotionStatus LidarObjects::motion_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.motion_status)
  return static_cast< ::calmcar::perception::LidarObjects_MotionStatus >(motion_status_);
}
inline void LidarObjects::set_motion_status(::calmcar::perception::LidarObjects_MotionStatus value) {
  
  motion_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.motion_status)
}

// float width = 19;
inline void LidarObjects::clear_width() {
  width_ = 0;
}
inline float LidarObjects::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.width)
  return width_;
}
inline void LidarObjects::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.width)
}

// float height = 20;
inline void LidarObjects::clear_height() {
  height_ = 0;
}
inline float LidarObjects::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.height)
  return height_;
}
inline void LidarObjects::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.height)
}

// float length = 21;
inline void LidarObjects::clear_length() {
  length_ = 0;
}
inline float LidarObjects::length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.length)
  return length_;
}
inline void LidarObjects::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarObjects.length)
}

// .calmcar.perception.Point closest_distance = 22;
inline bool LidarObjects::has_closest_distance() const {
  return this != internal_default_instance() && closest_distance_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::closest_distance() const {
  const ::calmcar::perception::Point* p = closest_distance_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.closest_distance)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_closest_distance() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.closest_distance)
  
  ::calmcar::perception::Point* temp = closest_distance_;
  closest_distance_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_closest_distance() {
  
  if (closest_distance_ == NULL) {
    closest_distance_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.closest_distance)
  return closest_distance_;
}
inline void LidarObjects::set_allocated_closest_distance(::calmcar::perception::Point* closest_distance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(closest_distance_);
  }
  if (closest_distance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      closest_distance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, closest_distance, submessage_arena);
    }
    
  } else {
    
  }
  closest_distance_ = closest_distance;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.closest_distance)
}

// .calmcar.perception.Point closest_surface_center = 23;
inline bool LidarObjects::has_closest_surface_center() const {
  return this != internal_default_instance() && closest_surface_center_ != NULL;
}
inline const ::calmcar::perception::Point& LidarObjects::closest_surface_center() const {
  const ::calmcar::perception::Point* p = closest_surface_center_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarObjects.closest_surface_center)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point*>(
      &::calmcar::perception::_Point_default_instance_);
}
inline ::calmcar::perception::Point* LidarObjects::release_closest_surface_center() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarObjects.closest_surface_center)
  
  ::calmcar::perception::Point* temp = closest_surface_center_;
  closest_surface_center_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point* LidarObjects::mutable_closest_surface_center() {
  
  if (closest_surface_center_ == NULL) {
    closest_surface_center_ = new ::calmcar::perception::Point;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarObjects.closest_surface_center)
  return closest_surface_center_;
}
inline void LidarObjects::set_allocated_closest_surface_center(::calmcar::perception::Point* closest_surface_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(closest_surface_center_);
  }
  if (closest_surface_center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      closest_surface_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, closest_surface_center, submessage_arena);
    }
    
  } else {
    
  }
  closest_surface_center_ = closest_surface_center;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarObjects.closest_surface_center)
}

// -------------------------------------------------------------------

// FreespaceSet

// float x = 1;
inline void FreespaceSet::clear_x() {
  x_ = 0;
}
inline float FreespaceSet::x() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.x)
  return x_;
}
inline void FreespaceSet::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.x)
}

// float y = 2;
inline void FreespaceSet::clear_y() {
  y_ = 0;
}
inline float FreespaceSet::y() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.y)
  return y_;
}
inline void FreespaceSet::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.y)
}

// uint32 class_type = 3;
inline void FreespaceSet::clear_class_type() {
  class_type_ = 0u;
}
inline ::google::protobuf::uint32 FreespaceSet::class_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.class_type)
  return class_type_;
}
inline void FreespaceSet::set_class_type(::google::protobuf::uint32 value) {
  
  class_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.class_type)
}

// uint32 edge = 4;
inline void FreespaceSet::clear_edge() {
  edge_ = 0u;
}
inline ::google::protobuf::uint32 FreespaceSet::edge() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.edge)
  return edge_;
}
inline void FreespaceSet::set_edge(::google::protobuf::uint32 value) {
  
  edge_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.edge)
}

// uint32 id = 5;
inline void FreespaceSet::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 FreespaceSet::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.id)
  return id_;
}
inline void FreespaceSet::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.id)
}

// bool is_valid = 6;
inline void FreespaceSet::clear_is_valid() {
  is_valid_ = false;
}
inline bool FreespaceSet::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.is_valid)
  return is_valid_;
}
inline void FreespaceSet::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.is_valid)
}

// float z = 7;
inline void FreespaceSet::clear_z() {
  z_ = 0;
}
inline float FreespaceSet::z() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.z)
  return z_;
}
inline void FreespaceSet::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.z)
}

// int64 timestamp = 8;
inline void FreespaceSet::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FreespaceSet::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreespaceSet.timestamp)
  return timestamp_;
}
inline void FreespaceSet::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreespaceSet.timestamp)
}

// -------------------------------------------------------------------

// LidarFreespace

// uint32 point_num = 1;
inline void LidarFreespace::clear_point_num() {
  point_num_ = 0u;
}
inline ::google::protobuf::uint32 LidarFreespace::point_num() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarFreespace.point_num)
  return point_num_;
}
inline void LidarFreespace::set_point_num(::google::protobuf::uint32 value) {
  
  point_num_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarFreespace.point_num)
}

// uint32 closed_contour = 2;
inline void LidarFreespace::clear_closed_contour() {
  closed_contour_ = 0u;
}
inline ::google::protobuf::uint32 LidarFreespace::closed_contour() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarFreespace.closed_contour)
  return closed_contour_;
}
inline void LidarFreespace::set_closed_contour(::google::protobuf::uint32 value) {
  
  closed_contour_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LidarFreespace.closed_contour)
}

// repeated .calmcar.perception.FreespaceSet freespace_set = 3;
inline int LidarFreespace::freespace_set_size() const {
  return freespace_set_.size();
}
inline void LidarFreespace::clear_freespace_set() {
  freespace_set_.Clear();
}
inline const ::calmcar::perception::FreespaceSet& LidarFreespace::freespace_set(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarFreespace.freespace_set)
  return freespace_set_.Get(index);
}
inline ::calmcar::perception::FreespaceSet* LidarFreespace::mutable_freespace_set(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarFreespace.freespace_set)
  return freespace_set_.Mutable(index);
}
inline ::calmcar::perception::FreespaceSet* LidarFreespace::add_freespace_set() {
  // @@protoc_insertion_point(field_add:calmcar.perception.LidarFreespace.freespace_set)
  return freespace_set_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreespaceSet >*
LidarFreespace::mutable_freespace_set() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.LidarFreespace.freespace_set)
  return &freespace_set_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreespaceSet >&
LidarFreespace::freespace_set() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.LidarFreespace.freespace_set)
  return freespace_set_;
}

// -------------------------------------------------------------------

// LidarPerceptionFrame

// repeated .calmcar.perception.LidarObjects lidar_object = 1;
inline int LidarPerceptionFrame::lidar_object_size() const {
  return lidar_object_.size();
}
inline void LidarPerceptionFrame::clear_lidar_object() {
  lidar_object_.Clear();
}
inline const ::calmcar::perception::LidarObjects& LidarPerceptionFrame::lidar_object(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarPerceptionFrame.lidar_object)
  return lidar_object_.Get(index);
}
inline ::calmcar::perception::LidarObjects* LidarPerceptionFrame::mutable_lidar_object(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarPerceptionFrame.lidar_object)
  return lidar_object_.Mutable(index);
}
inline ::calmcar::perception::LidarObjects* LidarPerceptionFrame::add_lidar_object() {
  // @@protoc_insertion_point(field_add:calmcar.perception.LidarPerceptionFrame.lidar_object)
  return lidar_object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LidarObjects >*
LidarPerceptionFrame::mutable_lidar_object() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.LidarPerceptionFrame.lidar_object)
  return &lidar_object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LidarObjects >&
LidarPerceptionFrame::lidar_object() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.LidarPerceptionFrame.lidar_object)
  return lidar_object_;
}

// .calmcar.perception.LidarFreespace lidar_fsd = 2;
inline bool LidarPerceptionFrame::has_lidar_fsd() const {
  return this != internal_default_instance() && lidar_fsd_ != NULL;
}
inline void LidarPerceptionFrame::clear_lidar_fsd() {
  if (GetArenaNoVirtual() == NULL && lidar_fsd_ != NULL) {
    delete lidar_fsd_;
  }
  lidar_fsd_ = NULL;
}
inline const ::calmcar::perception::LidarFreespace& LidarPerceptionFrame::lidar_fsd() const {
  const ::calmcar::perception::LidarFreespace* p = lidar_fsd_;
  // @@protoc_insertion_point(field_get:calmcar.perception.LidarPerceptionFrame.lidar_fsd)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::LidarFreespace*>(
      &::calmcar::perception::_LidarFreespace_default_instance_);
}
inline ::calmcar::perception::LidarFreespace* LidarPerceptionFrame::release_lidar_fsd() {
  // @@protoc_insertion_point(field_release:calmcar.perception.LidarPerceptionFrame.lidar_fsd)
  
  ::calmcar::perception::LidarFreespace* temp = lidar_fsd_;
  lidar_fsd_ = NULL;
  return temp;
}
inline ::calmcar::perception::LidarFreespace* LidarPerceptionFrame::mutable_lidar_fsd() {
  
  if (lidar_fsd_ == NULL) {
    lidar_fsd_ = new ::calmcar::perception::LidarFreespace;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LidarPerceptionFrame.lidar_fsd)
  return lidar_fsd_;
}
inline void LidarPerceptionFrame::set_allocated_lidar_fsd(::calmcar::perception::LidarFreespace* lidar_fsd) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lidar_fsd_;
  }
  if (lidar_fsd) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lidar_fsd = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lidar_fsd, submessage_arena);
    }
    
  } else {
    
  }
  lidar_fsd_ = lidar_fsd;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.LidarPerceptionFrame.lidar_fsd)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace calmcar

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmcar::perception::LidarObjects_MotionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LidarObjects_MotionStatus>() {
  return ::calmcar::perception::LidarObjects_MotionStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lidar_5fperception_2eproto__INCLUDED
