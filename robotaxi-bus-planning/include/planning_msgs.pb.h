// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning_msgs.proto

#ifndef PROTOBUF_planning_5fmsgs_2eproto__INCLUDED
#define PROTOBUF_planning_5fmsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common_msgs.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_planning_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlanningCmdImpl();
void InitDefaultsPlanningCmd();
void InitDefaultsBehaviorLimitCmdImpl();
void InitDefaultsBehaviorLimitCmd();
void InitDefaultsPlanningResultImpl();
void InitDefaultsPlanningResult();
void InitDefaultsIntegerImpl();
void InitDefaultsInteger();
void InitDefaultsPlanningStatusImpl();
void InitDefaultsPlanningStatus();
void InitDefaultsTrajectoryPointImpl();
void InitDefaultsTrajectoryPoint();
void InitDefaultsImuInfoImpl();
void InitDefaultsImuInfo();
void InitDefaultsBusinessFeedbackImpl();
void InitDefaultsBusinessFeedback();
void InitDefaultsBusinessImpl();
void InitDefaultsBusiness();
void InitDefaultsTrajectoryImpl();
void InitDefaultsTrajectory();
inline void InitDefaults() {
  InitDefaultsPlanningCmd();
  InitDefaultsBehaviorLimitCmd();
  InitDefaultsPlanningResult();
  InitDefaultsInteger();
  InitDefaultsPlanningStatus();
  InitDefaultsTrajectoryPoint();
  InitDefaultsImuInfo();
  InitDefaultsBusinessFeedback();
  InitDefaultsBusiness();
  InitDefaultsTrajectory();
}
}  // namespace protobuf_planning_5fmsgs_2eproto
namespace planning_msgs {
class BehaviorLimitCmd;
class BehaviorLimitCmdDefaultTypeInternal;
extern BehaviorLimitCmdDefaultTypeInternal _BehaviorLimitCmd_default_instance_;
class Business;
class BusinessDefaultTypeInternal;
extern BusinessDefaultTypeInternal _Business_default_instance_;
class BusinessFeedback;
class BusinessFeedbackDefaultTypeInternal;
extern BusinessFeedbackDefaultTypeInternal _BusinessFeedback_default_instance_;
class ImuInfo;
class ImuInfoDefaultTypeInternal;
extern ImuInfoDefaultTypeInternal _ImuInfo_default_instance_;
class Integer;
class IntegerDefaultTypeInternal;
extern IntegerDefaultTypeInternal _Integer_default_instance_;
class PlanningCmd;
class PlanningCmdDefaultTypeInternal;
extern PlanningCmdDefaultTypeInternal _PlanningCmd_default_instance_;
class PlanningResult;
class PlanningResultDefaultTypeInternal;
extern PlanningResultDefaultTypeInternal _PlanningResult_default_instance_;
class PlanningStatus;
class PlanningStatusDefaultTypeInternal;
extern PlanningStatusDefaultTypeInternal _PlanningStatus_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
}  // namespace planning_msgs
namespace planning_msgs {

// ===================================================================

class PlanningCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.PlanningCmd) */ {
 public:
  PlanningCmd();
  virtual ~PlanningCmd();

  PlanningCmd(const PlanningCmd& from);

  inline PlanningCmd& operator=(const PlanningCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningCmd(PlanningCmd&& from) noexcept
    : PlanningCmd() {
    *this = ::std::move(from);
  }

  inline PlanningCmd& operator=(PlanningCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningCmd* internal_default_instance() {
    return reinterpret_cast<const PlanningCmd*>(
               &_PlanningCmd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlanningCmd* other);
  friend void swap(PlanningCmd& a, PlanningCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningCmd* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningCmd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningCmd& from);
  void MergeFrom(const PlanningCmd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 mission_id = 1;
  void clear_mission_id();
  static const int kMissionIdFieldNumber = 1;
  ::google::protobuf::int32 mission_id() const;
  void set_mission_id(::google::protobuf::int32 value);

  // int32 mission_type = 2;
  void clear_mission_type();
  static const int kMissionTypeFieldNumber = 2;
  ::google::protobuf::int32 mission_type() const;
  void set_mission_type(::google::protobuf::int32 value);

  // int32 mission_command = 3;
  void clear_mission_command();
  static const int kMissionCommandFieldNumber = 3;
  ::google::protobuf::int32 mission_command() const;
  void set_mission_command(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.PlanningCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 mission_id_;
  ::google::protobuf::int32 mission_type_;
  ::google::protobuf::int32 mission_command_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsPlanningCmdImpl();
};
// -------------------------------------------------------------------

class BehaviorLimitCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.BehaviorLimitCmd) */ {
 public:
  BehaviorLimitCmd();
  virtual ~BehaviorLimitCmd();

  BehaviorLimitCmd(const BehaviorLimitCmd& from);

  inline BehaviorLimitCmd& operator=(const BehaviorLimitCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BehaviorLimitCmd(BehaviorLimitCmd&& from) noexcept
    : BehaviorLimitCmd() {
    *this = ::std::move(from);
  }

  inline BehaviorLimitCmd& operator=(BehaviorLimitCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorLimitCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BehaviorLimitCmd* internal_default_instance() {
    return reinterpret_cast<const BehaviorLimitCmd*>(
               &_BehaviorLimitCmd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(BehaviorLimitCmd* other);
  friend void swap(BehaviorLimitCmd& a, BehaviorLimitCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BehaviorLimitCmd* New() const PROTOBUF_FINAL { return New(NULL); }

  BehaviorLimitCmd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BehaviorLimitCmd& from);
  void MergeFrom(const BehaviorLimitCmd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BehaviorLimitCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 behaviorlimit = 4;
  int behaviorlimit_size() const;
  void clear_behaviorlimit();
  static const int kBehaviorlimitFieldNumber = 4;
  ::google::protobuf::int32 behaviorlimit(int index) const;
  void set_behaviorlimit(int index, ::google::protobuf::int32 value);
  void add_behaviorlimit(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      behaviorlimit() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_behaviorlimit();

  // repeated int32 behaviorexecutethreshold = 5;
  int behaviorexecutethreshold_size() const;
  void clear_behaviorexecutethreshold();
  static const int kBehaviorexecutethresholdFieldNumber = 5;
  ::google::protobuf::int32 behaviorexecutethreshold(int index) const;
  void set_behaviorexecutethreshold(int index, ::google::protobuf::int32 value);
  void add_behaviorexecutethreshold(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      behaviorexecutethreshold() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_behaviorexecutethreshold();

  // float speed_limit = 1;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 1;
  float speed_limit() const;
  void set_speed_limit(float value);

  // uint32 brake_cmd = 2;
  void clear_brake_cmd();
  static const int kBrakeCmdFieldNumber = 2;
  ::google::protobuf::uint32 brake_cmd() const;
  void set_brake_cmd(::google::protobuf::uint32 value);

  // uint32 lane_change_cmd = 3;
  void clear_lane_change_cmd();
  static const int kLaneChangeCmdFieldNumber = 3;
  ::google::protobuf::uint32 lane_change_cmd() const;
  void set_lane_change_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.BehaviorLimitCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > behaviorlimit_;
  mutable int _behaviorlimit_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > behaviorexecutethreshold_;
  mutable int _behaviorexecutethreshold_cached_byte_size_;
  float speed_limit_;
  ::google::protobuf::uint32 brake_cmd_;
  ::google::protobuf::uint32 lane_change_cmd_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsBehaviorLimitCmdImpl();
};
// -------------------------------------------------------------------

class PlanningResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.PlanningResult) */ {
 public:
  PlanningResult();
  virtual ~PlanningResult();

  PlanningResult(const PlanningResult& from);

  inline PlanningResult& operator=(const PlanningResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningResult(PlanningResult&& from) noexcept
    : PlanningResult() {
    *this = ::std::move(from);
  }

  inline PlanningResult& operator=(PlanningResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningResult* internal_default_instance() {
    return reinterpret_cast<const PlanningResult*>(
               &_PlanningResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PlanningResult* other);
  friend void swap(PlanningResult& a, PlanningResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningResult* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningResult& from);
  void MergeFrom(const PlanningResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string addition_message = 2;
  void clear_addition_message();
  static const int kAdditionMessageFieldNumber = 2;
  const ::std::string& addition_message() const;
  void set_addition_message(const ::std::string& value);
  #if LANG_CXX11
  void set_addition_message(::std::string&& value);
  #endif
  void set_addition_message(const char* value);
  void set_addition_message(const char* value, size_t size);
  ::std::string* mutable_addition_message();
  ::std::string* release_addition_message();
  void set_allocated_addition_message(::std::string* addition_message);

  // int32 result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.PlanningResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr addition_message_;
  ::google::protobuf::int32 result_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsPlanningResultImpl();
};
// -------------------------------------------------------------------

class Integer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.Integer) */ {
 public:
  Integer();
  virtual ~Integer();

  Integer(const Integer& from);

  inline Integer& operator=(const Integer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Integer(Integer&& from) noexcept
    : Integer() {
    *this = ::std::move(from);
  }

  inline Integer& operator=(Integer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Integer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Integer* internal_default_instance() {
    return reinterpret_cast<const Integer*>(
               &_Integer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Integer* other);
  friend void swap(Integer& a, Integer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Integer* New() const PROTOBUF_FINAL { return New(NULL); }

  Integer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Integer& from);
  void MergeFrom(const Integer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Integer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 input = 1;
  void clear_input();
  static const int kInputFieldNumber = 1;
  ::google::protobuf::uint32 input() const;
  void set_input(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.Integer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 input_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsIntegerImpl();
};
// -------------------------------------------------------------------

class PlanningStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.PlanningStatus) */ {
 public:
  PlanningStatus();
  virtual ~PlanningStatus();

  PlanningStatus(const PlanningStatus& from);

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningStatus(PlanningStatus&& from) noexcept
    : PlanningStatus() {
    *this = ::std::move(from);
  }

  inline PlanningStatus& operator=(PlanningStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningStatus* internal_default_instance() {
    return reinterpret_cast<const PlanningStatus*>(
               &_PlanningStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PlanningStatus* other);
  friend void swap(PlanningStatus& a, PlanningStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PlanningStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlanningStatus& from);
  void MergeFrom(const PlanningStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlanningStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 behaviorlimit = 8;
  int behaviorlimit_size() const;
  void clear_behaviorlimit();
  static const int kBehaviorlimitFieldNumber = 8;
  ::google::protobuf::int32 behaviorlimit(int index) const;
  void set_behaviorlimit(int index, ::google::protobuf::int32 value);
  void add_behaviorlimit(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      behaviorlimit() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_behaviorlimit();

  // repeated int32 behaviorexecutethreshold = 9;
  int behaviorexecutethreshold_size() const;
  void clear_behaviorexecutethreshold();
  static const int kBehaviorexecutethresholdFieldNumber = 9;
  ::google::protobuf::int32 behaviorexecutethreshold(int index) const;
  void set_behaviorexecutethreshold(int index, ::google::protobuf::int32 value);
  void add_behaviorexecutethreshold(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      behaviorexecutethreshold() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_behaviorexecutethreshold();

  // .planning_msgs.PlanningResult lane_change_feedback = 7;
  bool has_lane_change_feedback() const;
  void clear_lane_change_feedback();
  static const int kLaneChangeFeedbackFieldNumber = 7;
  const ::planning_msgs::PlanningResult& lane_change_feedback() const;
  ::planning_msgs::PlanningResult* release_lane_change_feedback();
  ::planning_msgs::PlanningResult* mutable_lane_change_feedback();
  void set_allocated_lane_change_feedback(::planning_msgs::PlanningResult* lane_change_feedback);

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // int32 mission_id = 2;
  void clear_mission_id();
  static const int kMissionIdFieldNumber = 2;
  ::google::protobuf::int32 mission_id() const;
  void set_mission_id(::google::protobuf::int32 value);

  // int32 mission_type = 3;
  void clear_mission_type();
  static const int kMissionTypeFieldNumber = 3;
  ::google::protobuf::int32 mission_type() const;
  void set_mission_type(::google::protobuf::int32 value);

  // float speed_limit = 4;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 4;
  float speed_limit() const;
  void set_speed_limit(float value);

  // int32 brake_status = 5;
  void clear_brake_status();
  static const int kBrakeStatusFieldNumber = 5;
  ::google::protobuf::int32 brake_status() const;
  void set_brake_status(::google::protobuf::int32 value);

  // int32 lane_change_status = 6;
  void clear_lane_change_status();
  static const int kLaneChangeStatusFieldNumber = 6;
  ::google::protobuf::int32 lane_change_status() const;
  void set_lane_change_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.PlanningStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > behaviorlimit_;
  mutable int _behaviorlimit_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > behaviorexecutethreshold_;
  mutable int _behaviorexecutethreshold_cached_byte_size_;
  ::planning_msgs::PlanningResult* lane_change_feedback_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 mission_id_;
  ::google::protobuf::int32 mission_type_;
  float speed_limit_;
  ::google::protobuf::int32 brake_status_;
  ::google::protobuf::int32 lane_change_status_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsPlanningStatusImpl();
};
// -------------------------------------------------------------------

class TrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.TrajectoryPoint) */ {
 public:
  TrajectoryPoint();
  virtual ~TrajectoryPoint();

  TrajectoryPoint(const TrajectoryPoint& from);

  inline TrajectoryPoint& operator=(const TrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryPoint(TrajectoryPoint&& from) noexcept
    : TrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline TrajectoryPoint& operator=(TrajectoryPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPoint*>(
               &_TrajectoryPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TrajectoryPoint* other);
  friend void swap(TrajectoryPoint& a, TrajectoryPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryPoint& from);
  void MergeFrom(const TrajectoryPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // double xg = 3;
  void clear_xg();
  static const int kXgFieldNumber = 3;
  double xg() const;
  void set_xg(double value);

  // double yg = 4;
  void clear_yg();
  static const int kYgFieldNumber = 4;
  double yg() const;
  void set_yg(double value);

  // double xg_dr = 5;
  void clear_xg_dr();
  static const int kXgDrFieldNumber = 5;
  double xg_dr() const;
  void set_xg_dr(double value);

  // double yg_dr = 6;
  void clear_yg_dr();
  static const int kYgDrFieldNumber = 6;
  double yg_dr() const;
  void set_yg_dr(double value);

  // float angle = 7;
  void clear_angle();
  static const int kAngleFieldNumber = 7;
  float angle() const;
  void set_angle(float value);

  // float angleglobal = 8;
  void clear_angleglobal();
  static const int kAngleglobalFieldNumber = 8;
  float angleglobal() const;
  void set_angleglobal(float value);

  // float angleglobal_dr = 9;
  void clear_angleglobal_dr();
  static const int kAngleglobalDrFieldNumber = 9;
  float angleglobal_dr() const;
  void set_angleglobal_dr(float value);

  // float velocity = 10;
  void clear_velocity();
  static const int kVelocityFieldNumber = 10;
  float velocity() const;
  void set_velocity(float value);

  // float a = 11;
  void clear_a();
  static const int kAFieldNumber = 11;
  float a() const;
  void set_a(float value);

  // float t = 12;
  void clear_t();
  static const int kTFieldNumber = 12;
  float t() const;
  void set_t(float value);

  // float curvature = 13;
  void clear_curvature();
  static const int kCurvatureFieldNumber = 13;
  float curvature() const;
  void set_curvature(float value);

  // float length = 14;
  void clear_length();
  static const int kLengthFieldNumber = 14;
  float length() const;
  void set_length(float value);

  // int32 direction = 15;
  void clear_direction();
  static const int kDirectionFieldNumber = 15;
  ::google::protobuf::int32 direction() const;
  void set_direction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.TrajectoryPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  double xg_;
  double yg_;
  double xg_dr_;
  double yg_dr_;
  float angle_;
  float angleglobal_;
  float angleglobal_dr_;
  float velocity_;
  float a_;
  float t_;
  float curvature_;
  float length_;
  ::google::protobuf::int32 direction_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsTrajectoryPointImpl();
};
// -------------------------------------------------------------------

class ImuInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.ImuInfo) */ {
 public:
  ImuInfo();
  virtual ~ImuInfo();

  ImuInfo(const ImuInfo& from);

  inline ImuInfo& operator=(const ImuInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImuInfo(ImuInfo&& from) noexcept
    : ImuInfo() {
    *this = ::std::move(from);
  }

  inline ImuInfo& operator=(ImuInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImuInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImuInfo* internal_default_instance() {
    return reinterpret_cast<const ImuInfo*>(
               &_ImuInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ImuInfo* other);
  friend void swap(ImuInfo& a, ImuInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImuInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ImuInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImuInfo& from);
  void MergeFrom(const ImuInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImuInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double time_stamp = 1;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  double time_stamp() const;
  void set_time_stamp(double value);

  // double xg = 2;
  void clear_xg();
  static const int kXgFieldNumber = 2;
  double xg() const;
  void set_xg(double value);

  // double yg = 3;
  void clear_yg();
  static const int kYgFieldNumber = 3;
  double yg() const;
  void set_yg(double value);

  // double yaw = 4;
  void clear_yaw();
  static const int kYawFieldNumber = 4;
  double yaw() const;
  void set_yaw(double value);

  // double velocity = 5;
  void clear_velocity();
  static const int kVelocityFieldNumber = 5;
  double velocity() const;
  void set_velocity(double value);

  // double vx = 6;
  void clear_vx();
  static const int kVxFieldNumber = 6;
  double vx() const;
  void set_vx(double value);

  // double vy = 7;
  void clear_vy();
  static const int kVyFieldNumber = 7;
  double vy() const;
  void set_vy(double value);

  // double loc_xg_dr = 8;
  void clear_loc_xg_dr();
  static const int kLocXgDrFieldNumber = 8;
  double loc_xg_dr() const;
  void set_loc_xg_dr(double value);

  // double loc_yg_dr = 9;
  void clear_loc_yg_dr();
  static const int kLocYgDrFieldNumber = 9;
  double loc_yg_dr() const;
  void set_loc_yg_dr(double value);

  // double loc_yaw_dr = 10;
  void clear_loc_yaw_dr();
  static const int kLocYawDrFieldNumber = 10;
  double loc_yaw_dr() const;
  void set_loc_yaw_dr(double value);

  // bool correction_flag = 11;
  void clear_correction_flag();
  static const int kCorrectionFlagFieldNumber = 11;
  bool correction_flag() const;
  void set_correction_flag(bool value);

  // @@protoc_insertion_point(class_scope:planning_msgs.ImuInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double time_stamp_;
  double xg_;
  double yg_;
  double yaw_;
  double velocity_;
  double vx_;
  double vy_;
  double loc_xg_dr_;
  double loc_yg_dr_;
  double loc_yaw_dr_;
  bool correction_flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsImuInfoImpl();
};
// -------------------------------------------------------------------

class BusinessFeedback : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.BusinessFeedback) */ {
 public:
  BusinessFeedback();
  virtual ~BusinessFeedback();

  BusinessFeedback(const BusinessFeedback& from);

  inline BusinessFeedback& operator=(const BusinessFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BusinessFeedback(BusinessFeedback&& from) noexcept
    : BusinessFeedback() {
    *this = ::std::move(from);
  }

  inline BusinessFeedback& operator=(BusinessFeedback&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BusinessFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BusinessFeedback* internal_default_instance() {
    return reinterpret_cast<const BusinessFeedback*>(
               &_BusinessFeedback_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BusinessFeedback* other);
  friend void swap(BusinessFeedback& a, BusinessFeedback& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BusinessFeedback* New() const PROTOBUF_FINAL { return New(NULL); }

  BusinessFeedback* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BusinessFeedback& from);
  void MergeFrom(const BusinessFeedback& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BusinessFeedback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string reference_lane_ids = 3;
  int reference_lane_ids_size() const;
  void clear_reference_lane_ids();
  static const int kReferenceLaneIdsFieldNumber = 3;
  const ::std::string& reference_lane_ids(int index) const;
  ::std::string* mutable_reference_lane_ids(int index);
  void set_reference_lane_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_reference_lane_ids(int index, ::std::string&& value);
  #endif
  void set_reference_lane_ids(int index, const char* value);
  void set_reference_lane_ids(int index, const char* value, size_t size);
  ::std::string* add_reference_lane_ids();
  void add_reference_lane_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_reference_lane_ids(::std::string&& value);
  #endif
  void add_reference_lane_ids(const char* value);
  void add_reference_lane_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reference_lane_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reference_lane_ids();

  // repeated string reference_target_ids = 4;
  int reference_target_ids_size() const;
  void clear_reference_target_ids();
  static const int kReferenceTargetIdsFieldNumber = 4;
  const ::std::string& reference_target_ids(int index) const;
  ::std::string* mutable_reference_target_ids(int index);
  void set_reference_target_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_reference_target_ids(int index, ::std::string&& value);
  #endif
  void set_reference_target_ids(int index, const char* value);
  void set_reference_target_ids(int index, const char* value, size_t size);
  ::std::string* add_reference_target_ids();
  void add_reference_target_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_reference_target_ids(::std::string&& value);
  #endif
  void add_reference_target_ids(const char* value);
  void add_reference_target_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reference_target_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reference_target_ids();

  // repeated string passable_lane_ids = 8;
  int passable_lane_ids_size() const;
  void clear_passable_lane_ids();
  static const int kPassableLaneIdsFieldNumber = 8;
  const ::std::string& passable_lane_ids(int index) const;
  ::std::string* mutable_passable_lane_ids(int index);
  void set_passable_lane_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_passable_lane_ids(int index, ::std::string&& value);
  #endif
  void set_passable_lane_ids(int index, const char* value);
  void set_passable_lane_ids(int index, const char* value, size_t size);
  ::std::string* add_passable_lane_ids();
  void add_passable_lane_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_passable_lane_ids(::std::string&& value);
  #endif
  void add_passable_lane_ids(const char* value);
  void add_passable_lane_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& passable_lane_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_passable_lane_ids();

  // repeated string black_road_ids = 9;
  int black_road_ids_size() const;
  void clear_black_road_ids();
  static const int kBlackRoadIdsFieldNumber = 9;
  const ::std::string& black_road_ids(int index) const;
  ::std::string* mutable_black_road_ids(int index);
  void set_black_road_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_black_road_ids(int index, ::std::string&& value);
  #endif
  void set_black_road_ids(int index, const char* value);
  void set_black_road_ids(int index, const char* value, size_t size);
  ::std::string* add_black_road_ids();
  void add_black_road_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_black_road_ids(::std::string&& value);
  #endif
  void add_black_road_ids(const char* value);
  void add_black_road_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& black_road_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_black_road_ids();

  // .common_msgs.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::common_msgs::Header& header() const;
  ::common_msgs::Header* release_header();
  ::common_msgs::Header* mutable_header();
  void set_allocated_header(::common_msgs::Header* header);

  // .planning_msgs.Business business = 2;
  bool has_business() const;
  void clear_business();
  static const int kBusinessFieldNumber = 2;
  const ::planning_msgs::Business& business() const;
  ::planning_msgs::Business* release_business();
  ::planning_msgs::Business* mutable_business();
  void set_allocated_business(::planning_msgs::Business* business);

  // int32 decision_id = 5;
  void clear_decision_id();
  static const int kDecisionIdFieldNumber = 5;
  ::google::protobuf::int32 decision_id() const;
  void set_decision_id(::google::protobuf::int32 value);

  // bool path_in_current = 6;
  void clear_path_in_current();
  static const int kPathInCurrentFieldNumber = 6;
  bool path_in_current() const;
  void set_path_in_current(bool value);

  // bool is_passable = 7;
  void clear_is_passable();
  static const int kIsPassableFieldNumber = 7;
  bool is_passable() const;
  void set_is_passable(bool value);

  // @@protoc_insertion_point(class_scope:planning_msgs.BusinessFeedback)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reference_lane_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reference_target_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> passable_lane_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> black_road_ids_;
  ::common_msgs::Header* header_;
  ::planning_msgs::Business* business_;
  ::google::protobuf::int32 decision_id_;
  bool path_in_current_;
  bool is_passable_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsBusinessFeedbackImpl();
};
// -------------------------------------------------------------------

class Business : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.Business) */ {
 public:
  Business();
  virtual ~Business();

  Business(const Business& from);

  inline Business& operator=(const Business& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Business(Business&& from) noexcept
    : Business() {
    *this = ::std::move(from);
  }

  inline Business& operator=(Business&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Business& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Business* internal_default_instance() {
    return reinterpret_cast<const Business*>(
               &_Business_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Business* other);
  friend void swap(Business& a, Business& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Business* New() const PROTOBUF_FINAL { return New(NULL); }

  Business* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Business& from);
  void MergeFrom(const Business& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Business* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 orderreply = 1;
  void clear_orderreply();
  static const int kOrderreplyFieldNumber = 1;
  ::google::protobuf::int32 orderreply() const;
  void set_orderreply(::google::protobuf::int32 value);

  // uint32 direction = 2;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::google::protobuf::uint32 direction() const;
  void set_direction(::google::protobuf::uint32 value);

  // int32 turning = 3;
  void clear_turning();
  static const int kTurningFieldNumber = 3;
  ::google::protobuf::int32 turning() const;
  void set_turning(::google::protobuf::int32 value);

  // int32 driving_status = 4;
  void clear_driving_status();
  static const int kDrivingStatusFieldNumber = 4;
  ::google::protobuf::int32 driving_status() const;
  void set_driving_status(::google::protobuf::int32 value);

  // float speed_limit = 5;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 5;
  float speed_limit() const;
  void set_speed_limit(float value);

  // int32 impassable_flag = 6;
  void clear_impassable_flag();
  static const int kImpassableFlagFieldNumber = 6;
  ::google::protobuf::int32 impassable_flag() const;
  void set_impassable_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planning_msgs.Business)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 orderreply_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::int32 turning_;
  ::google::protobuf::int32 driving_status_;
  float speed_limit_;
  ::google::protobuf::int32 impassable_flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsBusinessImpl();
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planning_msgs.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .planning_msgs.TrajectoryPoint points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::planning_msgs::TrajectoryPoint& points(int index) const;
  ::planning_msgs::TrajectoryPoint* mutable_points(int index);
  ::planning_msgs::TrajectoryPoint* add_points();
  ::google::protobuf::RepeatedPtrField< ::planning_msgs::TrajectoryPoint >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::planning_msgs::TrajectoryPoint >&
      points() const;

  // repeated string lane_ids = 6;
  int lane_ids_size() const;
  void clear_lane_ids();
  static const int kLaneIdsFieldNumber = 6;
  const ::std::string& lane_ids(int index) const;
  ::std::string* mutable_lane_ids(int index);
  void set_lane_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lane_ids(int index, ::std::string&& value);
  #endif
  void set_lane_ids(int index, const char* value);
  void set_lane_ids(int index, const char* value, size_t size);
  ::std::string* add_lane_ids();
  void add_lane_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_lane_ids(::std::string&& value);
  #endif
  void add_lane_ids(const char* value);
  void add_lane_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lane_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lane_ids();

  // .common_msgs.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::common_msgs::Header& header() const;
  ::common_msgs::Header* release_header();
  ::common_msgs::Header* mutable_header();
  void set_allocated_header(::common_msgs::Header* header);

  // .planning_msgs.ImuInfo imu_loc_data = 10;
  bool has_imu_loc_data() const;
  void clear_imu_loc_data();
  static const int kImuLocDataFieldNumber = 10;
  const ::planning_msgs::ImuInfo& imu_loc_data() const;
  ::planning_msgs::ImuInfo* release_imu_loc_data();
  ::planning_msgs::ImuInfo* mutable_imu_loc_data();
  void set_allocated_imu_loc_data(::planning_msgs::ImuInfo* imu_loc_data);

  // .planning_msgs.ImuInfo correct_loc_data = 11;
  bool has_correct_loc_data() const;
  void clear_correct_loc_data();
  static const int kCorrectLocDataFieldNumber = 11;
  const ::planning_msgs::ImuInfo& correct_loc_data() const;
  ::planning_msgs::ImuInfo* release_correct_loc_data();
  ::planning_msgs::ImuInfo* mutable_correct_loc_data();
  void set_allocated_correct_loc_data(::planning_msgs::ImuInfo* correct_loc_data);

  // uint32 direction = 3;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  ::google::protobuf::uint32 direction() const;
  void set_direction(::google::protobuf::uint32 value);

  // uint32 autodrvmodeentry = 4;
  void clear_autodrvmodeentry();
  static const int kAutodrvmodeentryFieldNumber = 4;
  ::google::protobuf::uint32 autodrvmodeentry() const;
  void set_autodrvmodeentry(::google::protobuf::uint32 value);

  // uint32 autodrvmodeexit = 5;
  void clear_autodrvmodeexit();
  static const int kAutodrvmodeexitFieldNumber = 5;
  ::google::protobuf::uint32 autodrvmodeexit() const;
  void set_autodrvmodeexit(::google::protobuf::uint32 value);

  // int32 lane_type = 7;
  void clear_lane_type();
  static const int kLaneTypeFieldNumber = 7;
  ::google::protobuf::int32 lane_type() const;
  void set_lane_type(::google::protobuf::int32 value);

  // int32 car_fault_level = 8;
  void clear_car_fault_level();
  static const int kCarFaultLevelFieldNumber = 8;
  ::google::protobuf::int32 car_fault_level() const;
  void set_car_fault_level(::google::protobuf::int32 value);

  // float control_accuracy = 9;
  void clear_control_accuracy();
  static const int kControlAccuracyFieldNumber = 9;
  float control_accuracy() const;
  void set_control_accuracy(float value);

  // int32 gear_position_request = 12;
  void clear_gear_position_request();
  static const int kGearPositionRequestFieldNumber = 12;
  ::google::protobuf::int32 gear_position_request() const;
  void set_gear_position_request(::google::protobuf::int32 value);

  // int32 senario_type = 13;
  void clear_senario_type();
  static const int kSenarioTypeFieldNumber = 13;
  ::google::protobuf::int32 senario_type() const;
  void set_senario_type(::google::protobuf::int32 value);

  // float steeringangle_rate_max = 14;
  void clear_steeringangle_rate_max();
  static const int kSteeringangleRateMaxFieldNumber = 14;
  float steeringangle_rate_max() const;
  void set_steeringangle_rate_max(float value);

  // @@protoc_insertion_point(class_scope:planning_msgs.Trajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::planning_msgs::TrajectoryPoint > points_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lane_ids_;
  ::common_msgs::Header* header_;
  ::planning_msgs::ImuInfo* imu_loc_data_;
  ::planning_msgs::ImuInfo* correct_loc_data_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 autodrvmodeentry_;
  ::google::protobuf::uint32 autodrvmodeexit_;
  ::google::protobuf::int32 lane_type_;
  ::google::protobuf::int32 car_fault_level_;
  float control_accuracy_;
  ::google::protobuf::int32 gear_position_request_;
  ::google::protobuf::int32 senario_type_;
  float steeringangle_rate_max_;
  mutable int _cached_size_;
  friend struct ::protobuf_planning_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_planning_5fmsgs_2eproto::InitDefaultsTrajectoryImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlanningCmd

// int32 mission_id = 1;
inline void PlanningCmd::clear_mission_id() {
  mission_id_ = 0;
}
inline ::google::protobuf::int32 PlanningCmd::mission_id() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningCmd.mission_id)
  return mission_id_;
}
inline void PlanningCmd::set_mission_id(::google::protobuf::int32 value) {
  
  mission_id_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningCmd.mission_id)
}

// int32 mission_type = 2;
inline void PlanningCmd::clear_mission_type() {
  mission_type_ = 0;
}
inline ::google::protobuf::int32 PlanningCmd::mission_type() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningCmd.mission_type)
  return mission_type_;
}
inline void PlanningCmd::set_mission_type(::google::protobuf::int32 value) {
  
  mission_type_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningCmd.mission_type)
}

// int32 mission_command = 3;
inline void PlanningCmd::clear_mission_command() {
  mission_command_ = 0;
}
inline ::google::protobuf::int32 PlanningCmd::mission_command() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningCmd.mission_command)
  return mission_command_;
}
inline void PlanningCmd::set_mission_command(::google::protobuf::int32 value) {
  
  mission_command_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningCmd.mission_command)
}

// -------------------------------------------------------------------

// BehaviorLimitCmd

// float speed_limit = 1;
inline void BehaviorLimitCmd::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float BehaviorLimitCmd::speed_limit() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BehaviorLimitCmd.speed_limit)
  return speed_limit_;
}
inline void BehaviorLimitCmd::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BehaviorLimitCmd.speed_limit)
}

// uint32 brake_cmd = 2;
inline void BehaviorLimitCmd::clear_brake_cmd() {
  brake_cmd_ = 0u;
}
inline ::google::protobuf::uint32 BehaviorLimitCmd::brake_cmd() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BehaviorLimitCmd.brake_cmd)
  return brake_cmd_;
}
inline void BehaviorLimitCmd::set_brake_cmd(::google::protobuf::uint32 value) {
  
  brake_cmd_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BehaviorLimitCmd.brake_cmd)
}

// uint32 lane_change_cmd = 3;
inline void BehaviorLimitCmd::clear_lane_change_cmd() {
  lane_change_cmd_ = 0u;
}
inline ::google::protobuf::uint32 BehaviorLimitCmd::lane_change_cmd() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BehaviorLimitCmd.lane_change_cmd)
  return lane_change_cmd_;
}
inline void BehaviorLimitCmd::set_lane_change_cmd(::google::protobuf::uint32 value) {
  
  lane_change_cmd_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BehaviorLimitCmd.lane_change_cmd)
}

// repeated int32 behaviorlimit = 4;
inline int BehaviorLimitCmd::behaviorlimit_size() const {
  return behaviorlimit_.size();
}
inline void BehaviorLimitCmd::clear_behaviorlimit() {
  behaviorlimit_.Clear();
}
inline ::google::protobuf::int32 BehaviorLimitCmd::behaviorlimit(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BehaviorLimitCmd.behaviorlimit)
  return behaviorlimit_.Get(index);
}
inline void BehaviorLimitCmd::set_behaviorlimit(int index, ::google::protobuf::int32 value) {
  behaviorlimit_.Set(index, value);
  // @@protoc_insertion_point(field_set:planning_msgs.BehaviorLimitCmd.behaviorlimit)
}
inline void BehaviorLimitCmd::add_behaviorlimit(::google::protobuf::int32 value) {
  behaviorlimit_.Add(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BehaviorLimitCmd.behaviorlimit)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BehaviorLimitCmd::behaviorlimit() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BehaviorLimitCmd.behaviorlimit)
  return behaviorlimit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BehaviorLimitCmd::mutable_behaviorlimit() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BehaviorLimitCmd.behaviorlimit)
  return &behaviorlimit_;
}

// repeated int32 behaviorexecutethreshold = 5;
inline int BehaviorLimitCmd::behaviorexecutethreshold_size() const {
  return behaviorexecutethreshold_.size();
}
inline void BehaviorLimitCmd::clear_behaviorexecutethreshold() {
  behaviorexecutethreshold_.Clear();
}
inline ::google::protobuf::int32 BehaviorLimitCmd::behaviorexecutethreshold(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BehaviorLimitCmd.behaviorexecutethreshold)
  return behaviorexecutethreshold_.Get(index);
}
inline void BehaviorLimitCmd::set_behaviorexecutethreshold(int index, ::google::protobuf::int32 value) {
  behaviorexecutethreshold_.Set(index, value);
  // @@protoc_insertion_point(field_set:planning_msgs.BehaviorLimitCmd.behaviorexecutethreshold)
}
inline void BehaviorLimitCmd::add_behaviorexecutethreshold(::google::protobuf::int32 value) {
  behaviorexecutethreshold_.Add(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BehaviorLimitCmd.behaviorexecutethreshold)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BehaviorLimitCmd::behaviorexecutethreshold() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BehaviorLimitCmd.behaviorexecutethreshold)
  return behaviorexecutethreshold_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BehaviorLimitCmd::mutable_behaviorexecutethreshold() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BehaviorLimitCmd.behaviorexecutethreshold)
  return &behaviorexecutethreshold_;
}

// -------------------------------------------------------------------

// PlanningResult

// int32 result = 1;
inline void PlanningResult::clear_result() {
  result_ = 0;
}
inline ::google::protobuf::int32 PlanningResult::result() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningResult.result)
  return result_;
}
inline void PlanningResult::set_result(::google::protobuf::int32 value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningResult.result)
}

// string addition_message = 2;
inline void PlanningResult::clear_addition_message() {
  addition_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanningResult::addition_message() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningResult.addition_message)
  return addition_message_.GetNoArena();
}
inline void PlanningResult::set_addition_message(const ::std::string& value) {
  
  addition_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningResult.addition_message)
}
#if LANG_CXX11
inline void PlanningResult::set_addition_message(::std::string&& value) {
  
  addition_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:planning_msgs.PlanningResult.addition_message)
}
#endif
inline void PlanningResult::set_addition_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  addition_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:planning_msgs.PlanningResult.addition_message)
}
inline void PlanningResult::set_addition_message(const char* value, size_t size) {
  
  addition_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.PlanningResult.addition_message)
}
inline ::std::string* PlanningResult::mutable_addition_message() {
  
  // @@protoc_insertion_point(field_mutable:planning_msgs.PlanningResult.addition_message)
  return addition_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanningResult::release_addition_message() {
  // @@protoc_insertion_point(field_release:planning_msgs.PlanningResult.addition_message)
  
  return addition_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanningResult::set_allocated_addition_message(::std::string* addition_message) {
  if (addition_message != NULL) {
    
  } else {
    
  }
  addition_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addition_message);
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.PlanningResult.addition_message)
}

// -------------------------------------------------------------------

// Integer

// uint32 input = 1;
inline void Integer::clear_input() {
  input_ = 0u;
}
inline ::google::protobuf::uint32 Integer::input() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Integer.input)
  return input_;
}
inline void Integer::set_input(::google::protobuf::uint32 value) {
  
  input_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Integer.input)
}

// -------------------------------------------------------------------

// PlanningStatus

// int32 status = 1;
inline void PlanningStatus::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 PlanningStatus::status() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.status)
  return status_;
}
inline void PlanningStatus::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.status)
}

// int32 mission_id = 2;
inline void PlanningStatus::clear_mission_id() {
  mission_id_ = 0;
}
inline ::google::protobuf::int32 PlanningStatus::mission_id() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.mission_id)
  return mission_id_;
}
inline void PlanningStatus::set_mission_id(::google::protobuf::int32 value) {
  
  mission_id_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.mission_id)
}

// int32 mission_type = 3;
inline void PlanningStatus::clear_mission_type() {
  mission_type_ = 0;
}
inline ::google::protobuf::int32 PlanningStatus::mission_type() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.mission_type)
  return mission_type_;
}
inline void PlanningStatus::set_mission_type(::google::protobuf::int32 value) {
  
  mission_type_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.mission_type)
}

// float speed_limit = 4;
inline void PlanningStatus::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float PlanningStatus::speed_limit() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.speed_limit)
  return speed_limit_;
}
inline void PlanningStatus::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.speed_limit)
}

// int32 brake_status = 5;
inline void PlanningStatus::clear_brake_status() {
  brake_status_ = 0;
}
inline ::google::protobuf::int32 PlanningStatus::brake_status() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.brake_status)
  return brake_status_;
}
inline void PlanningStatus::set_brake_status(::google::protobuf::int32 value) {
  
  brake_status_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.brake_status)
}

// int32 lane_change_status = 6;
inline void PlanningStatus::clear_lane_change_status() {
  lane_change_status_ = 0;
}
inline ::google::protobuf::int32 PlanningStatus::lane_change_status() const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.lane_change_status)
  return lane_change_status_;
}
inline void PlanningStatus::set_lane_change_status(::google::protobuf::int32 value) {
  
  lane_change_status_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.lane_change_status)
}

// .planning_msgs.PlanningResult lane_change_feedback = 7;
inline bool PlanningStatus::has_lane_change_feedback() const {
  return this != internal_default_instance() && lane_change_feedback_ != NULL;
}
inline void PlanningStatus::clear_lane_change_feedback() {
  if (GetArenaNoVirtual() == NULL && lane_change_feedback_ != NULL) {
    delete lane_change_feedback_;
  }
  lane_change_feedback_ = NULL;
}
inline const ::planning_msgs::PlanningResult& PlanningStatus::lane_change_feedback() const {
  const ::planning_msgs::PlanningResult* p = lane_change_feedback_;
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.lane_change_feedback)
  return p != NULL ? *p : *reinterpret_cast<const ::planning_msgs::PlanningResult*>(
      &::planning_msgs::_PlanningResult_default_instance_);
}
inline ::planning_msgs::PlanningResult* PlanningStatus::release_lane_change_feedback() {
  // @@protoc_insertion_point(field_release:planning_msgs.PlanningStatus.lane_change_feedback)
  
  ::planning_msgs::PlanningResult* temp = lane_change_feedback_;
  lane_change_feedback_ = NULL;
  return temp;
}
inline ::planning_msgs::PlanningResult* PlanningStatus::mutable_lane_change_feedback() {
  
  if (lane_change_feedback_ == NULL) {
    lane_change_feedback_ = new ::planning_msgs::PlanningResult;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.PlanningStatus.lane_change_feedback)
  return lane_change_feedback_;
}
inline void PlanningStatus::set_allocated_lane_change_feedback(::planning_msgs::PlanningResult* lane_change_feedback) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_change_feedback_;
  }
  if (lane_change_feedback) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_change_feedback = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_change_feedback, submessage_arena);
    }
    
  } else {
    
  }
  lane_change_feedback_ = lane_change_feedback;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.PlanningStatus.lane_change_feedback)
}

// repeated int32 behaviorlimit = 8;
inline int PlanningStatus::behaviorlimit_size() const {
  return behaviorlimit_.size();
}
inline void PlanningStatus::clear_behaviorlimit() {
  behaviorlimit_.Clear();
}
inline ::google::protobuf::int32 PlanningStatus::behaviorlimit(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.behaviorlimit)
  return behaviorlimit_.Get(index);
}
inline void PlanningStatus::set_behaviorlimit(int index, ::google::protobuf::int32 value) {
  behaviorlimit_.Set(index, value);
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.behaviorlimit)
}
inline void PlanningStatus::add_behaviorlimit(::google::protobuf::int32 value) {
  behaviorlimit_.Add(value);
  // @@protoc_insertion_point(field_add:planning_msgs.PlanningStatus.behaviorlimit)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanningStatus::behaviorlimit() const {
  // @@protoc_insertion_point(field_list:planning_msgs.PlanningStatus.behaviorlimit)
  return behaviorlimit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanningStatus::mutable_behaviorlimit() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.PlanningStatus.behaviorlimit)
  return &behaviorlimit_;
}

// repeated int32 behaviorexecutethreshold = 9;
inline int PlanningStatus::behaviorexecutethreshold_size() const {
  return behaviorexecutethreshold_.size();
}
inline void PlanningStatus::clear_behaviorexecutethreshold() {
  behaviorexecutethreshold_.Clear();
}
inline ::google::protobuf::int32 PlanningStatus::behaviorexecutethreshold(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.PlanningStatus.behaviorexecutethreshold)
  return behaviorexecutethreshold_.Get(index);
}
inline void PlanningStatus::set_behaviorexecutethreshold(int index, ::google::protobuf::int32 value) {
  behaviorexecutethreshold_.Set(index, value);
  // @@protoc_insertion_point(field_set:planning_msgs.PlanningStatus.behaviorexecutethreshold)
}
inline void PlanningStatus::add_behaviorexecutethreshold(::google::protobuf::int32 value) {
  behaviorexecutethreshold_.Add(value);
  // @@protoc_insertion_point(field_add:planning_msgs.PlanningStatus.behaviorexecutethreshold)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlanningStatus::behaviorexecutethreshold() const {
  // @@protoc_insertion_point(field_list:planning_msgs.PlanningStatus.behaviorexecutethreshold)
  return behaviorexecutethreshold_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlanningStatus::mutable_behaviorexecutethreshold() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.PlanningStatus.behaviorexecutethreshold)
  return &behaviorexecutethreshold_;
}

// -------------------------------------------------------------------

// TrajectoryPoint

// float x = 1;
inline void TrajectoryPoint::clear_x() {
  x_ = 0;
}
inline float TrajectoryPoint::x() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.x)
  return x_;
}
inline void TrajectoryPoint::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.x)
}

// float y = 2;
inline void TrajectoryPoint::clear_y() {
  y_ = 0;
}
inline float TrajectoryPoint::y() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.y)
  return y_;
}
inline void TrajectoryPoint::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.y)
}

// double xg = 3;
inline void TrajectoryPoint::clear_xg() {
  xg_ = 0;
}
inline double TrajectoryPoint::xg() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.xg)
  return xg_;
}
inline void TrajectoryPoint::set_xg(double value) {
  
  xg_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.xg)
}

// double yg = 4;
inline void TrajectoryPoint::clear_yg() {
  yg_ = 0;
}
inline double TrajectoryPoint::yg() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.yg)
  return yg_;
}
inline void TrajectoryPoint::set_yg(double value) {
  
  yg_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.yg)
}

// double xg_dr = 5;
inline void TrajectoryPoint::clear_xg_dr() {
  xg_dr_ = 0;
}
inline double TrajectoryPoint::xg_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.xg_dr)
  return xg_dr_;
}
inline void TrajectoryPoint::set_xg_dr(double value) {
  
  xg_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.xg_dr)
}

// double yg_dr = 6;
inline void TrajectoryPoint::clear_yg_dr() {
  yg_dr_ = 0;
}
inline double TrajectoryPoint::yg_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.yg_dr)
  return yg_dr_;
}
inline void TrajectoryPoint::set_yg_dr(double value) {
  
  yg_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.yg_dr)
}

// float angle = 7;
inline void TrajectoryPoint::clear_angle() {
  angle_ = 0;
}
inline float TrajectoryPoint::angle() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.angle)
  return angle_;
}
inline void TrajectoryPoint::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.angle)
}

// float angleglobal = 8;
inline void TrajectoryPoint::clear_angleglobal() {
  angleglobal_ = 0;
}
inline float TrajectoryPoint::angleglobal() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.angleglobal)
  return angleglobal_;
}
inline void TrajectoryPoint::set_angleglobal(float value) {
  
  angleglobal_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.angleglobal)
}

// float angleglobal_dr = 9;
inline void TrajectoryPoint::clear_angleglobal_dr() {
  angleglobal_dr_ = 0;
}
inline float TrajectoryPoint::angleglobal_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.angleglobal_dr)
  return angleglobal_dr_;
}
inline void TrajectoryPoint::set_angleglobal_dr(float value) {
  
  angleglobal_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.angleglobal_dr)
}

// float velocity = 10;
inline void TrajectoryPoint::clear_velocity() {
  velocity_ = 0;
}
inline float TrajectoryPoint::velocity() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.velocity)
  return velocity_;
}
inline void TrajectoryPoint::set_velocity(float value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.velocity)
}

// float a = 11;
inline void TrajectoryPoint::clear_a() {
  a_ = 0;
}
inline float TrajectoryPoint::a() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.a)
  return a_;
}
inline void TrajectoryPoint::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.a)
}

// float t = 12;
inline void TrajectoryPoint::clear_t() {
  t_ = 0;
}
inline float TrajectoryPoint::t() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.t)
  return t_;
}
inline void TrajectoryPoint::set_t(float value) {
  
  t_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.t)
}

// float curvature = 13;
inline void TrajectoryPoint::clear_curvature() {
  curvature_ = 0;
}
inline float TrajectoryPoint::curvature() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.curvature)
  return curvature_;
}
inline void TrajectoryPoint::set_curvature(float value) {
  
  curvature_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.curvature)
}

// float length = 14;
inline void TrajectoryPoint::clear_length() {
  length_ = 0;
}
inline float TrajectoryPoint::length() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.length)
  return length_;
}
inline void TrajectoryPoint::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.length)
}

// int32 direction = 15;
inline void TrajectoryPoint::clear_direction() {
  direction_ = 0;
}
inline ::google::protobuf::int32 TrajectoryPoint::direction() const {
  // @@protoc_insertion_point(field_get:planning_msgs.TrajectoryPoint.direction)
  return direction_;
}
inline void TrajectoryPoint::set_direction(::google::protobuf::int32 value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.TrajectoryPoint.direction)
}

// -------------------------------------------------------------------

// ImuInfo

// double time_stamp = 1;
inline void ImuInfo::clear_time_stamp() {
  time_stamp_ = 0;
}
inline double ImuInfo::time_stamp() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.time_stamp)
  return time_stamp_;
}
inline void ImuInfo::set_time_stamp(double value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.time_stamp)
}

// double xg = 2;
inline void ImuInfo::clear_xg() {
  xg_ = 0;
}
inline double ImuInfo::xg() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.xg)
  return xg_;
}
inline void ImuInfo::set_xg(double value) {
  
  xg_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.xg)
}

// double yg = 3;
inline void ImuInfo::clear_yg() {
  yg_ = 0;
}
inline double ImuInfo::yg() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.yg)
  return yg_;
}
inline void ImuInfo::set_yg(double value) {
  
  yg_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.yg)
}

// double yaw = 4;
inline void ImuInfo::clear_yaw() {
  yaw_ = 0;
}
inline double ImuInfo::yaw() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.yaw)
  return yaw_;
}
inline void ImuInfo::set_yaw(double value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.yaw)
}

// double velocity = 5;
inline void ImuInfo::clear_velocity() {
  velocity_ = 0;
}
inline double ImuInfo::velocity() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.velocity)
  return velocity_;
}
inline void ImuInfo::set_velocity(double value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.velocity)
}

// double vx = 6;
inline void ImuInfo::clear_vx() {
  vx_ = 0;
}
inline double ImuInfo::vx() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.vx)
  return vx_;
}
inline void ImuInfo::set_vx(double value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.vx)
}

// double vy = 7;
inline void ImuInfo::clear_vy() {
  vy_ = 0;
}
inline double ImuInfo::vy() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.vy)
  return vy_;
}
inline void ImuInfo::set_vy(double value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.vy)
}

// double loc_xg_dr = 8;
inline void ImuInfo::clear_loc_xg_dr() {
  loc_xg_dr_ = 0;
}
inline double ImuInfo::loc_xg_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.loc_xg_dr)
  return loc_xg_dr_;
}
inline void ImuInfo::set_loc_xg_dr(double value) {
  
  loc_xg_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.loc_xg_dr)
}

// double loc_yg_dr = 9;
inline void ImuInfo::clear_loc_yg_dr() {
  loc_yg_dr_ = 0;
}
inline double ImuInfo::loc_yg_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.loc_yg_dr)
  return loc_yg_dr_;
}
inline void ImuInfo::set_loc_yg_dr(double value) {
  
  loc_yg_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.loc_yg_dr)
}

// double loc_yaw_dr = 10;
inline void ImuInfo::clear_loc_yaw_dr() {
  loc_yaw_dr_ = 0;
}
inline double ImuInfo::loc_yaw_dr() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.loc_yaw_dr)
  return loc_yaw_dr_;
}
inline void ImuInfo::set_loc_yaw_dr(double value) {
  
  loc_yaw_dr_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.loc_yaw_dr)
}

// bool correction_flag = 11;
inline void ImuInfo::clear_correction_flag() {
  correction_flag_ = false;
}
inline bool ImuInfo::correction_flag() const {
  // @@protoc_insertion_point(field_get:planning_msgs.ImuInfo.correction_flag)
  return correction_flag_;
}
inline void ImuInfo::set_correction_flag(bool value) {
  
  correction_flag_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.ImuInfo.correction_flag)
}

// -------------------------------------------------------------------

// BusinessFeedback

// .common_msgs.Header header = 1;
inline bool BusinessFeedback::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::common_msgs::Header& BusinessFeedback::header() const {
  const ::common_msgs::Header* p = header_;
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.header)
  return p != NULL ? *p : *reinterpret_cast<const ::common_msgs::Header*>(
      &::common_msgs::_Header_default_instance_);
}
inline ::common_msgs::Header* BusinessFeedback::release_header() {
  // @@protoc_insertion_point(field_release:planning_msgs.BusinessFeedback.header)
  
  ::common_msgs::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::common_msgs::Header* BusinessFeedback::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::common_msgs::Header;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.header)
  return header_;
}
inline void BusinessFeedback::set_allocated_header(::common_msgs::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.BusinessFeedback.header)
}

// .planning_msgs.Business business = 2;
inline bool BusinessFeedback::has_business() const {
  return this != internal_default_instance() && business_ != NULL;
}
inline void BusinessFeedback::clear_business() {
  if (GetArenaNoVirtual() == NULL && business_ != NULL) {
    delete business_;
  }
  business_ = NULL;
}
inline const ::planning_msgs::Business& BusinessFeedback::business() const {
  const ::planning_msgs::Business* p = business_;
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.business)
  return p != NULL ? *p : *reinterpret_cast<const ::planning_msgs::Business*>(
      &::planning_msgs::_Business_default_instance_);
}
inline ::planning_msgs::Business* BusinessFeedback::release_business() {
  // @@protoc_insertion_point(field_release:planning_msgs.BusinessFeedback.business)
  
  ::planning_msgs::Business* temp = business_;
  business_ = NULL;
  return temp;
}
inline ::planning_msgs::Business* BusinessFeedback::mutable_business() {
  
  if (business_ == NULL) {
    business_ = new ::planning_msgs::Business;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.business)
  return business_;
}
inline void BusinessFeedback::set_allocated_business(::planning_msgs::Business* business) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete business_;
  }
  if (business) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      business = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, business, submessage_arena);
    }
    
  } else {
    
  }
  business_ = business;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.BusinessFeedback.business)
}

// repeated string reference_lane_ids = 3;
inline int BusinessFeedback::reference_lane_ids_size() const {
  return reference_lane_ids_.size();
}
inline void BusinessFeedback::clear_reference_lane_ids() {
  reference_lane_ids_.Clear();
}
inline const ::std::string& BusinessFeedback::reference_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.reference_lane_ids)
  return reference_lane_ids_.Get(index);
}
inline ::std::string* BusinessFeedback::mutable_reference_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.reference_lane_ids)
  return reference_lane_ids_.Mutable(index);
}
inline void BusinessFeedback::set_reference_lane_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.reference_lane_ids)
  reference_lane_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BusinessFeedback::set_reference_lane_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.reference_lane_ids)
  reference_lane_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BusinessFeedback::set_reference_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reference_lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:planning_msgs.BusinessFeedback.reference_lane_ids)
}
inline void BusinessFeedback::set_reference_lane_ids(int index, const char* value, size_t size) {
  reference_lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.BusinessFeedback.reference_lane_ids)
}
inline ::std::string* BusinessFeedback::add_reference_lane_ids() {
  // @@protoc_insertion_point(field_add_mutable:planning_msgs.BusinessFeedback.reference_lane_ids)
  return reference_lane_ids_.Add();
}
inline void BusinessFeedback::add_reference_lane_ids(const ::std::string& value) {
  reference_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.reference_lane_ids)
}
#if LANG_CXX11
inline void BusinessFeedback::add_reference_lane_ids(::std::string&& value) {
  reference_lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.reference_lane_ids)
}
#endif
inline void BusinessFeedback::add_reference_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reference_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:planning_msgs.BusinessFeedback.reference_lane_ids)
}
inline void BusinessFeedback::add_reference_lane_ids(const char* value, size_t size) {
  reference_lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:planning_msgs.BusinessFeedback.reference_lane_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BusinessFeedback::reference_lane_ids() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BusinessFeedback.reference_lane_ids)
  return reference_lane_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BusinessFeedback::mutable_reference_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BusinessFeedback.reference_lane_ids)
  return &reference_lane_ids_;
}

// repeated string reference_target_ids = 4;
inline int BusinessFeedback::reference_target_ids_size() const {
  return reference_target_ids_.size();
}
inline void BusinessFeedback::clear_reference_target_ids() {
  reference_target_ids_.Clear();
}
inline const ::std::string& BusinessFeedback::reference_target_ids(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.reference_target_ids)
  return reference_target_ids_.Get(index);
}
inline ::std::string* BusinessFeedback::mutable_reference_target_ids(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.reference_target_ids)
  return reference_target_ids_.Mutable(index);
}
inline void BusinessFeedback::set_reference_target_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.reference_target_ids)
  reference_target_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BusinessFeedback::set_reference_target_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.reference_target_ids)
  reference_target_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BusinessFeedback::set_reference_target_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reference_target_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:planning_msgs.BusinessFeedback.reference_target_ids)
}
inline void BusinessFeedback::set_reference_target_ids(int index, const char* value, size_t size) {
  reference_target_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.BusinessFeedback.reference_target_ids)
}
inline ::std::string* BusinessFeedback::add_reference_target_ids() {
  // @@protoc_insertion_point(field_add_mutable:planning_msgs.BusinessFeedback.reference_target_ids)
  return reference_target_ids_.Add();
}
inline void BusinessFeedback::add_reference_target_ids(const ::std::string& value) {
  reference_target_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.reference_target_ids)
}
#if LANG_CXX11
inline void BusinessFeedback::add_reference_target_ids(::std::string&& value) {
  reference_target_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.reference_target_ids)
}
#endif
inline void BusinessFeedback::add_reference_target_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  reference_target_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:planning_msgs.BusinessFeedback.reference_target_ids)
}
inline void BusinessFeedback::add_reference_target_ids(const char* value, size_t size) {
  reference_target_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:planning_msgs.BusinessFeedback.reference_target_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BusinessFeedback::reference_target_ids() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BusinessFeedback.reference_target_ids)
  return reference_target_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BusinessFeedback::mutable_reference_target_ids() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BusinessFeedback.reference_target_ids)
  return &reference_target_ids_;
}

// int32 decision_id = 5;
inline void BusinessFeedback::clear_decision_id() {
  decision_id_ = 0;
}
inline ::google::protobuf::int32 BusinessFeedback::decision_id() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.decision_id)
  return decision_id_;
}
inline void BusinessFeedback::set_decision_id(::google::protobuf::int32 value) {
  
  decision_id_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.decision_id)
}

// bool path_in_current = 6;
inline void BusinessFeedback::clear_path_in_current() {
  path_in_current_ = false;
}
inline bool BusinessFeedback::path_in_current() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.path_in_current)
  return path_in_current_;
}
inline void BusinessFeedback::set_path_in_current(bool value) {
  
  path_in_current_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.path_in_current)
}

// bool is_passable = 7;
inline void BusinessFeedback::clear_is_passable() {
  is_passable_ = false;
}
inline bool BusinessFeedback::is_passable() const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.is_passable)
  return is_passable_;
}
inline void BusinessFeedback::set_is_passable(bool value) {
  
  is_passable_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.is_passable)
}

// repeated string passable_lane_ids = 8;
inline int BusinessFeedback::passable_lane_ids_size() const {
  return passable_lane_ids_.size();
}
inline void BusinessFeedback::clear_passable_lane_ids() {
  passable_lane_ids_.Clear();
}
inline const ::std::string& BusinessFeedback::passable_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.passable_lane_ids)
  return passable_lane_ids_.Get(index);
}
inline ::std::string* BusinessFeedback::mutable_passable_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.passable_lane_ids)
  return passable_lane_ids_.Mutable(index);
}
inline void BusinessFeedback::set_passable_lane_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.passable_lane_ids)
  passable_lane_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BusinessFeedback::set_passable_lane_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.passable_lane_ids)
  passable_lane_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BusinessFeedback::set_passable_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  passable_lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:planning_msgs.BusinessFeedback.passable_lane_ids)
}
inline void BusinessFeedback::set_passable_lane_ids(int index, const char* value, size_t size) {
  passable_lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.BusinessFeedback.passable_lane_ids)
}
inline ::std::string* BusinessFeedback::add_passable_lane_ids() {
  // @@protoc_insertion_point(field_add_mutable:planning_msgs.BusinessFeedback.passable_lane_ids)
  return passable_lane_ids_.Add();
}
inline void BusinessFeedback::add_passable_lane_ids(const ::std::string& value) {
  passable_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.passable_lane_ids)
}
#if LANG_CXX11
inline void BusinessFeedback::add_passable_lane_ids(::std::string&& value) {
  passable_lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.passable_lane_ids)
}
#endif
inline void BusinessFeedback::add_passable_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  passable_lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:planning_msgs.BusinessFeedback.passable_lane_ids)
}
inline void BusinessFeedback::add_passable_lane_ids(const char* value, size_t size) {
  passable_lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:planning_msgs.BusinessFeedback.passable_lane_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BusinessFeedback::passable_lane_ids() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BusinessFeedback.passable_lane_ids)
  return passable_lane_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BusinessFeedback::mutable_passable_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BusinessFeedback.passable_lane_ids)
  return &passable_lane_ids_;
}

// repeated string black_road_ids = 9;
inline int BusinessFeedback::black_road_ids_size() const {
  return black_road_ids_.size();
}
inline void BusinessFeedback::clear_black_road_ids() {
  black_road_ids_.Clear();
}
inline const ::std::string& BusinessFeedback::black_road_ids(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.BusinessFeedback.black_road_ids)
  return black_road_ids_.Get(index);
}
inline ::std::string* BusinessFeedback::mutable_black_road_ids(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.BusinessFeedback.black_road_ids)
  return black_road_ids_.Mutable(index);
}
inline void BusinessFeedback::set_black_road_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.black_road_ids)
  black_road_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BusinessFeedback::set_black_road_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.BusinessFeedback.black_road_ids)
  black_road_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BusinessFeedback::set_black_road_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  black_road_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:planning_msgs.BusinessFeedback.black_road_ids)
}
inline void BusinessFeedback::set_black_road_ids(int index, const char* value, size_t size) {
  black_road_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.BusinessFeedback.black_road_ids)
}
inline ::std::string* BusinessFeedback::add_black_road_ids() {
  // @@protoc_insertion_point(field_add_mutable:planning_msgs.BusinessFeedback.black_road_ids)
  return black_road_ids_.Add();
}
inline void BusinessFeedback::add_black_road_ids(const ::std::string& value) {
  black_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.black_road_ids)
}
#if LANG_CXX11
inline void BusinessFeedback::add_black_road_ids(::std::string&& value) {
  black_road_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:planning_msgs.BusinessFeedback.black_road_ids)
}
#endif
inline void BusinessFeedback::add_black_road_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  black_road_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:planning_msgs.BusinessFeedback.black_road_ids)
}
inline void BusinessFeedback::add_black_road_ids(const char* value, size_t size) {
  black_road_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:planning_msgs.BusinessFeedback.black_road_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BusinessFeedback::black_road_ids() const {
  // @@protoc_insertion_point(field_list:planning_msgs.BusinessFeedback.black_road_ids)
  return black_road_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BusinessFeedback::mutable_black_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.BusinessFeedback.black_road_ids)
  return &black_road_ids_;
}

// -------------------------------------------------------------------

// Business

// int32 orderreply = 1;
inline void Business::clear_orderreply() {
  orderreply_ = 0;
}
inline ::google::protobuf::int32 Business::orderreply() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.orderreply)
  return orderreply_;
}
inline void Business::set_orderreply(::google::protobuf::int32 value) {
  
  orderreply_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.orderreply)
}

// uint32 direction = 2;
inline void Business::clear_direction() {
  direction_ = 0u;
}
inline ::google::protobuf::uint32 Business::direction() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.direction)
  return direction_;
}
inline void Business::set_direction(::google::protobuf::uint32 value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.direction)
}

// int32 turning = 3;
inline void Business::clear_turning() {
  turning_ = 0;
}
inline ::google::protobuf::int32 Business::turning() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.turning)
  return turning_;
}
inline void Business::set_turning(::google::protobuf::int32 value) {
  
  turning_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.turning)
}

// int32 driving_status = 4;
inline void Business::clear_driving_status() {
  driving_status_ = 0;
}
inline ::google::protobuf::int32 Business::driving_status() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.driving_status)
  return driving_status_;
}
inline void Business::set_driving_status(::google::protobuf::int32 value) {
  
  driving_status_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.driving_status)
}

// float speed_limit = 5;
inline void Business::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float Business::speed_limit() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.speed_limit)
  return speed_limit_;
}
inline void Business::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.speed_limit)
}

// int32 impassable_flag = 6;
inline void Business::clear_impassable_flag() {
  impassable_flag_ = 0;
}
inline ::google::protobuf::int32 Business::impassable_flag() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Business.impassable_flag)
  return impassable_flag_;
}
inline void Business::set_impassable_flag(::google::protobuf::int32 value) {
  
  impassable_flag_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Business.impassable_flag)
}

// -------------------------------------------------------------------

// Trajectory

// .common_msgs.Header header = 1;
inline bool Trajectory::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::common_msgs::Header& Trajectory::header() const {
  const ::common_msgs::Header* p = header_;
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.header)
  return p != NULL ? *p : *reinterpret_cast<const ::common_msgs::Header*>(
      &::common_msgs::_Header_default_instance_);
}
inline ::common_msgs::Header* Trajectory::release_header() {
  // @@protoc_insertion_point(field_release:planning_msgs.Trajectory.header)
  
  ::common_msgs::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::common_msgs::Header* Trajectory::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::common_msgs::Header;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.Trajectory.header)
  return header_;
}
inline void Trajectory::set_allocated_header(::common_msgs::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.Trajectory.header)
}

// repeated .planning_msgs.TrajectoryPoint points = 2;
inline int Trajectory::points_size() const {
  return points_.size();
}
inline void Trajectory::clear_points() {
  points_.Clear();
}
inline const ::planning_msgs::TrajectoryPoint& Trajectory::points(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.points)
  return points_.Get(index);
}
inline ::planning_msgs::TrajectoryPoint* Trajectory::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.Trajectory.points)
  return points_.Mutable(index);
}
inline ::planning_msgs::TrajectoryPoint* Trajectory::add_points() {
  // @@protoc_insertion_point(field_add:planning_msgs.Trajectory.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::planning_msgs::TrajectoryPoint >*
Trajectory::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.Trajectory.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::planning_msgs::TrajectoryPoint >&
Trajectory::points() const {
  // @@protoc_insertion_point(field_list:planning_msgs.Trajectory.points)
  return points_;
}

// uint32 direction = 3;
inline void Trajectory::clear_direction() {
  direction_ = 0u;
}
inline ::google::protobuf::uint32 Trajectory::direction() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.direction)
  return direction_;
}
inline void Trajectory::set_direction(::google::protobuf::uint32 value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.direction)
}

// uint32 autodrvmodeentry = 4;
inline void Trajectory::clear_autodrvmodeentry() {
  autodrvmodeentry_ = 0u;
}
inline ::google::protobuf::uint32 Trajectory::autodrvmodeentry() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.autodrvmodeentry)
  return autodrvmodeentry_;
}
inline void Trajectory::set_autodrvmodeentry(::google::protobuf::uint32 value) {
  
  autodrvmodeentry_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.autodrvmodeentry)
}

// uint32 autodrvmodeexit = 5;
inline void Trajectory::clear_autodrvmodeexit() {
  autodrvmodeexit_ = 0u;
}
inline ::google::protobuf::uint32 Trajectory::autodrvmodeexit() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.autodrvmodeexit)
  return autodrvmodeexit_;
}
inline void Trajectory::set_autodrvmodeexit(::google::protobuf::uint32 value) {
  
  autodrvmodeexit_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.autodrvmodeexit)
}

// repeated string lane_ids = 6;
inline int Trajectory::lane_ids_size() const {
  return lane_ids_.size();
}
inline void Trajectory::clear_lane_ids() {
  lane_ids_.Clear();
}
inline const ::std::string& Trajectory::lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.lane_ids)
  return lane_ids_.Get(index);
}
inline ::std::string* Trajectory::mutable_lane_ids(int index) {
  // @@protoc_insertion_point(field_mutable:planning_msgs.Trajectory.lane_ids)
  return lane_ids_.Mutable(index);
}
inline void Trajectory::set_lane_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.lane_ids)
  lane_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Trajectory::set_lane_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.lane_ids)
  lane_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Trajectory::set_lane_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:planning_msgs.Trajectory.lane_ids)
}
inline void Trajectory::set_lane_ids(int index, const char* value, size_t size) {
  lane_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:planning_msgs.Trajectory.lane_ids)
}
inline ::std::string* Trajectory::add_lane_ids() {
  // @@protoc_insertion_point(field_add_mutable:planning_msgs.Trajectory.lane_ids)
  return lane_ids_.Add();
}
inline void Trajectory::add_lane_ids(const ::std::string& value) {
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:planning_msgs.Trajectory.lane_ids)
}
#if LANG_CXX11
inline void Trajectory::add_lane_ids(::std::string&& value) {
  lane_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:planning_msgs.Trajectory.lane_ids)
}
#endif
inline void Trajectory::add_lane_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lane_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:planning_msgs.Trajectory.lane_ids)
}
inline void Trajectory::add_lane_ids(const char* value, size_t size) {
  lane_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:planning_msgs.Trajectory.lane_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Trajectory::lane_ids() const {
  // @@protoc_insertion_point(field_list:planning_msgs.Trajectory.lane_ids)
  return lane_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Trajectory::mutable_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:planning_msgs.Trajectory.lane_ids)
  return &lane_ids_;
}

// int32 lane_type = 7;
inline void Trajectory::clear_lane_type() {
  lane_type_ = 0;
}
inline ::google::protobuf::int32 Trajectory::lane_type() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.lane_type)
  return lane_type_;
}
inline void Trajectory::set_lane_type(::google::protobuf::int32 value) {
  
  lane_type_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.lane_type)
}

// int32 car_fault_level = 8;
inline void Trajectory::clear_car_fault_level() {
  car_fault_level_ = 0;
}
inline ::google::protobuf::int32 Trajectory::car_fault_level() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.car_fault_level)
  return car_fault_level_;
}
inline void Trajectory::set_car_fault_level(::google::protobuf::int32 value) {
  
  car_fault_level_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.car_fault_level)
}

// float control_accuracy = 9;
inline void Trajectory::clear_control_accuracy() {
  control_accuracy_ = 0;
}
inline float Trajectory::control_accuracy() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.control_accuracy)
  return control_accuracy_;
}
inline void Trajectory::set_control_accuracy(float value) {
  
  control_accuracy_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.control_accuracy)
}

// .planning_msgs.ImuInfo imu_loc_data = 10;
inline bool Trajectory::has_imu_loc_data() const {
  return this != internal_default_instance() && imu_loc_data_ != NULL;
}
inline void Trajectory::clear_imu_loc_data() {
  if (GetArenaNoVirtual() == NULL && imu_loc_data_ != NULL) {
    delete imu_loc_data_;
  }
  imu_loc_data_ = NULL;
}
inline const ::planning_msgs::ImuInfo& Trajectory::imu_loc_data() const {
  const ::planning_msgs::ImuInfo* p = imu_loc_data_;
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.imu_loc_data)
  return p != NULL ? *p : *reinterpret_cast<const ::planning_msgs::ImuInfo*>(
      &::planning_msgs::_ImuInfo_default_instance_);
}
inline ::planning_msgs::ImuInfo* Trajectory::release_imu_loc_data() {
  // @@protoc_insertion_point(field_release:planning_msgs.Trajectory.imu_loc_data)
  
  ::planning_msgs::ImuInfo* temp = imu_loc_data_;
  imu_loc_data_ = NULL;
  return temp;
}
inline ::planning_msgs::ImuInfo* Trajectory::mutable_imu_loc_data() {
  
  if (imu_loc_data_ == NULL) {
    imu_loc_data_ = new ::planning_msgs::ImuInfo;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.Trajectory.imu_loc_data)
  return imu_loc_data_;
}
inline void Trajectory::set_allocated_imu_loc_data(::planning_msgs::ImuInfo* imu_loc_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete imu_loc_data_;
  }
  if (imu_loc_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      imu_loc_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, imu_loc_data, submessage_arena);
    }
    
  } else {
    
  }
  imu_loc_data_ = imu_loc_data;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.Trajectory.imu_loc_data)
}

// .planning_msgs.ImuInfo correct_loc_data = 11;
inline bool Trajectory::has_correct_loc_data() const {
  return this != internal_default_instance() && correct_loc_data_ != NULL;
}
inline void Trajectory::clear_correct_loc_data() {
  if (GetArenaNoVirtual() == NULL && correct_loc_data_ != NULL) {
    delete correct_loc_data_;
  }
  correct_loc_data_ = NULL;
}
inline const ::planning_msgs::ImuInfo& Trajectory::correct_loc_data() const {
  const ::planning_msgs::ImuInfo* p = correct_loc_data_;
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.correct_loc_data)
  return p != NULL ? *p : *reinterpret_cast<const ::planning_msgs::ImuInfo*>(
      &::planning_msgs::_ImuInfo_default_instance_);
}
inline ::planning_msgs::ImuInfo* Trajectory::release_correct_loc_data() {
  // @@protoc_insertion_point(field_release:planning_msgs.Trajectory.correct_loc_data)
  
  ::planning_msgs::ImuInfo* temp = correct_loc_data_;
  correct_loc_data_ = NULL;
  return temp;
}
inline ::planning_msgs::ImuInfo* Trajectory::mutable_correct_loc_data() {
  
  if (correct_loc_data_ == NULL) {
    correct_loc_data_ = new ::planning_msgs::ImuInfo;
  }
  // @@protoc_insertion_point(field_mutable:planning_msgs.Trajectory.correct_loc_data)
  return correct_loc_data_;
}
inline void Trajectory::set_allocated_correct_loc_data(::planning_msgs::ImuInfo* correct_loc_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete correct_loc_data_;
  }
  if (correct_loc_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      correct_loc_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, correct_loc_data, submessage_arena);
    }
    
  } else {
    
  }
  correct_loc_data_ = correct_loc_data;
  // @@protoc_insertion_point(field_set_allocated:planning_msgs.Trajectory.correct_loc_data)
}

// int32 gear_position_request = 12;
inline void Trajectory::clear_gear_position_request() {
  gear_position_request_ = 0;
}
inline ::google::protobuf::int32 Trajectory::gear_position_request() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.gear_position_request)
  return gear_position_request_;
}
inline void Trajectory::set_gear_position_request(::google::protobuf::int32 value) {
  
  gear_position_request_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.gear_position_request)
}

// int32 senario_type = 13;
inline void Trajectory::clear_senario_type() {
  senario_type_ = 0;
}
inline ::google::protobuf::int32 Trajectory::senario_type() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.senario_type)
  return senario_type_;
}
inline void Trajectory::set_senario_type(::google::protobuf::int32 value) {
  
  senario_type_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.senario_type)
}

// float steeringangle_rate_max = 14;
inline void Trajectory::clear_steeringangle_rate_max() {
  steeringangle_rate_max_ = 0;
}
inline float Trajectory::steeringangle_rate_max() const {
  // @@protoc_insertion_point(field_get:planning_msgs.Trajectory.steeringangle_rate_max)
  return steeringangle_rate_max_;
}
inline void Trajectory::set_steeringangle_rate_max(float value) {
  
  steeringangle_rate_max_ = value;
  // @@protoc_insertion_point(field_set:planning_msgs.Trajectory.steeringangle_rate_max)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning_msgs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planning_5fmsgs_2eproto__INCLUDED
