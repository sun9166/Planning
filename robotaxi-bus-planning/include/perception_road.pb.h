// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception_road.proto

#ifndef PROTOBUF_perception_5froad_2eproto__INCLUDED
#define PROTOBUF_perception_5froad_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "perception_sensor_info.pb.h"
#include "perception_types.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_5froad_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLaneHostImpl();
void InitDefaultsLaneHost();
void InitDefaultsLaneAdjacentImpl();
void InitDefaultsLaneAdjacent();
void InitDefaultsLaneRoadedgeImpl();
void InitDefaultsLaneRoadedge();
void InitDefaultsLaneImpl();
void InitDefaultsLane();
void InitDefaultsRoadMarkImpl();
void InitDefaultsRoadMark();
void InitDefaultsFreeSpaceImagePointImpl();
void InitDefaultsFreeSpaceImagePoint();
void InitDefaultsFreeSpacePointImpl();
void InitDefaultsFreeSpacePoint();
void InitDefaultsFreeSpaceImpl();
void InitDefaultsFreeSpace();
inline void InitDefaults() {
  InitDefaultsLaneHost();
  InitDefaultsLaneAdjacent();
  InitDefaultsLaneRoadedge();
  InitDefaultsLane();
  InitDefaultsRoadMark();
  InitDefaultsFreeSpaceImagePoint();
  InitDefaultsFreeSpacePoint();
  InitDefaultsFreeSpace();
}
}  // namespace protobuf_perception_5froad_2eproto
namespace calmcar {
namespace perception {
class FreeSpace;
class FreeSpaceDefaultTypeInternal;
extern FreeSpaceDefaultTypeInternal _FreeSpace_default_instance_;
class FreeSpaceImagePoint;
class FreeSpaceImagePointDefaultTypeInternal;
extern FreeSpaceImagePointDefaultTypeInternal _FreeSpaceImagePoint_default_instance_;
class FreeSpacePoint;
class FreeSpacePointDefaultTypeInternal;
extern FreeSpacePointDefaultTypeInternal _FreeSpacePoint_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneAdjacent;
class LaneAdjacentDefaultTypeInternal;
extern LaneAdjacentDefaultTypeInternal _LaneAdjacent_default_instance_;
class LaneHost;
class LaneHostDefaultTypeInternal;
extern LaneHostDefaultTypeInternal _LaneHost_default_instance_;
class LaneRoadedge;
class LaneRoadedgeDefaultTypeInternal;
extern LaneRoadedgeDefaultTypeInternal _LaneRoadedge_default_instance_;
class RoadMark;
class RoadMarkDefaultTypeInternal;
extern RoadMarkDefaultTypeInternal _RoadMark_default_instance_;
}  // namespace perception
}  // namespace calmcar
namespace calmcar {
namespace perception {

enum LineColor {
  LINE_COLOR_UNKNOWN = 0,
  LINE_COLOR_WHITE = 1,
  LINE_COLOR_YELLOW = 2,
  LINE_COLOR_BLUE_GREEN = 3,
  LINE_COLOR_ORANGE_RED = 4,
  LineColor_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LineColor_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LineColor_IsValid(int value);
const LineColor LineColor_MIN = LINE_COLOR_UNKNOWN;
const LineColor LineColor_MAX = LINE_COLOR_ORANGE_RED;
const int LineColor_ARRAYSIZE = LineColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineColor_descriptor();
inline const ::std::string& LineColor_Name(LineColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineColor_descriptor(), value);
}
inline bool LineColor_Parse(
    const ::std::string& name, LineColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineColor>(
    LineColor_descriptor(), name, value);
}
enum LineQuality {
  LINE_QUALITY_VERY_LOW = 0,
  LINE_QUALITY_LOW = 1,
  LINE_QUALITY_PREDICTION = 2,
  LINE_QUALITY_RELIABLE = 3,
  LINE_QUALITY_MORE_RELIABLE = 4,
  LINE_QUALITY_HIGH_QUALITY = 5,
  LineQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LineQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LineQuality_IsValid(int value);
const LineQuality LineQuality_MIN = LINE_QUALITY_VERY_LOW;
const LineQuality LineQuality_MAX = LINE_QUALITY_HIGH_QUALITY;
const int LineQuality_ARRAYSIZE = LineQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineQuality_descriptor();
inline const ::std::string& LineQuality_Name(LineQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineQuality_descriptor(), value);
}
inline bool LineQuality_Parse(
    const ::std::string& name, LineQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineQuality>(
    LineQuality_descriptor(), name, value);
}
enum LanemarkType {
  LANEMARK_TYPE_UNDECIDED = 0,
  LANEMARK_TYPE_SOLID = 1,
  LANEMARKE_TYPE_DASHED = 2,
  LANEMARK_TYPE_DLM = 3,
  LANEMARK_TYPE_BOTTS_DOTS = 4,
  LANEMARK_TYPE_DECELERATION = 5,
  LANEMARK_TYPE_HOV_LANE = 6,
  LanemarkType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LanemarkType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LanemarkType_IsValid(int value);
const LanemarkType LanemarkType_MIN = LANEMARK_TYPE_UNDECIDED;
const LanemarkType LanemarkType_MAX = LANEMARK_TYPE_HOV_LANE;
const int LanemarkType_ARRAYSIZE = LanemarkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LanemarkType_descriptor();
inline const ::std::string& LanemarkType_Name(LanemarkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LanemarkType_descriptor(), value);
}
inline bool LanemarkType_Parse(
    const ::std::string& name, LanemarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LanemarkType>(
    LanemarkType_descriptor(), name, value);
}
enum LreType {
  LRE_TYPE_UNDECIDED = 0,
  LRE_TYPE_ROAD_EDGE = 1,
  LRE_TYPE_ELEVATED_STRUCTURE = 2,
  LRE_TYPE_CURB = 3,
  LRE_TYPE_CONES_POLES = 4,
  LRE_TYPE_PARKING_CARS = 5,
  LreType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LreType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LreType_IsValid(int value);
const LreType LreType_MIN = LRE_TYPE_UNDECIDED;
const LreType LreType_MAX = LRE_TYPE_PARKING_CARS;
const int LreType_ARRAYSIZE = LreType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LreType_descriptor();
inline const ::std::string& LreType_Name(LreType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LreType_descriptor(), value);
}
inline bool LreType_Parse(
    const ::std::string& name, LreType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LreType>(
    LreType_descriptor(), name, value);
}
enum DlmType {
  DLM_TYPE_NOT_DLM = 0,
  DLM_TYPE_SOLID_DASHED = 1,
  DLM_TYPE_DASHED_SOLID = 2,
  DLM_TYPE_SOLID_SOLID = 3,
  DLM_TYPE_DASHED_DASHED = 4,
  DLM_TYPE_UNDECIDED = 5,
  DlmType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DlmType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DlmType_IsValid(int value);
const DlmType DlmType_MIN = DLM_TYPE_NOT_DLM;
const DlmType DlmType_MAX = DLM_TYPE_UNDECIDED;
const int DlmType_ARRAYSIZE = DlmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DlmType_descriptor();
inline const ::std::string& DlmType_Name(DlmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DlmType_descriptor(), value);
}
inline bool DlmType_Parse(
    const ::std::string& name, DlmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DlmType>(
    DlmType_descriptor(), name, value);
}
enum DecelType {
  DECEL_TYPE_NOT_DECEL = 0,
  DECEL_TYPE_SOLID = 1,
  DECEL_TYPE_DASHED = 2,
  DECEL_TYPE_RESERVED = 3,
  DecelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DecelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DecelType_IsValid(int value);
const DecelType DecelType_MIN = DECEL_TYPE_NOT_DECEL;
const DecelType DecelType_MAX = DECEL_TYPE_RESERVED;
const int DecelType_ARRAYSIZE = DecelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecelType_descriptor();
inline const ::std::string& DecelType_Name(DecelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecelType_descriptor(), value);
}
inline bool DecelType_Parse(
    const ::std::string& name, DecelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecelType>(
    DecelType_descriptor(), name, value);
}
enum LineSide {
  LINE_SIDE_UNKNOWN = 0,
  LINE_SIDE_LEFT = 1,
  LINE_SIDE_RIGHT = 2,
  LineSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LineSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LineSide_IsValid(int value);
const LineSide LineSide_MIN = LINE_SIDE_UNKNOWN;
const LineSide LineSide_MAX = LINE_SIDE_RIGHT;
const int LineSide_ARRAYSIZE = LineSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineSide_descriptor();
inline const ::std::string& LineSide_Name(LineSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineSide_descriptor(), value);
}
inline bool LineSide_Parse(
    const ::std::string& name, LineSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineSide>(
    LineSide_descriptor(), name, value);
}
enum LineRole {
  LINE_ROLE_NONE = 0,
  LINE_ROLE_LEFT_LEFT_LANEMARK = 1,
  LINE_ROLE_LEFT_RIGHT_LANEMARK = 2,
  LINE_ROLE_RIGHT_LEFT_LANEMARK = 3,
  LINE_ROLE_RIGHT_RIGHT_LANEMARK = 4,
  LineRole_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LineRole_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LineRole_IsValid(int value);
const LineRole LineRole_MIN = LINE_ROLE_NONE;
const LineRole LineRole_MAX = LINE_ROLE_RIGHT_RIGHT_LANEMARK;
const int LineRole_ARRAYSIZE = LineRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineRole_descriptor();
inline const ::std::string& LineRole_Name(LineRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineRole_descriptor(), value);
}
inline bool LineRole_Parse(
    const ::std::string& name, LineRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineRole>(
    LineRole_descriptor(), name, value);
}
enum LreIndex {
  LRE_INDEX_UNFILLED = 0,
  LRE_INDEX_FIRST = 1,
  LRE_INDEX_SECOND = 2,
  LreIndex_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LreIndex_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LreIndex_IsValid(int value);
const LreIndex LreIndex_MIN = LRE_INDEX_UNFILLED;
const LreIndex LreIndex_MAX = LRE_INDEX_SECOND;
const int LreIndex_ARRAYSIZE = LreIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* LreIndex_descriptor();
inline const ::std::string& LreIndex_Name(LreIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    LreIndex_descriptor(), value);
}
inline bool LreIndex_Parse(
    const ::std::string& name, LreIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LreIndex>(
    LreIndex_descriptor(), name, value);
}
enum FSPType {
  FSP_TYPE_UNKNOWN = 0,
  FSP_TYPE_ROAD_EDGE = 1,
  FSP_TYPE_PARTICIPAN = 2,
  FSP_TYPE_BARRICADE = 3,
  FSPType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FSPType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FSPType_IsValid(int value);
const FSPType FSPType_MIN = FSP_TYPE_UNKNOWN;
const FSPType FSPType_MAX = FSP_TYPE_BARRICADE;
const int FSPType_ARRAYSIZE = FSPType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FSPType_descriptor();
inline const ::std::string& FSPType_Name(FSPType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FSPType_descriptor(), value);
}
inline bool FSPType_Parse(
    const ::std::string& name, FSPType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FSPType>(
    FSPType_descriptor(), name, value);
}
// ===================================================================

class LaneHost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LaneHost) */ {
 public:
  LaneHost();
  virtual ~LaneHost();

  LaneHost(const LaneHost& from);

  inline LaneHost& operator=(const LaneHost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneHost(LaneHost&& from) noexcept
    : LaneHost() {
    *this = ::std::move(from);
  }

  inline LaneHost& operator=(LaneHost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneHost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneHost* internal_default_instance() {
    return reinterpret_cast<const LaneHost*>(
               &_LaneHost_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaneHost* other);
  friend void swap(LaneHost& a, LaneHost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneHost* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneHost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneHost& from);
  void MergeFrom(const LaneHost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneHost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.Point2i image_points = 37;
  int image_points_size() const;
  void clear_image_points();
  static const int kImagePointsFieldNumber = 37;
  const ::calmcar::perception::Point2i& image_points(int index) const;
  ::calmcar::perception::Point2i* mutable_image_points(int index);
  ::calmcar::perception::Point2i* add_image_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
      mutable_image_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
      image_points() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 track_id = 2;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  ::google::protobuf::int32 track_id() const;
  void set_track_id(::google::protobuf::int32 value);

  // int32 age = 3;
  void clear_age();
  static const int kAgeFieldNumber = 3;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // float exist_probability = 4;
  void clear_exist_probability();
  static const int kExistProbabilityFieldNumber = 4;
  float exist_probability() const;
  void set_exist_probability(float value);

  // .calmcar.perception.LineQuality quality = 5;
  void clear_quality();
  static const int kQualityFieldNumber = 5;
  ::calmcar::perception::LineQuality quality() const;
  void set_quality(::calmcar::perception::LineQuality value);

  // int64 prediction_source = 6;
  void clear_prediction_source();
  static const int kPredictionSourceFieldNumber = 6;
  ::google::protobuf::int64 prediction_source() const;
  void set_prediction_source(::google::protobuf::int64 value);

  // int64 prediction_type = 7;
  void clear_prediction_type();
  static const int kPredictionTypeFieldNumber = 7;
  ::google::protobuf::int64 prediction_type() const;
  void set_prediction_type(::google::protobuf::int64 value);

  // .calmcar.perception.LineColor color = 8;
  void clear_color();
  static const int kColorFieldNumber = 8;
  ::calmcar::perception::LineColor color() const;
  void set_color(::calmcar::perception::LineColor value);

  // float color_confidence = 9;
  void clear_color_confidence();
  static const int kColorConfidenceFieldNumber = 9;
  float color_confidence() const;
  void set_color_confidence(float value);

  // .calmcar.perception.LanemarkType lanemark_type = 10;
  void clear_lanemark_type();
  static const int kLanemarkTypeFieldNumber = 10;
  ::calmcar::perception::LanemarkType lanemark_type() const;
  void set_lanemark_type(::calmcar::perception::LanemarkType value);

  // float lanemark_type_confidence = 11;
  void clear_lanemark_type_confidence();
  static const int kLanemarkTypeConfidenceFieldNumber = 11;
  float lanemark_type_confidence() const;
  void set_lanemark_type_confidence(float value);

  // .calmcar.perception.DlmType dlm_type = 12;
  void clear_dlm_type();
  static const int kDlmTypeFieldNumber = 12;
  ::calmcar::perception::DlmType dlm_type() const;
  void set_dlm_type(::calmcar::perception::DlmType value);

  // .calmcar.perception.DecelType decel_type = 13;
  void clear_decel_type();
  static const int kDecelTypeFieldNumber = 13;
  ::calmcar::perception::DecelType decel_type() const;
  void set_decel_type(::calmcar::perception::DecelType value);

  // .calmcar.perception.LineSide side = 14;
  void clear_side();
  static const int kSideFieldNumber = 14;
  ::calmcar::perception::LineSide side() const;
  void set_side(::calmcar::perception::LineSide value);

  // float marker_width = 16;
  void clear_marker_width();
  static const int kMarkerWidthFieldNumber = 16;
  float marker_width() const;
  void set_marker_width(float value);

  // float marker_width_std = 17;
  void clear_marker_width_std();
  static const int kMarkerWidthStdFieldNumber = 17;
  float marker_width_std() const;
  void set_marker_width_std(float value);

  // float dash_average_length = 18;
  void clear_dash_average_length();
  static const int kDashAverageLengthFieldNumber = 18;
  float dash_average_length() const;
  void set_dash_average_length(float value);

  // float dash_average_gap = 19;
  void clear_dash_average_gap();
  static const int kDashAverageGapFieldNumber = 19;
  float dash_average_gap() const;
  void set_dash_average_gap(float value);

  // float first_line_c3 = 21;
  void clear_first_line_c3();
  static const int kFirstLineC3FieldNumber = 21;
  float first_line_c3() const;
  void set_first_line_c3(float value);

  // float first_line_c2 = 22;
  void clear_first_line_c2();
  static const int kFirstLineC2FieldNumber = 22;
  float first_line_c2() const;
  void set_first_line_c2(float value);

  // float first_line_c1 = 23;
  void clear_first_line_c1();
  static const int kFirstLineC1FieldNumber = 23;
  float first_line_c1() const;
  void set_first_line_c1(float value);

  // float first_line_c0 = 24;
  void clear_first_line_c0();
  static const int kFirstLineC0FieldNumber = 24;
  float first_line_c0() const;
  void set_first_line_c0(float value);

  // float first_view_range_start = 25;
  void clear_first_view_range_start();
  static const int kFirstViewRangeStartFieldNumber = 25;
  float first_view_range_start() const;
  void set_first_view_range_start(float value);

  // float first_view_range_end = 26;
  void clear_first_view_range_end();
  static const int kFirstViewRangeEndFieldNumber = 26;
  float first_view_range_end() const;
  void set_first_view_range_end(float value);

  // float first_measured_view_range_end = 27;
  void clear_first_measured_view_range_end();
  static const int kFirstMeasuredViewRangeEndFieldNumber = 27;
  float first_measured_view_range_end() const;
  void set_first_measured_view_range_end(float value);

  // bool crossing = 15;
  void clear_crossing();
  static const int kCrossingFieldNumber = 15;
  bool crossing() const;
  void set_crossing(bool value);

  // bool is_multi_clothoid = 20;
  void clear_is_multi_clothoid();
  static const int kIsMultiClothoidFieldNumber = 20;
  bool is_multi_clothoid() const;
  void set_is_multi_clothoid(bool value);

  // bool is_valid = 36;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 36;
  bool is_valid() const;
  void set_is_valid(bool value);

  // bool availability_state = 38;
  void clear_availability_state();
  static const int kAvailabilityStateFieldNumber = 38;
  bool availability_state() const;
  void set_availability_state(bool value);

  // float second_line_c3 = 28;
  void clear_second_line_c3();
  static const int kSecondLineC3FieldNumber = 28;
  float second_line_c3() const;
  void set_second_line_c3(float value);

  // float second_line_c2 = 29;
  void clear_second_line_c2();
  static const int kSecondLineC2FieldNumber = 29;
  float second_line_c2() const;
  void set_second_line_c2(float value);

  // float second_line_c1 = 30;
  void clear_second_line_c1();
  static const int kSecondLineC1FieldNumber = 30;
  float second_line_c1() const;
  void set_second_line_c1(float value);

  // float second_line_c0 = 31;
  void clear_second_line_c0();
  static const int kSecondLineC0FieldNumber = 31;
  float second_line_c0() const;
  void set_second_line_c0(float value);

  // float second_view_range_start = 32;
  void clear_second_view_range_start();
  static const int kSecondViewRangeStartFieldNumber = 32;
  float second_view_range_start() const;
  void set_second_view_range_start(float value);

  // float second_view_range_end = 33;
  void clear_second_view_range_end();
  static const int kSecondViewRangeEndFieldNumber = 33;
  float second_view_range_end() const;
  void set_second_view_range_end(float value);

  // float second_measured_view_range_end = 34;
  void clear_second_measured_view_range_end();
  static const int kSecondMeasuredViewRangeEndFieldNumber = 34;
  float second_measured_view_range_end() const;
  void set_second_measured_view_range_end(float value);

  // .calmcar.perception.CameraInfo.Position camera_position = 35;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 35;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LaneHost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i > image_points_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 track_id_;
  ::google::protobuf::int32 age_;
  float exist_probability_;
  int quality_;
  ::google::protobuf::int64 prediction_source_;
  ::google::protobuf::int64 prediction_type_;
  int color_;
  float color_confidence_;
  int lanemark_type_;
  float lanemark_type_confidence_;
  int dlm_type_;
  int decel_type_;
  int side_;
  float marker_width_;
  float marker_width_std_;
  float dash_average_length_;
  float dash_average_gap_;
  float first_line_c3_;
  float first_line_c2_;
  float first_line_c1_;
  float first_line_c0_;
  float first_view_range_start_;
  float first_view_range_end_;
  float first_measured_view_range_end_;
  bool crossing_;
  bool is_multi_clothoid_;
  bool is_valid_;
  bool availability_state_;
  float second_line_c3_;
  float second_line_c2_;
  float second_line_c1_;
  float second_line_c0_;
  float second_view_range_start_;
  float second_view_range_end_;
  float second_measured_view_range_end_;
  int camera_position_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsLaneHostImpl();
};
// -------------------------------------------------------------------

class LaneAdjacent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LaneAdjacent) */ {
 public:
  LaneAdjacent();
  virtual ~LaneAdjacent();

  LaneAdjacent(const LaneAdjacent& from);

  inline LaneAdjacent& operator=(const LaneAdjacent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneAdjacent(LaneAdjacent&& from) noexcept
    : LaneAdjacent() {
    *this = ::std::move(from);
  }

  inline LaneAdjacent& operator=(LaneAdjacent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneAdjacent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneAdjacent* internal_default_instance() {
    return reinterpret_cast<const LaneAdjacent*>(
               &_LaneAdjacent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LaneAdjacent* other);
  friend void swap(LaneAdjacent& a, LaneAdjacent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneAdjacent* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneAdjacent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneAdjacent& from);
  void MergeFrom(const LaneAdjacent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneAdjacent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.Point2i image_points = 25;
  int image_points_size() const;
  void clear_image_points();
  static const int kImagePointsFieldNumber = 25;
  const ::calmcar::perception::Point2i& image_points(int index) const;
  ::calmcar::perception::Point2i* mutable_image_points(int index);
  ::calmcar::perception::Point2i* add_image_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
      mutable_image_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
      image_points() const;

  // int32 track_id = 1;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 1;
  ::google::protobuf::int32 track_id() const;
  void set_track_id(::google::protobuf::int32 value);

  // int32 age = 2;
  void clear_age();
  static const int kAgeFieldNumber = 2;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // float exist_probability = 3;
  void clear_exist_probability();
  static const int kExistProbabilityFieldNumber = 3;
  float exist_probability() const;
  void set_exist_probability(float value);

  // .calmcar.perception.LineQuality quality = 4;
  void clear_quality();
  static const int kQualityFieldNumber = 4;
  ::calmcar::perception::LineQuality quality() const;
  void set_quality(::calmcar::perception::LineQuality value);

  // int64 prediction_source = 5;
  void clear_prediction_source();
  static const int kPredictionSourceFieldNumber = 5;
  ::google::protobuf::int64 prediction_source() const;
  void set_prediction_source(::google::protobuf::int64 value);

  // int64 prediction_type = 6;
  void clear_prediction_type();
  static const int kPredictionTypeFieldNumber = 6;
  ::google::protobuf::int64 prediction_type() const;
  void set_prediction_type(::google::protobuf::int64 value);

  // .calmcar.perception.LineColor color = 7;
  void clear_color();
  static const int kColorFieldNumber = 7;
  ::calmcar::perception::LineColor color() const;
  void set_color(::calmcar::perception::LineColor value);

  // float color_confidence = 8;
  void clear_color_confidence();
  static const int kColorConfidenceFieldNumber = 8;
  float color_confidence() const;
  void set_color_confidence(float value);

  // .calmcar.perception.LanemarkType lanemark_type = 9;
  void clear_lanemark_type();
  static const int kLanemarkTypeFieldNumber = 9;
  ::calmcar::perception::LanemarkType lanemark_type() const;
  void set_lanemark_type(::calmcar::perception::LanemarkType value);

  // float lanemark_type_confidence = 10;
  void clear_lanemark_type_confidence();
  static const int kLanemarkTypeConfidenceFieldNumber = 10;
  float lanemark_type_confidence() const;
  void set_lanemark_type_confidence(float value);

  // .calmcar.perception.DlmType dlm_type = 11;
  void clear_dlm_type();
  static const int kDlmTypeFieldNumber = 11;
  ::calmcar::perception::DlmType dlm_type() const;
  void set_dlm_type(::calmcar::perception::DlmType value);

  // .calmcar.perception.LineRole role = 12;
  void clear_role();
  static const int kRoleFieldNumber = 12;
  ::calmcar::perception::LineRole role() const;
  void set_role(::calmcar::perception::LineRole value);

  // float marker_width = 13;
  void clear_marker_width();
  static const int kMarkerWidthFieldNumber = 13;
  float marker_width() const;
  void set_marker_width(float value);

  // float marker_width_std = 14;
  void clear_marker_width_std();
  static const int kMarkerWidthStdFieldNumber = 14;
  float marker_width_std() const;
  void set_marker_width_std(float value);

  // float line_c3 = 15;
  void clear_line_c3();
  static const int kLineC3FieldNumber = 15;
  float line_c3() const;
  void set_line_c3(float value);

  // float line_c2 = 16;
  void clear_line_c2();
  static const int kLineC2FieldNumber = 16;
  float line_c2() const;
  void set_line_c2(float value);

  // float line_c1 = 17;
  void clear_line_c1();
  static const int kLineC1FieldNumber = 17;
  float line_c1() const;
  void set_line_c1(float value);

  // float line_c0 = 18;
  void clear_line_c0();
  static const int kLineC0FieldNumber = 18;
  float line_c0() const;
  void set_line_c0(float value);

  // float view_range_start = 19;
  void clear_view_range_start();
  static const int kViewRangeStartFieldNumber = 19;
  float view_range_start() const;
  void set_view_range_start(float value);

  // float view_range_end = 20;
  void clear_view_range_end();
  static const int kViewRangeEndFieldNumber = 20;
  float view_range_end() const;
  void set_view_range_end(float value);

  // int64 timestamp = 22;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 22;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // float measured_view_range_end = 21;
  void clear_measured_view_range_end();
  static const int kMeasuredViewRangeEndFieldNumber = 21;
  float measured_view_range_end() const;
  void set_measured_view_range_end(float value);

  // .calmcar.perception.CameraInfo.Position camera_position = 23;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 23;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // bool is_valid = 24;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 24;
  bool is_valid() const;
  void set_is_valid(bool value);

  // bool availability_state = 26;
  void clear_availability_state();
  static const int kAvailabilityStateFieldNumber = 26;
  bool availability_state() const;
  void set_availability_state(bool value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LaneAdjacent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i > image_points_;
  ::google::protobuf::int32 track_id_;
  ::google::protobuf::int32 age_;
  float exist_probability_;
  int quality_;
  ::google::protobuf::int64 prediction_source_;
  ::google::protobuf::int64 prediction_type_;
  int color_;
  float color_confidence_;
  int lanemark_type_;
  float lanemark_type_confidence_;
  int dlm_type_;
  int role_;
  float marker_width_;
  float marker_width_std_;
  float line_c3_;
  float line_c2_;
  float line_c1_;
  float line_c0_;
  float view_range_start_;
  float view_range_end_;
  ::google::protobuf::int64 timestamp_;
  float measured_view_range_end_;
  int camera_position_;
  bool is_valid_;
  bool availability_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsLaneAdjacentImpl();
};
// -------------------------------------------------------------------

class LaneRoadedge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.LaneRoadedge) */ {
 public:
  LaneRoadedge();
  virtual ~LaneRoadedge();

  LaneRoadedge(const LaneRoadedge& from);

  inline LaneRoadedge& operator=(const LaneRoadedge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneRoadedge(LaneRoadedge&& from) noexcept
    : LaneRoadedge() {
    *this = ::std::move(from);
  }

  inline LaneRoadedge& operator=(LaneRoadedge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneRoadedge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneRoadedge* internal_default_instance() {
    return reinterpret_cast<const LaneRoadedge*>(
               &_LaneRoadedge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LaneRoadedge* other);
  friend void swap(LaneRoadedge& a, LaneRoadedge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneRoadedge* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneRoadedge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneRoadedge& from);
  void MergeFrom(const LaneRoadedge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneRoadedge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.Point2i image_points = 20;
  int image_points_size() const;
  void clear_image_points();
  static const int kImagePointsFieldNumber = 20;
  const ::calmcar::perception::Point2i& image_points(int index) const;
  ::calmcar::perception::Point2i* mutable_image_points(int index);
  ::calmcar::perception::Point2i* add_image_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
      mutable_image_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
      image_points() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 age = 2;
  void clear_age();
  static const int kAgeFieldNumber = 2;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // float exist_probability = 3;
  void clear_exist_probability();
  static const int kExistProbabilityFieldNumber = 3;
  float exist_probability() const;
  void set_exist_probability(float value);

  // .calmcar.perception.LreType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::calmcar::perception::LreType type() const;
  void set_type(::calmcar::perception::LreType value);

  // int32 prediction_type = 5;
  void clear_prediction_type();
  static const int kPredictionTypeFieldNumber = 5;
  ::google::protobuf::int32 prediction_type() const;
  void set_prediction_type(::google::protobuf::int32 value);

  // .calmcar.perception.LineSide side = 6;
  void clear_side();
  static const int kSideFieldNumber = 6;
  ::calmcar::perception::LineSide side() const;
  void set_side(::calmcar::perception::LineSide value);

  // .calmcar.perception.LreIndex index = 7;
  void clear_index();
  static const int kIndexFieldNumber = 7;
  ::calmcar::perception::LreIndex index() const;
  void set_index(::calmcar::perception::LreIndex value);

  // float height = 8;
  void clear_height();
  static const int kHeightFieldNumber = 8;
  float height() const;
  void set_height(float value);

  // float height_std = 9;
  void clear_height_std();
  static const int kHeightStdFieldNumber = 9;
  float height_std() const;
  void set_height_std(float value);

  // float line_c3 = 10;
  void clear_line_c3();
  static const int kLineC3FieldNumber = 10;
  float line_c3() const;
  void set_line_c3(float value);

  // float line_c1 = 11;
  void clear_line_c1();
  static const int kLineC1FieldNumber = 11;
  float line_c1() const;
  void set_line_c1(float value);

  // float line_c2 = 12;
  void clear_line_c2();
  static const int kLineC2FieldNumber = 12;
  float line_c2() const;
  void set_line_c2(float value);

  // float line_c0 = 13;
  void clear_line_c0();
  static const int kLineC0FieldNumber = 13;
  float line_c0() const;
  void set_line_c0(float value);

  // float view_range_start = 14;
  void clear_view_range_start();
  static const int kViewRangeStartFieldNumber = 14;
  float view_range_start() const;
  void set_view_range_start(float value);

  // float view_range_end = 15;
  void clear_view_range_end();
  static const int kViewRangeEndFieldNumber = 15;
  float view_range_end() const;
  void set_view_range_end(float value);

  // float measured_view_range_end = 16;
  void clear_measured_view_range_end();
  static const int kMeasuredViewRangeEndFieldNumber = 16;
  float measured_view_range_end() const;
  void set_measured_view_range_end(float value);

  // int64 timestamp = 17;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 17;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 18;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 18;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // bool is_valid = 19;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 19;
  bool is_valid() const;
  void set_is_valid(bool value);

  // bool availability_state = 21;
  void clear_availability_state();
  static const int kAvailabilityStateFieldNumber = 21;
  bool availability_state() const;
  void set_availability_state(bool value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.LaneRoadedge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i > image_points_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 age_;
  float exist_probability_;
  int type_;
  ::google::protobuf::int32 prediction_type_;
  int side_;
  int index_;
  float height_;
  float height_std_;
  float line_c3_;
  float line_c1_;
  float line_c2_;
  float line_c0_;
  float view_range_start_;
  float view_range_end_;
  float measured_view_range_end_;
  ::google::protobuf::int64 timestamp_;
  int camera_position_;
  bool is_valid_;
  bool availability_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsLaneRoadedgeImpl();
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const PROTOBUF_FINAL { return New(NULL); }

  Lane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.LaneHost lane_host = 4;
  int lane_host_size() const;
  void clear_lane_host();
  static const int kLaneHostFieldNumber = 4;
  const ::calmcar::perception::LaneHost& lane_host(int index) const;
  ::calmcar::perception::LaneHost* mutable_lane_host(int index);
  ::calmcar::perception::LaneHost* add_lane_host();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneHost >*
      mutable_lane_host();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneHost >&
      lane_host() const;

  // repeated .calmcar.perception.LaneAdjacent lane_adjacent = 6;
  int lane_adjacent_size() const;
  void clear_lane_adjacent();
  static const int kLaneAdjacentFieldNumber = 6;
  const ::calmcar::perception::LaneAdjacent& lane_adjacent(int index) const;
  ::calmcar::perception::LaneAdjacent* mutable_lane_adjacent(int index);
  ::calmcar::perception::LaneAdjacent* add_lane_adjacent();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneAdjacent >*
      mutable_lane_adjacent();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneAdjacent >&
      lane_adjacent() const;

  // repeated .calmcar.perception.LaneRoadedge road_edge = 8;
  int road_edge_size() const;
  void clear_road_edge();
  static const int kRoadEdgeFieldNumber = 8;
  const ::calmcar::perception::LaneRoadedge& road_edge(int index) const;
  ::calmcar::perception::LaneRoadedge* mutable_road_edge(int index);
  ::calmcar::perception::LaneRoadedge* add_road_edge();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneRoadedge >*
      mutable_road_edge();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneRoadedge >&
      road_edge() const;

  // int64 sync_id = 1;
  void clear_sync_id();
  static const int kSyncIdFieldNumber = 1;
  ::google::protobuf::int64 sync_id() const;
  void set_sync_id(::google::protobuf::int64 value);

  // float estimated_width = 2;
  void clear_estimated_width();
  static const int kEstimatedWidthFieldNumber = 2;
  float estimated_width() const;
  void set_estimated_width(float value);

  // int32 lane_host_count = 3;
  void clear_lane_host_count();
  static const int kLaneHostCountFieldNumber = 3;
  ::google::protobuf::int32 lane_host_count() const;
  void set_lane_host_count(::google::protobuf::int32 value);

  // int32 lane_adjacent_count = 5;
  void clear_lane_adjacent_count();
  static const int kLaneAdjacentCountFieldNumber = 5;
  ::google::protobuf::int32 lane_adjacent_count() const;
  void set_lane_adjacent_count(::google::protobuf::int32 value);

  // int32 road_edge_count = 7;
  void clear_road_edge_count();
  static const int kRoadEdgeCountFieldNumber = 7;
  ::google::protobuf::int32 road_edge_count() const;
  void set_road_edge_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneHost > lane_host_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneAdjacent > lane_adjacent_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneRoadedge > road_edge_;
  ::google::protobuf::int64 sync_id_;
  float estimated_width_;
  ::google::protobuf::int32 lane_host_count_;
  ::google::protobuf::int32 lane_adjacent_count_;
  ::google::protobuf::int32 road_edge_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsLaneImpl();
};
// -------------------------------------------------------------------

class RoadMark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.RoadMark) */ {
 public:
  RoadMark();
  virtual ~RoadMark();

  RoadMark(const RoadMark& from);

  inline RoadMark& operator=(const RoadMark& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadMark(RoadMark&& from) noexcept
    : RoadMark() {
    *this = ::std::move(from);
  }

  inline RoadMark& operator=(RoadMark&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadMark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadMark* internal_default_instance() {
    return reinterpret_cast<const RoadMark*>(
               &_RoadMark_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RoadMark* other);
  friend void swap(RoadMark& a, RoadMark& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadMark* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadMark* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadMark& from);
  void MergeFrom(const RoadMark& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadMark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_class_name = 8;
  void clear_object_class_name();
  static const int kObjectClassNameFieldNumber = 8;
  const ::std::string& object_class_name() const;
  void set_object_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_object_class_name(::std::string&& value);
  #endif
  void set_object_class_name(const char* value);
  void set_object_class_name(const char* value, size_t size);
  ::std::string* mutable_object_class_name();
  ::std::string* release_object_class_name();
  void set_allocated_object_class_name(::std::string* object_class_name);

  // string object_subclass_name = 10;
  void clear_object_subclass_name();
  static const int kObjectSubclassNameFieldNumber = 10;
  const ::std::string& object_subclass_name() const;
  void set_object_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_object_subclass_name(::std::string&& value);
  #endif
  void set_object_subclass_name(const char* value);
  void set_object_subclass_name(const char* value, size_t size);
  ::std::string* mutable_object_subclass_name();
  ::std::string* release_object_subclass_name();
  void set_allocated_object_subclass_name(::std::string* object_subclass_name);

  // .calmcar.perception.Rect bbox = 4;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 4;
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // int64 sync_id = 1;
  void clear_sync_id();
  static const int kSyncIdFieldNumber = 1;
  ::google::protobuf::int64 sync_id() const;
  void set_sync_id(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 3;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 3;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // int32 id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 age = 6;
  void clear_age();
  static const int kAgeFieldNumber = 6;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // int32 object_class = 7;
  void clear_object_class();
  static const int kObjectClassFieldNumber = 7;
  ::google::protobuf::int32 object_class() const;
  void set_object_class(::google::protobuf::int32 value);

  // int32 object_subclass = 9;
  void clear_object_subclass();
  static const int kObjectSubclassFieldNumber = 9;
  ::google::protobuf::int32 object_subclass() const;
  void set_object_subclass(::google::protobuf::int32 value);

  // float confidence = 11;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 11;
  float confidence() const;
  void set_confidence(float value);

  // float lat_distance = 12;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 12;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float lat_distance_std = 13;
  void clear_lat_distance_std();
  static const int kLatDistanceStdFieldNumber = 13;
  float lat_distance_std() const;
  void set_lat_distance_std(float value);

  // float long_distance = 14;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 14;
  float long_distance() const;
  void set_long_distance(float value);

  // float long_distance_std = 15;
  void clear_long_distance_std();
  static const int kLongDistanceStdFieldNumber = 15;
  float long_distance_std() const;
  void set_long_distance_std(float value);

  // float width = 16;
  void clear_width();
  static const int kWidthFieldNumber = 16;
  float width() const;
  void set_width(float value);

  // float length = 17;
  void clear_length();
  static const int kLengthFieldNumber = 17;
  float length() const;
  void set_length(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.RoadMark)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_class_name_;
  ::google::protobuf::internal::ArenaStringPtr object_subclass_name_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::int64 sync_id_;
  ::google::protobuf::int64 timestamp_;
  int camera_position_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 age_;
  ::google::protobuf::int32 object_class_;
  ::google::protobuf::int32 object_subclass_;
  float confidence_;
  float lat_distance_;
  float lat_distance_std_;
  float long_distance_;
  float long_distance_std_;
  float width_;
  float length_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsRoadMarkImpl();
};
// -------------------------------------------------------------------

class FreeSpaceImagePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.FreeSpaceImagePoint) */ {
 public:
  FreeSpaceImagePoint();
  virtual ~FreeSpaceImagePoint();

  FreeSpaceImagePoint(const FreeSpaceImagePoint& from);

  inline FreeSpaceImagePoint& operator=(const FreeSpaceImagePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeSpaceImagePoint(FreeSpaceImagePoint&& from) noexcept
    : FreeSpaceImagePoint() {
    *this = ::std::move(from);
  }

  inline FreeSpaceImagePoint& operator=(FreeSpaceImagePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpaceImagePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeSpaceImagePoint* internal_default_instance() {
    return reinterpret_cast<const FreeSpaceImagePoint*>(
               &_FreeSpaceImagePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(FreeSpaceImagePoint* other);
  friend void swap(FreeSpaceImagePoint& a, FreeSpaceImagePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeSpaceImagePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  FreeSpaceImagePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FreeSpaceImagePoint& from);
  void MergeFrom(const FreeSpaceImagePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FreeSpaceImagePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.Point2i image_point = 3;
  bool has_image_point() const;
  void clear_image_point();
  static const int kImagePointFieldNumber = 3;
  const ::calmcar::perception::Point2i& image_point() const;
  ::calmcar::perception::Point2i* release_image_point();
  ::calmcar::perception::Point2i* mutable_image_point();
  void set_allocated_image_point(::calmcar::perception::Point2i* image_point);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // .calmcar.perception.FSPType classification_type = 2;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 2;
  ::calmcar::perception::FSPType classification_type() const;
  void set_classification_type(::calmcar::perception::FSPType value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.FreeSpaceImagePoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar::perception::Point2i* image_point_;
  int camera_position_;
  int classification_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsFreeSpaceImagePointImpl();
};
// -------------------------------------------------------------------

class FreeSpacePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.FreeSpacePoint) */ {
 public:
  FreeSpacePoint();
  virtual ~FreeSpacePoint();

  FreeSpacePoint(const FreeSpacePoint& from);

  inline FreeSpacePoint& operator=(const FreeSpacePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeSpacePoint(FreeSpacePoint&& from) noexcept
    : FreeSpacePoint() {
    *this = ::std::move(from);
  }

  inline FreeSpacePoint& operator=(FreeSpacePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpacePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeSpacePoint* internal_default_instance() {
    return reinterpret_cast<const FreeSpacePoint*>(
               &_FreeSpacePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FreeSpacePoint* other);
  friend void swap(FreeSpacePoint& a, FreeSpacePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeSpacePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  FreeSpacePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FreeSpacePoint& from);
  void MergeFrom(const FreeSpacePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FreeSpacePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // .calmcar.perception.FSPType classification_type = 2;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 2;
  ::calmcar::perception::FSPType classification_type() const;
  void set_classification_type(::calmcar::perception::FSPType value);

  // float exist_probability = 3;
  void clear_exist_probability();
  static const int kExistProbabilityFieldNumber = 3;
  float exist_probability() const;
  void set_exist_probability(float value);

  // float azimuth_angle = 4;
  void clear_azimuth_angle();
  static const int kAzimuthAngleFieldNumber = 4;
  float azimuth_angle() const;
  void set_azimuth_angle(float value);

  // float range = 5;
  void clear_range();
  static const int kRangeFieldNumber = 5;
  float range() const;
  void set_range(float value);

  // float range_std = 6;
  void clear_range_std();
  static const int kRangeStdFieldNumber = 6;
  float range_std() const;
  void set_range_std(float value);

  // int64 timestamp = 8;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 id = 7;
  void clear_id();
  static const int kIdFieldNumber = 7;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // bool is_valid = 9;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 9;
  bool is_valid() const;
  void set_is_valid(bool value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.FreeSpacePoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int camera_position_;
  int classification_type_;
  float exist_probability_;
  float azimuth_angle_;
  float range_;
  float range_std_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 id_;
  bool is_valid_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsFreeSpacePointImpl();
};
// -------------------------------------------------------------------

class FreeSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.FreeSpace) */ {
 public:
  FreeSpace();
  virtual ~FreeSpace();

  FreeSpace(const FreeSpace& from);

  inline FreeSpace& operator=(const FreeSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeSpace(FreeSpace&& from) noexcept
    : FreeSpace() {
    *this = ::std::move(from);
  }

  inline FreeSpace& operator=(FreeSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeSpace* internal_default_instance() {
    return reinterpret_cast<const FreeSpace*>(
               &_FreeSpace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FreeSpace* other);
  friend void swap(FreeSpace& a, FreeSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeSpace* New() const PROTOBUF_FINAL { return New(NULL); }

  FreeSpace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FreeSpace& from);
  void MergeFrom(const FreeSpace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FreeSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.FreeSpaceImagePoint image_points = 2;
  int image_points_size() const;
  void clear_image_points();
  static const int kImagePointsFieldNumber = 2;
  const ::calmcar::perception::FreeSpaceImagePoint& image_points(int index) const;
  ::calmcar::perception::FreeSpaceImagePoint* mutable_image_points(int index);
  ::calmcar::perception::FreeSpaceImagePoint* add_image_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpaceImagePoint >*
      mutable_image_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpaceImagePoint >&
      image_points() const;

  // repeated .calmcar.perception.FreeSpacePoint freespace_points = 3;
  int freespace_points_size() const;
  void clear_freespace_points();
  static const int kFreespacePointsFieldNumber = 3;
  const ::calmcar::perception::FreeSpacePoint& freespace_points(int index) const;
  ::calmcar::perception::FreeSpacePoint* mutable_freespace_points(int index);
  ::calmcar::perception::FreeSpacePoint* add_freespace_points();
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpacePoint >*
      mutable_freespace_points();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpacePoint >&
      freespace_points() const;

  // int64 sync_id = 1;
  void clear_sync_id();
  static const int kSyncIdFieldNumber = 1;
  ::google::protobuf::int64 sync_id() const;
  void set_sync_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.FreeSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpaceImagePoint > image_points_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpacePoint > freespace_points_;
  ::google::protobuf::int64 sync_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5froad_2eproto::TableStruct;
  friend void ::protobuf_perception_5froad_2eproto::InitDefaultsFreeSpaceImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneHost

// int64 timestamp = 1;
inline void LaneHost::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneHost::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.timestamp)
  return timestamp_;
}
inline void LaneHost::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.timestamp)
}

// int32 track_id = 2;
inline void LaneHost::clear_track_id() {
  track_id_ = 0;
}
inline ::google::protobuf::int32 LaneHost::track_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.track_id)
  return track_id_;
}
inline void LaneHost::set_track_id(::google::protobuf::int32 value) {
  
  track_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.track_id)
}

// int32 age = 3;
inline void LaneHost::clear_age() {
  age_ = 0;
}
inline ::google::protobuf::int32 LaneHost::age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.age)
  return age_;
}
inline void LaneHost::set_age(::google::protobuf::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.age)
}

// float exist_probability = 4;
inline void LaneHost::clear_exist_probability() {
  exist_probability_ = 0;
}
inline float LaneHost::exist_probability() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.exist_probability)
  return exist_probability_;
}
inline void LaneHost::set_exist_probability(float value) {
  
  exist_probability_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.exist_probability)
}

// .calmcar.perception.LineQuality quality = 5;
inline void LaneHost::clear_quality() {
  quality_ = 0;
}
inline ::calmcar::perception::LineQuality LaneHost::quality() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.quality)
  return static_cast< ::calmcar::perception::LineQuality >(quality_);
}
inline void LaneHost::set_quality(::calmcar::perception::LineQuality value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.quality)
}

// int64 prediction_source = 6;
inline void LaneHost::clear_prediction_source() {
  prediction_source_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneHost::prediction_source() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.prediction_source)
  return prediction_source_;
}
inline void LaneHost::set_prediction_source(::google::protobuf::int64 value) {
  
  prediction_source_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.prediction_source)
}

// int64 prediction_type = 7;
inline void LaneHost::clear_prediction_type() {
  prediction_type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneHost::prediction_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.prediction_type)
  return prediction_type_;
}
inline void LaneHost::set_prediction_type(::google::protobuf::int64 value) {
  
  prediction_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.prediction_type)
}

// .calmcar.perception.LineColor color = 8;
inline void LaneHost::clear_color() {
  color_ = 0;
}
inline ::calmcar::perception::LineColor LaneHost::color() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.color)
  return static_cast< ::calmcar::perception::LineColor >(color_);
}
inline void LaneHost::set_color(::calmcar::perception::LineColor value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.color)
}

// float color_confidence = 9;
inline void LaneHost::clear_color_confidence() {
  color_confidence_ = 0;
}
inline float LaneHost::color_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.color_confidence)
  return color_confidence_;
}
inline void LaneHost::set_color_confidence(float value) {
  
  color_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.color_confidence)
}

// .calmcar.perception.LanemarkType lanemark_type = 10;
inline void LaneHost::clear_lanemark_type() {
  lanemark_type_ = 0;
}
inline ::calmcar::perception::LanemarkType LaneHost::lanemark_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.lanemark_type)
  return static_cast< ::calmcar::perception::LanemarkType >(lanemark_type_);
}
inline void LaneHost::set_lanemark_type(::calmcar::perception::LanemarkType value) {
  
  lanemark_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.lanemark_type)
}

// float lanemark_type_confidence = 11;
inline void LaneHost::clear_lanemark_type_confidence() {
  lanemark_type_confidence_ = 0;
}
inline float LaneHost::lanemark_type_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.lanemark_type_confidence)
  return lanemark_type_confidence_;
}
inline void LaneHost::set_lanemark_type_confidence(float value) {
  
  lanemark_type_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.lanemark_type_confidence)
}

// .calmcar.perception.DlmType dlm_type = 12;
inline void LaneHost::clear_dlm_type() {
  dlm_type_ = 0;
}
inline ::calmcar::perception::DlmType LaneHost::dlm_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.dlm_type)
  return static_cast< ::calmcar::perception::DlmType >(dlm_type_);
}
inline void LaneHost::set_dlm_type(::calmcar::perception::DlmType value) {
  
  dlm_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.dlm_type)
}

// .calmcar.perception.DecelType decel_type = 13;
inline void LaneHost::clear_decel_type() {
  decel_type_ = 0;
}
inline ::calmcar::perception::DecelType LaneHost::decel_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.decel_type)
  return static_cast< ::calmcar::perception::DecelType >(decel_type_);
}
inline void LaneHost::set_decel_type(::calmcar::perception::DecelType value) {
  
  decel_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.decel_type)
}

// .calmcar.perception.LineSide side = 14;
inline void LaneHost::clear_side() {
  side_ = 0;
}
inline ::calmcar::perception::LineSide LaneHost::side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.side)
  return static_cast< ::calmcar::perception::LineSide >(side_);
}
inline void LaneHost::set_side(::calmcar::perception::LineSide value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.side)
}

// bool crossing = 15;
inline void LaneHost::clear_crossing() {
  crossing_ = false;
}
inline bool LaneHost::crossing() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.crossing)
  return crossing_;
}
inline void LaneHost::set_crossing(bool value) {
  
  crossing_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.crossing)
}

// float marker_width = 16;
inline void LaneHost::clear_marker_width() {
  marker_width_ = 0;
}
inline float LaneHost::marker_width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.marker_width)
  return marker_width_;
}
inline void LaneHost::set_marker_width(float value) {
  
  marker_width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.marker_width)
}

// float marker_width_std = 17;
inline void LaneHost::clear_marker_width_std() {
  marker_width_std_ = 0;
}
inline float LaneHost::marker_width_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.marker_width_std)
  return marker_width_std_;
}
inline void LaneHost::set_marker_width_std(float value) {
  
  marker_width_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.marker_width_std)
}

// float dash_average_length = 18;
inline void LaneHost::clear_dash_average_length() {
  dash_average_length_ = 0;
}
inline float LaneHost::dash_average_length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.dash_average_length)
  return dash_average_length_;
}
inline void LaneHost::set_dash_average_length(float value) {
  
  dash_average_length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.dash_average_length)
}

// float dash_average_gap = 19;
inline void LaneHost::clear_dash_average_gap() {
  dash_average_gap_ = 0;
}
inline float LaneHost::dash_average_gap() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.dash_average_gap)
  return dash_average_gap_;
}
inline void LaneHost::set_dash_average_gap(float value) {
  
  dash_average_gap_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.dash_average_gap)
}

// bool is_multi_clothoid = 20;
inline void LaneHost::clear_is_multi_clothoid() {
  is_multi_clothoid_ = false;
}
inline bool LaneHost::is_multi_clothoid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.is_multi_clothoid)
  return is_multi_clothoid_;
}
inline void LaneHost::set_is_multi_clothoid(bool value) {
  
  is_multi_clothoid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.is_multi_clothoid)
}

// float first_line_c3 = 21;
inline void LaneHost::clear_first_line_c3() {
  first_line_c3_ = 0;
}
inline float LaneHost::first_line_c3() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_line_c3)
  return first_line_c3_;
}
inline void LaneHost::set_first_line_c3(float value) {
  
  first_line_c3_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_line_c3)
}

// float first_line_c2 = 22;
inline void LaneHost::clear_first_line_c2() {
  first_line_c2_ = 0;
}
inline float LaneHost::first_line_c2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_line_c2)
  return first_line_c2_;
}
inline void LaneHost::set_first_line_c2(float value) {
  
  first_line_c2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_line_c2)
}

// float first_line_c1 = 23;
inline void LaneHost::clear_first_line_c1() {
  first_line_c1_ = 0;
}
inline float LaneHost::first_line_c1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_line_c1)
  return first_line_c1_;
}
inline void LaneHost::set_first_line_c1(float value) {
  
  first_line_c1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_line_c1)
}

// float first_line_c0 = 24;
inline void LaneHost::clear_first_line_c0() {
  first_line_c0_ = 0;
}
inline float LaneHost::first_line_c0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_line_c0)
  return first_line_c0_;
}
inline void LaneHost::set_first_line_c0(float value) {
  
  first_line_c0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_line_c0)
}

// float first_view_range_start = 25;
inline void LaneHost::clear_first_view_range_start() {
  first_view_range_start_ = 0;
}
inline float LaneHost::first_view_range_start() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_view_range_start)
  return first_view_range_start_;
}
inline void LaneHost::set_first_view_range_start(float value) {
  
  first_view_range_start_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_view_range_start)
}

// float first_view_range_end = 26;
inline void LaneHost::clear_first_view_range_end() {
  first_view_range_end_ = 0;
}
inline float LaneHost::first_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_view_range_end)
  return first_view_range_end_;
}
inline void LaneHost::set_first_view_range_end(float value) {
  
  first_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_view_range_end)
}

// float first_measured_view_range_end = 27;
inline void LaneHost::clear_first_measured_view_range_end() {
  first_measured_view_range_end_ = 0;
}
inline float LaneHost::first_measured_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.first_measured_view_range_end)
  return first_measured_view_range_end_;
}
inline void LaneHost::set_first_measured_view_range_end(float value) {
  
  first_measured_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.first_measured_view_range_end)
}

// float second_line_c3 = 28;
inline void LaneHost::clear_second_line_c3() {
  second_line_c3_ = 0;
}
inline float LaneHost::second_line_c3() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_line_c3)
  return second_line_c3_;
}
inline void LaneHost::set_second_line_c3(float value) {
  
  second_line_c3_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_line_c3)
}

// float second_line_c2 = 29;
inline void LaneHost::clear_second_line_c2() {
  second_line_c2_ = 0;
}
inline float LaneHost::second_line_c2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_line_c2)
  return second_line_c2_;
}
inline void LaneHost::set_second_line_c2(float value) {
  
  second_line_c2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_line_c2)
}

// float second_line_c1 = 30;
inline void LaneHost::clear_second_line_c1() {
  second_line_c1_ = 0;
}
inline float LaneHost::second_line_c1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_line_c1)
  return second_line_c1_;
}
inline void LaneHost::set_second_line_c1(float value) {
  
  second_line_c1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_line_c1)
}

// float second_line_c0 = 31;
inline void LaneHost::clear_second_line_c0() {
  second_line_c0_ = 0;
}
inline float LaneHost::second_line_c0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_line_c0)
  return second_line_c0_;
}
inline void LaneHost::set_second_line_c0(float value) {
  
  second_line_c0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_line_c0)
}

// float second_view_range_start = 32;
inline void LaneHost::clear_second_view_range_start() {
  second_view_range_start_ = 0;
}
inline float LaneHost::second_view_range_start() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_view_range_start)
  return second_view_range_start_;
}
inline void LaneHost::set_second_view_range_start(float value) {
  
  second_view_range_start_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_view_range_start)
}

// float second_view_range_end = 33;
inline void LaneHost::clear_second_view_range_end() {
  second_view_range_end_ = 0;
}
inline float LaneHost::second_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_view_range_end)
  return second_view_range_end_;
}
inline void LaneHost::set_second_view_range_end(float value) {
  
  second_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_view_range_end)
}

// float second_measured_view_range_end = 34;
inline void LaneHost::clear_second_measured_view_range_end() {
  second_measured_view_range_end_ = 0;
}
inline float LaneHost::second_measured_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.second_measured_view_range_end)
  return second_measured_view_range_end_;
}
inline void LaneHost::set_second_measured_view_range_end(float value) {
  
  second_measured_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.second_measured_view_range_end)
}

// .calmcar.perception.CameraInfo.Position camera_position = 35;
inline void LaneHost::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position LaneHost::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void LaneHost::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.camera_position)
}

// bool is_valid = 36;
inline void LaneHost::clear_is_valid() {
  is_valid_ = false;
}
inline bool LaneHost::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.is_valid)
  return is_valid_;
}
inline void LaneHost::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.is_valid)
}

// repeated .calmcar.perception.Point2i image_points = 37;
inline int LaneHost::image_points_size() const {
  return image_points_.size();
}
inline const ::calmcar::perception::Point2i& LaneHost::image_points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.image_points)
  return image_points_.Get(index);
}
inline ::calmcar::perception::Point2i* LaneHost::mutable_image_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LaneHost.image_points)
  return image_points_.Mutable(index);
}
inline ::calmcar::perception::Point2i* LaneHost::add_image_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.LaneHost.image_points)
  return image_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
LaneHost::mutable_image_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.LaneHost.image_points)
  return &image_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
LaneHost::image_points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.LaneHost.image_points)
  return image_points_;
}

// bool availability_state = 38;
inline void LaneHost::clear_availability_state() {
  availability_state_ = false;
}
inline bool LaneHost::availability_state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneHost.availability_state)
  return availability_state_;
}
inline void LaneHost::set_availability_state(bool value) {
  
  availability_state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneHost.availability_state)
}

// -------------------------------------------------------------------

// LaneAdjacent

// int32 track_id = 1;
inline void LaneAdjacent::clear_track_id() {
  track_id_ = 0;
}
inline ::google::protobuf::int32 LaneAdjacent::track_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.track_id)
  return track_id_;
}
inline void LaneAdjacent::set_track_id(::google::protobuf::int32 value) {
  
  track_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.track_id)
}

// int32 age = 2;
inline void LaneAdjacent::clear_age() {
  age_ = 0;
}
inline ::google::protobuf::int32 LaneAdjacent::age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.age)
  return age_;
}
inline void LaneAdjacent::set_age(::google::protobuf::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.age)
}

// float exist_probability = 3;
inline void LaneAdjacent::clear_exist_probability() {
  exist_probability_ = 0;
}
inline float LaneAdjacent::exist_probability() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.exist_probability)
  return exist_probability_;
}
inline void LaneAdjacent::set_exist_probability(float value) {
  
  exist_probability_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.exist_probability)
}

// .calmcar.perception.LineQuality quality = 4;
inline void LaneAdjacent::clear_quality() {
  quality_ = 0;
}
inline ::calmcar::perception::LineQuality LaneAdjacent::quality() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.quality)
  return static_cast< ::calmcar::perception::LineQuality >(quality_);
}
inline void LaneAdjacent::set_quality(::calmcar::perception::LineQuality value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.quality)
}

// int64 prediction_source = 5;
inline void LaneAdjacent::clear_prediction_source() {
  prediction_source_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneAdjacent::prediction_source() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.prediction_source)
  return prediction_source_;
}
inline void LaneAdjacent::set_prediction_source(::google::protobuf::int64 value) {
  
  prediction_source_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.prediction_source)
}

// int64 prediction_type = 6;
inline void LaneAdjacent::clear_prediction_type() {
  prediction_type_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneAdjacent::prediction_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.prediction_type)
  return prediction_type_;
}
inline void LaneAdjacent::set_prediction_type(::google::protobuf::int64 value) {
  
  prediction_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.prediction_type)
}

// .calmcar.perception.LineColor color = 7;
inline void LaneAdjacent::clear_color() {
  color_ = 0;
}
inline ::calmcar::perception::LineColor LaneAdjacent::color() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.color)
  return static_cast< ::calmcar::perception::LineColor >(color_);
}
inline void LaneAdjacent::set_color(::calmcar::perception::LineColor value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.color)
}

// float color_confidence = 8;
inline void LaneAdjacent::clear_color_confidence() {
  color_confidence_ = 0;
}
inline float LaneAdjacent::color_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.color_confidence)
  return color_confidence_;
}
inline void LaneAdjacent::set_color_confidence(float value) {
  
  color_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.color_confidence)
}

// .calmcar.perception.LanemarkType lanemark_type = 9;
inline void LaneAdjacent::clear_lanemark_type() {
  lanemark_type_ = 0;
}
inline ::calmcar::perception::LanemarkType LaneAdjacent::lanemark_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.lanemark_type)
  return static_cast< ::calmcar::perception::LanemarkType >(lanemark_type_);
}
inline void LaneAdjacent::set_lanemark_type(::calmcar::perception::LanemarkType value) {
  
  lanemark_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.lanemark_type)
}

// float lanemark_type_confidence = 10;
inline void LaneAdjacent::clear_lanemark_type_confidence() {
  lanemark_type_confidence_ = 0;
}
inline float LaneAdjacent::lanemark_type_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.lanemark_type_confidence)
  return lanemark_type_confidence_;
}
inline void LaneAdjacent::set_lanemark_type_confidence(float value) {
  
  lanemark_type_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.lanemark_type_confidence)
}

// .calmcar.perception.DlmType dlm_type = 11;
inline void LaneAdjacent::clear_dlm_type() {
  dlm_type_ = 0;
}
inline ::calmcar::perception::DlmType LaneAdjacent::dlm_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.dlm_type)
  return static_cast< ::calmcar::perception::DlmType >(dlm_type_);
}
inline void LaneAdjacent::set_dlm_type(::calmcar::perception::DlmType value) {
  
  dlm_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.dlm_type)
}

// .calmcar.perception.LineRole role = 12;
inline void LaneAdjacent::clear_role() {
  role_ = 0;
}
inline ::calmcar::perception::LineRole LaneAdjacent::role() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.role)
  return static_cast< ::calmcar::perception::LineRole >(role_);
}
inline void LaneAdjacent::set_role(::calmcar::perception::LineRole value) {
  
  role_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.role)
}

// float marker_width = 13;
inline void LaneAdjacent::clear_marker_width() {
  marker_width_ = 0;
}
inline float LaneAdjacent::marker_width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.marker_width)
  return marker_width_;
}
inline void LaneAdjacent::set_marker_width(float value) {
  
  marker_width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.marker_width)
}

// float marker_width_std = 14;
inline void LaneAdjacent::clear_marker_width_std() {
  marker_width_std_ = 0;
}
inline float LaneAdjacent::marker_width_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.marker_width_std)
  return marker_width_std_;
}
inline void LaneAdjacent::set_marker_width_std(float value) {
  
  marker_width_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.marker_width_std)
}

// float line_c3 = 15;
inline void LaneAdjacent::clear_line_c3() {
  line_c3_ = 0;
}
inline float LaneAdjacent::line_c3() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.line_c3)
  return line_c3_;
}
inline void LaneAdjacent::set_line_c3(float value) {
  
  line_c3_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.line_c3)
}

// float line_c2 = 16;
inline void LaneAdjacent::clear_line_c2() {
  line_c2_ = 0;
}
inline float LaneAdjacent::line_c2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.line_c2)
  return line_c2_;
}
inline void LaneAdjacent::set_line_c2(float value) {
  
  line_c2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.line_c2)
}

// float line_c1 = 17;
inline void LaneAdjacent::clear_line_c1() {
  line_c1_ = 0;
}
inline float LaneAdjacent::line_c1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.line_c1)
  return line_c1_;
}
inline void LaneAdjacent::set_line_c1(float value) {
  
  line_c1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.line_c1)
}

// float line_c0 = 18;
inline void LaneAdjacent::clear_line_c0() {
  line_c0_ = 0;
}
inline float LaneAdjacent::line_c0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.line_c0)
  return line_c0_;
}
inline void LaneAdjacent::set_line_c0(float value) {
  
  line_c0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.line_c0)
}

// float view_range_start = 19;
inline void LaneAdjacent::clear_view_range_start() {
  view_range_start_ = 0;
}
inline float LaneAdjacent::view_range_start() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.view_range_start)
  return view_range_start_;
}
inline void LaneAdjacent::set_view_range_start(float value) {
  
  view_range_start_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.view_range_start)
}

// float view_range_end = 20;
inline void LaneAdjacent::clear_view_range_end() {
  view_range_end_ = 0;
}
inline float LaneAdjacent::view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.view_range_end)
  return view_range_end_;
}
inline void LaneAdjacent::set_view_range_end(float value) {
  
  view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.view_range_end)
}

// float measured_view_range_end = 21;
inline void LaneAdjacent::clear_measured_view_range_end() {
  measured_view_range_end_ = 0;
}
inline float LaneAdjacent::measured_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.measured_view_range_end)
  return measured_view_range_end_;
}
inline void LaneAdjacent::set_measured_view_range_end(float value) {
  
  measured_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.measured_view_range_end)
}

// int64 timestamp = 22;
inline void LaneAdjacent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneAdjacent::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.timestamp)
  return timestamp_;
}
inline void LaneAdjacent::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.timestamp)
}

// .calmcar.perception.CameraInfo.Position camera_position = 23;
inline void LaneAdjacent::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position LaneAdjacent::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void LaneAdjacent::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.camera_position)
}

// bool is_valid = 24;
inline void LaneAdjacent::clear_is_valid() {
  is_valid_ = false;
}
inline bool LaneAdjacent::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.is_valid)
  return is_valid_;
}
inline void LaneAdjacent::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.is_valid)
}

// repeated .calmcar.perception.Point2i image_points = 25;
inline int LaneAdjacent::image_points_size() const {
  return image_points_.size();
}
inline const ::calmcar::perception::Point2i& LaneAdjacent::image_points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.image_points)
  return image_points_.Get(index);
}
inline ::calmcar::perception::Point2i* LaneAdjacent::mutable_image_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LaneAdjacent.image_points)
  return image_points_.Mutable(index);
}
inline ::calmcar::perception::Point2i* LaneAdjacent::add_image_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.LaneAdjacent.image_points)
  return image_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
LaneAdjacent::mutable_image_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.LaneAdjacent.image_points)
  return &image_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
LaneAdjacent::image_points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.LaneAdjacent.image_points)
  return image_points_;
}

// bool availability_state = 26;
inline void LaneAdjacent::clear_availability_state() {
  availability_state_ = false;
}
inline bool LaneAdjacent::availability_state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneAdjacent.availability_state)
  return availability_state_;
}
inline void LaneAdjacent::set_availability_state(bool value) {
  
  availability_state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneAdjacent.availability_state)
}

// -------------------------------------------------------------------

// LaneRoadedge

// int32 id = 1;
inline void LaneRoadedge::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 LaneRoadedge::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.id)
  return id_;
}
inline void LaneRoadedge::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.id)
}

// int32 age = 2;
inline void LaneRoadedge::clear_age() {
  age_ = 0;
}
inline ::google::protobuf::int32 LaneRoadedge::age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.age)
  return age_;
}
inline void LaneRoadedge::set_age(::google::protobuf::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.age)
}

// float exist_probability = 3;
inline void LaneRoadedge::clear_exist_probability() {
  exist_probability_ = 0;
}
inline float LaneRoadedge::exist_probability() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.exist_probability)
  return exist_probability_;
}
inline void LaneRoadedge::set_exist_probability(float value) {
  
  exist_probability_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.exist_probability)
}

// .calmcar.perception.LreType type = 4;
inline void LaneRoadedge::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::LreType LaneRoadedge::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.type)
  return static_cast< ::calmcar::perception::LreType >(type_);
}
inline void LaneRoadedge::set_type(::calmcar::perception::LreType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.type)
}

// int32 prediction_type = 5;
inline void LaneRoadedge::clear_prediction_type() {
  prediction_type_ = 0;
}
inline ::google::protobuf::int32 LaneRoadedge::prediction_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.prediction_type)
  return prediction_type_;
}
inline void LaneRoadedge::set_prediction_type(::google::protobuf::int32 value) {
  
  prediction_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.prediction_type)
}

// .calmcar.perception.LineSide side = 6;
inline void LaneRoadedge::clear_side() {
  side_ = 0;
}
inline ::calmcar::perception::LineSide LaneRoadedge::side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.side)
  return static_cast< ::calmcar::perception::LineSide >(side_);
}
inline void LaneRoadedge::set_side(::calmcar::perception::LineSide value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.side)
}

// .calmcar.perception.LreIndex index = 7;
inline void LaneRoadedge::clear_index() {
  index_ = 0;
}
inline ::calmcar::perception::LreIndex LaneRoadedge::index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.index)
  return static_cast< ::calmcar::perception::LreIndex >(index_);
}
inline void LaneRoadedge::set_index(::calmcar::perception::LreIndex value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.index)
}

// float height = 8;
inline void LaneRoadedge::clear_height() {
  height_ = 0;
}
inline float LaneRoadedge::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.height)
  return height_;
}
inline void LaneRoadedge::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.height)
}

// float height_std = 9;
inline void LaneRoadedge::clear_height_std() {
  height_std_ = 0;
}
inline float LaneRoadedge::height_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.height_std)
  return height_std_;
}
inline void LaneRoadedge::set_height_std(float value) {
  
  height_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.height_std)
}

// float line_c3 = 10;
inline void LaneRoadedge::clear_line_c3() {
  line_c3_ = 0;
}
inline float LaneRoadedge::line_c3() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.line_c3)
  return line_c3_;
}
inline void LaneRoadedge::set_line_c3(float value) {
  
  line_c3_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.line_c3)
}

// float line_c1 = 11;
inline void LaneRoadedge::clear_line_c1() {
  line_c1_ = 0;
}
inline float LaneRoadedge::line_c1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.line_c1)
  return line_c1_;
}
inline void LaneRoadedge::set_line_c1(float value) {
  
  line_c1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.line_c1)
}

// float line_c2 = 12;
inline void LaneRoadedge::clear_line_c2() {
  line_c2_ = 0;
}
inline float LaneRoadedge::line_c2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.line_c2)
  return line_c2_;
}
inline void LaneRoadedge::set_line_c2(float value) {
  
  line_c2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.line_c2)
}

// float line_c0 = 13;
inline void LaneRoadedge::clear_line_c0() {
  line_c0_ = 0;
}
inline float LaneRoadedge::line_c0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.line_c0)
  return line_c0_;
}
inline void LaneRoadedge::set_line_c0(float value) {
  
  line_c0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.line_c0)
}

// float view_range_start = 14;
inline void LaneRoadedge::clear_view_range_start() {
  view_range_start_ = 0;
}
inline float LaneRoadedge::view_range_start() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.view_range_start)
  return view_range_start_;
}
inline void LaneRoadedge::set_view_range_start(float value) {
  
  view_range_start_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.view_range_start)
}

// float view_range_end = 15;
inline void LaneRoadedge::clear_view_range_end() {
  view_range_end_ = 0;
}
inline float LaneRoadedge::view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.view_range_end)
  return view_range_end_;
}
inline void LaneRoadedge::set_view_range_end(float value) {
  
  view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.view_range_end)
}

// float measured_view_range_end = 16;
inline void LaneRoadedge::clear_measured_view_range_end() {
  measured_view_range_end_ = 0;
}
inline float LaneRoadedge::measured_view_range_end() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.measured_view_range_end)
  return measured_view_range_end_;
}
inline void LaneRoadedge::set_measured_view_range_end(float value) {
  
  measured_view_range_end_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.measured_view_range_end)
}

// int64 timestamp = 17;
inline void LaneRoadedge::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneRoadedge::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.timestamp)
  return timestamp_;
}
inline void LaneRoadedge::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.timestamp)
}

// .calmcar.perception.CameraInfo.Position camera_position = 18;
inline void LaneRoadedge::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position LaneRoadedge::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void LaneRoadedge::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.camera_position)
}

// bool is_valid = 19;
inline void LaneRoadedge::clear_is_valid() {
  is_valid_ = false;
}
inline bool LaneRoadedge::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.is_valid)
  return is_valid_;
}
inline void LaneRoadedge::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.is_valid)
}

// repeated .calmcar.perception.Point2i image_points = 20;
inline int LaneRoadedge::image_points_size() const {
  return image_points_.size();
}
inline const ::calmcar::perception::Point2i& LaneRoadedge::image_points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.image_points)
  return image_points_.Get(index);
}
inline ::calmcar::perception::Point2i* LaneRoadedge::mutable_image_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.LaneRoadedge.image_points)
  return image_points_.Mutable(index);
}
inline ::calmcar::perception::Point2i* LaneRoadedge::add_image_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.LaneRoadedge.image_points)
  return image_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >*
LaneRoadedge::mutable_image_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.LaneRoadedge.image_points)
  return &image_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Point2i >&
LaneRoadedge::image_points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.LaneRoadedge.image_points)
  return image_points_;
}

// bool availability_state = 21;
inline void LaneRoadedge::clear_availability_state() {
  availability_state_ = false;
}
inline bool LaneRoadedge::availability_state() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.LaneRoadedge.availability_state)
  return availability_state_;
}
inline void LaneRoadedge::set_availability_state(bool value) {
  
  availability_state_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.LaneRoadedge.availability_state)
}

// -------------------------------------------------------------------

// Lane

// int64 sync_id = 1;
inline void Lane::clear_sync_id() {
  sync_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::sync_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.sync_id)
  return sync_id_;
}
inline void Lane::set_sync_id(::google::protobuf::int64 value) {
  
  sync_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Lane.sync_id)
}

// float estimated_width = 2;
inline void Lane::clear_estimated_width() {
  estimated_width_ = 0;
}
inline float Lane::estimated_width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.estimated_width)
  return estimated_width_;
}
inline void Lane::set_estimated_width(float value) {
  
  estimated_width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Lane.estimated_width)
}

// int32 lane_host_count = 3;
inline void Lane::clear_lane_host_count() {
  lane_host_count_ = 0;
}
inline ::google::protobuf::int32 Lane::lane_host_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.lane_host_count)
  return lane_host_count_;
}
inline void Lane::set_lane_host_count(::google::protobuf::int32 value) {
  
  lane_host_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Lane.lane_host_count)
}

// repeated .calmcar.perception.LaneHost lane_host = 4;
inline int Lane::lane_host_size() const {
  return lane_host_.size();
}
inline void Lane::clear_lane_host() {
  lane_host_.Clear();
}
inline const ::calmcar::perception::LaneHost& Lane::lane_host(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.lane_host)
  return lane_host_.Get(index);
}
inline ::calmcar::perception::LaneHost* Lane::mutable_lane_host(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Lane.lane_host)
  return lane_host_.Mutable(index);
}
inline ::calmcar::perception::LaneHost* Lane::add_lane_host() {
  // @@protoc_insertion_point(field_add:calmcar.perception.Lane.lane_host)
  return lane_host_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneHost >*
Lane::mutable_lane_host() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.Lane.lane_host)
  return &lane_host_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneHost >&
Lane::lane_host() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.Lane.lane_host)
  return lane_host_;
}

// int32 lane_adjacent_count = 5;
inline void Lane::clear_lane_adjacent_count() {
  lane_adjacent_count_ = 0;
}
inline ::google::protobuf::int32 Lane::lane_adjacent_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.lane_adjacent_count)
  return lane_adjacent_count_;
}
inline void Lane::set_lane_adjacent_count(::google::protobuf::int32 value) {
  
  lane_adjacent_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Lane.lane_adjacent_count)
}

// repeated .calmcar.perception.LaneAdjacent lane_adjacent = 6;
inline int Lane::lane_adjacent_size() const {
  return lane_adjacent_.size();
}
inline void Lane::clear_lane_adjacent() {
  lane_adjacent_.Clear();
}
inline const ::calmcar::perception::LaneAdjacent& Lane::lane_adjacent(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.lane_adjacent)
  return lane_adjacent_.Get(index);
}
inline ::calmcar::perception::LaneAdjacent* Lane::mutable_lane_adjacent(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Lane.lane_adjacent)
  return lane_adjacent_.Mutable(index);
}
inline ::calmcar::perception::LaneAdjacent* Lane::add_lane_adjacent() {
  // @@protoc_insertion_point(field_add:calmcar.perception.Lane.lane_adjacent)
  return lane_adjacent_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneAdjacent >*
Lane::mutable_lane_adjacent() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.Lane.lane_adjacent)
  return &lane_adjacent_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneAdjacent >&
Lane::lane_adjacent() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.Lane.lane_adjacent)
  return lane_adjacent_;
}

// int32 road_edge_count = 7;
inline void Lane::clear_road_edge_count() {
  road_edge_count_ = 0;
}
inline ::google::protobuf::int32 Lane::road_edge_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.road_edge_count)
  return road_edge_count_;
}
inline void Lane::set_road_edge_count(::google::protobuf::int32 value) {
  
  road_edge_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Lane.road_edge_count)
}

// repeated .calmcar.perception.LaneRoadedge road_edge = 8;
inline int Lane::road_edge_size() const {
  return road_edge_.size();
}
inline void Lane::clear_road_edge() {
  road_edge_.Clear();
}
inline const ::calmcar::perception::LaneRoadedge& Lane::road_edge(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Lane.road_edge)
  return road_edge_.Get(index);
}
inline ::calmcar::perception::LaneRoadedge* Lane::mutable_road_edge(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Lane.road_edge)
  return road_edge_.Mutable(index);
}
inline ::calmcar::perception::LaneRoadedge* Lane::add_road_edge() {
  // @@protoc_insertion_point(field_add:calmcar.perception.Lane.road_edge)
  return road_edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneRoadedge >*
Lane::mutable_road_edge() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.Lane.road_edge)
  return &road_edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::LaneRoadedge >&
Lane::road_edge() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.Lane.road_edge)
  return road_edge_;
}

// -------------------------------------------------------------------

// RoadMark

// int64 sync_id = 1;
inline void RoadMark::clear_sync_id() {
  sync_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadMark::sync_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.sync_id)
  return sync_id_;
}
inline void RoadMark::set_sync_id(::google::protobuf::int64 value) {
  
  sync_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.sync_id)
}

// int64 timestamp = 2;
inline void RoadMark::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadMark::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.timestamp)
  return timestamp_;
}
inline void RoadMark::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.timestamp)
}

// .calmcar.perception.CameraInfo.Position camera_position = 3;
inline void RoadMark::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position RoadMark::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void RoadMark::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.camera_position)
}

// .calmcar.perception.Rect bbox = 4;
inline bool RoadMark::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& RoadMark::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* RoadMark::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.RoadMark.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* RoadMark::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::calmcar::perception::Rect;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.RoadMark.bbox)
  return bbox_;
}
inline void RoadMark::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.RoadMark.bbox)
}

// int32 id = 5;
inline void RoadMark::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 RoadMark::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.id)
  return id_;
}
inline void RoadMark::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.id)
}

// int32 age = 6;
inline void RoadMark::clear_age() {
  age_ = 0;
}
inline ::google::protobuf::int32 RoadMark::age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.age)
  return age_;
}
inline void RoadMark::set_age(::google::protobuf::int32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.age)
}

// int32 object_class = 7;
inline void RoadMark::clear_object_class() {
  object_class_ = 0;
}
inline ::google::protobuf::int32 RoadMark::object_class() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.object_class)
  return object_class_;
}
inline void RoadMark::set_object_class(::google::protobuf::int32 value) {
  
  object_class_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.object_class)
}

// string object_class_name = 8;
inline void RoadMark::clear_object_class_name() {
  object_class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadMark::object_class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.object_class_name)
  return object_class_name_.GetNoArena();
}
inline void RoadMark::set_object_class_name(const ::std::string& value) {
  
  object_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.object_class_name)
}
#if LANG_CXX11
inline void RoadMark::set_object_class_name(::std::string&& value) {
  
  object_class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.RoadMark.object_class_name)
}
#endif
inline void RoadMark::set_object_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  object_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.RoadMark.object_class_name)
}
inline void RoadMark::set_object_class_name(const char* value, size_t size) {
  
  object_class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.RoadMark.object_class_name)
}
inline ::std::string* RoadMark::mutable_object_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.RoadMark.object_class_name)
  return object_class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadMark::release_object_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.RoadMark.object_class_name)
  
  return object_class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadMark::set_allocated_object_class_name(::std::string* object_class_name) {
  if (object_class_name != NULL) {
    
  } else {
    
  }
  object_class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.RoadMark.object_class_name)
}

// int32 object_subclass = 9;
inline void RoadMark::clear_object_subclass() {
  object_subclass_ = 0;
}
inline ::google::protobuf::int32 RoadMark::object_subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.object_subclass)
  return object_subclass_;
}
inline void RoadMark::set_object_subclass(::google::protobuf::int32 value) {
  
  object_subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.object_subclass)
}

// string object_subclass_name = 10;
inline void RoadMark::clear_object_subclass_name() {
  object_subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadMark::object_subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.object_subclass_name)
  return object_subclass_name_.GetNoArena();
}
inline void RoadMark::set_object_subclass_name(const ::std::string& value) {
  
  object_subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.object_subclass_name)
}
#if LANG_CXX11
inline void RoadMark::set_object_subclass_name(::std::string&& value) {
  
  object_subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.RoadMark.object_subclass_name)
}
#endif
inline void RoadMark::set_object_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  object_subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.RoadMark.object_subclass_name)
}
inline void RoadMark::set_object_subclass_name(const char* value, size_t size) {
  
  object_subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.RoadMark.object_subclass_name)
}
inline ::std::string* RoadMark::mutable_object_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.RoadMark.object_subclass_name)
  return object_subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadMark::release_object_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.RoadMark.object_subclass_name)
  
  return object_subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadMark::set_allocated_object_subclass_name(::std::string* object_subclass_name) {
  if (object_subclass_name != NULL) {
    
  } else {
    
  }
  object_subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.RoadMark.object_subclass_name)
}

// float confidence = 11;
inline void RoadMark::clear_confidence() {
  confidence_ = 0;
}
inline float RoadMark::confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.confidence)
  return confidence_;
}
inline void RoadMark::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.confidence)
}

// float lat_distance = 12;
inline void RoadMark::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float RoadMark::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.lat_distance)
  return lat_distance_;
}
inline void RoadMark::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.lat_distance)
}

// float lat_distance_std = 13;
inline void RoadMark::clear_lat_distance_std() {
  lat_distance_std_ = 0;
}
inline float RoadMark::lat_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.lat_distance_std)
  return lat_distance_std_;
}
inline void RoadMark::set_lat_distance_std(float value) {
  
  lat_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.lat_distance_std)
}

// float long_distance = 14;
inline void RoadMark::clear_long_distance() {
  long_distance_ = 0;
}
inline float RoadMark::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.long_distance)
  return long_distance_;
}
inline void RoadMark::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.long_distance)
}

// float long_distance_std = 15;
inline void RoadMark::clear_long_distance_std() {
  long_distance_std_ = 0;
}
inline float RoadMark::long_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.long_distance_std)
  return long_distance_std_;
}
inline void RoadMark::set_long_distance_std(float value) {
  
  long_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.long_distance_std)
}

// float width = 16;
inline void RoadMark::clear_width() {
  width_ = 0;
}
inline float RoadMark::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.width)
  return width_;
}
inline void RoadMark::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.width)
}

// float length = 17;
inline void RoadMark::clear_length() {
  length_ = 0;
}
inline float RoadMark::length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.RoadMark.length)
  return length_;
}
inline void RoadMark::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.RoadMark.length)
}

// -------------------------------------------------------------------

// FreeSpaceImagePoint

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void FreeSpaceImagePoint::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position FreeSpaceImagePoint::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpaceImagePoint.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void FreeSpaceImagePoint::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpaceImagePoint.camera_position)
}

// .calmcar.perception.FSPType classification_type = 2;
inline void FreeSpaceImagePoint::clear_classification_type() {
  classification_type_ = 0;
}
inline ::calmcar::perception::FSPType FreeSpaceImagePoint::classification_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpaceImagePoint.classification_type)
  return static_cast< ::calmcar::perception::FSPType >(classification_type_);
}
inline void FreeSpaceImagePoint::set_classification_type(::calmcar::perception::FSPType value) {
  
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpaceImagePoint.classification_type)
}

// .calmcar.perception.Point2i image_point = 3;
inline bool FreeSpaceImagePoint::has_image_point() const {
  return this != internal_default_instance() && image_point_ != NULL;
}
inline const ::calmcar::perception::Point2i& FreeSpaceImagePoint::image_point() const {
  const ::calmcar::perception::Point2i* p = image_point_;
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpaceImagePoint.image_point)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Point2i*>(
      &::calmcar::perception::_Point2i_default_instance_);
}
inline ::calmcar::perception::Point2i* FreeSpaceImagePoint::release_image_point() {
  // @@protoc_insertion_point(field_release:calmcar.perception.FreeSpaceImagePoint.image_point)
  
  ::calmcar::perception::Point2i* temp = image_point_;
  image_point_ = NULL;
  return temp;
}
inline ::calmcar::perception::Point2i* FreeSpaceImagePoint::mutable_image_point() {
  
  if (image_point_ == NULL) {
    image_point_ = new ::calmcar::perception::Point2i;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.FreeSpaceImagePoint.image_point)
  return image_point_;
}
inline void FreeSpaceImagePoint::set_allocated_image_point(::calmcar::perception::Point2i* image_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(image_point_);
  }
  if (image_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image_point, submessage_arena);
    }
    
  } else {
    
  }
  image_point_ = image_point;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.FreeSpaceImagePoint.image_point)
}

// -------------------------------------------------------------------

// FreeSpacePoint

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void FreeSpacePoint::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position FreeSpacePoint::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void FreeSpacePoint::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.camera_position)
}

// .calmcar.perception.FSPType classification_type = 2;
inline void FreeSpacePoint::clear_classification_type() {
  classification_type_ = 0;
}
inline ::calmcar::perception::FSPType FreeSpacePoint::classification_type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.classification_type)
  return static_cast< ::calmcar::perception::FSPType >(classification_type_);
}
inline void FreeSpacePoint::set_classification_type(::calmcar::perception::FSPType value) {
  
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.classification_type)
}

// float exist_probability = 3;
inline void FreeSpacePoint::clear_exist_probability() {
  exist_probability_ = 0;
}
inline float FreeSpacePoint::exist_probability() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.exist_probability)
  return exist_probability_;
}
inline void FreeSpacePoint::set_exist_probability(float value) {
  
  exist_probability_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.exist_probability)
}

// float azimuth_angle = 4;
inline void FreeSpacePoint::clear_azimuth_angle() {
  azimuth_angle_ = 0;
}
inline float FreeSpacePoint::azimuth_angle() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.azimuth_angle)
  return azimuth_angle_;
}
inline void FreeSpacePoint::set_azimuth_angle(float value) {
  
  azimuth_angle_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.azimuth_angle)
}

// float range = 5;
inline void FreeSpacePoint::clear_range() {
  range_ = 0;
}
inline float FreeSpacePoint::range() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.range)
  return range_;
}
inline void FreeSpacePoint::set_range(float value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.range)
}

// float range_std = 6;
inline void FreeSpacePoint::clear_range_std() {
  range_std_ = 0;
}
inline float FreeSpacePoint::range_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.range_std)
  return range_std_;
}
inline void FreeSpacePoint::set_range_std(float value) {
  
  range_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.range_std)
}

// int32 id = 7;
inline void FreeSpacePoint::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 FreeSpacePoint::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.id)
  return id_;
}
inline void FreeSpacePoint::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.id)
}

// int64 timestamp = 8;
inline void FreeSpacePoint::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FreeSpacePoint::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.timestamp)
  return timestamp_;
}
inline void FreeSpacePoint::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.timestamp)
}

// bool is_valid = 9;
inline void FreeSpacePoint::clear_is_valid() {
  is_valid_ = false;
}
inline bool FreeSpacePoint::is_valid() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpacePoint.is_valid)
  return is_valid_;
}
inline void FreeSpacePoint::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpacePoint.is_valid)
}

// -------------------------------------------------------------------

// FreeSpace

// int64 sync_id = 1;
inline void FreeSpace::clear_sync_id() {
  sync_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FreeSpace::sync_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpace.sync_id)
  return sync_id_;
}
inline void FreeSpace::set_sync_id(::google::protobuf::int64 value) {
  
  sync_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.FreeSpace.sync_id)
}

// repeated .calmcar.perception.FreeSpaceImagePoint image_points = 2;
inline int FreeSpace::image_points_size() const {
  return image_points_.size();
}
inline void FreeSpace::clear_image_points() {
  image_points_.Clear();
}
inline const ::calmcar::perception::FreeSpaceImagePoint& FreeSpace::image_points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpace.image_points)
  return image_points_.Get(index);
}
inline ::calmcar::perception::FreeSpaceImagePoint* FreeSpace::mutable_image_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.FreeSpace.image_points)
  return image_points_.Mutable(index);
}
inline ::calmcar::perception::FreeSpaceImagePoint* FreeSpace::add_image_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.FreeSpace.image_points)
  return image_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpaceImagePoint >*
FreeSpace::mutable_image_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.FreeSpace.image_points)
  return &image_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpaceImagePoint >&
FreeSpace::image_points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.FreeSpace.image_points)
  return image_points_;
}

// repeated .calmcar.perception.FreeSpacePoint freespace_points = 3;
inline int FreeSpace::freespace_points_size() const {
  return freespace_points_.size();
}
inline void FreeSpace::clear_freespace_points() {
  freespace_points_.Clear();
}
inline const ::calmcar::perception::FreeSpacePoint& FreeSpace::freespace_points(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.FreeSpace.freespace_points)
  return freespace_points_.Get(index);
}
inline ::calmcar::perception::FreeSpacePoint* FreeSpace::mutable_freespace_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.FreeSpace.freespace_points)
  return freespace_points_.Mutable(index);
}
inline ::calmcar::perception::FreeSpacePoint* FreeSpace::add_freespace_points() {
  // @@protoc_insertion_point(field_add:calmcar.perception.FreeSpace.freespace_points)
  return freespace_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpacePoint >*
FreeSpace::mutable_freespace_points() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.FreeSpace.freespace_points)
  return &freespace_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::FreeSpacePoint >&
FreeSpace::freespace_points() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.FreeSpace.freespace_points)
  return freespace_points_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace calmcar

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmcar::perception::LineColor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LineColor>() {
  return ::calmcar::perception::LineColor_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LineQuality> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LineQuality>() {
  return ::calmcar::perception::LineQuality_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LanemarkType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LanemarkType>() {
  return ::calmcar::perception::LanemarkType_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LreType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LreType>() {
  return ::calmcar::perception::LreType_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::DlmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::DlmType>() {
  return ::calmcar::perception::DlmType_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::DecelType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::DecelType>() {
  return ::calmcar::perception::DecelType_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LineSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LineSide>() {
  return ::calmcar::perception::LineSide_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LineRole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LineRole>() {
  return ::calmcar::perception::LineRole_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::LreIndex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::LreIndex>() {
  return ::calmcar::perception::LreIndex_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::FSPType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::FSPType>() {
  return ::calmcar::perception::FSPType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_5froad_2eproto__INCLUDED
