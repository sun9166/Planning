// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map_overlap.proto

#ifndef PROTOBUF_map_5foverlap_2eproto__INCLUDED
#define PROTOBUF_map_5foverlap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "map_id.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_map_5foverlap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLaneOverlapInfoImpl();
void InitDefaultsLaneOverlapInfo();
void InitDefaultsSignalOverlapInfoImpl();
void InitDefaultsSignalOverlapInfo();
void InitDefaultsStopSignOverlapInfoImpl();
void InitDefaultsStopSignOverlapInfo();
void InitDefaultsCrosswalkOverlapInfoImpl();
void InitDefaultsCrosswalkOverlapInfo();
void InitDefaultsJunctionOverlapInfoImpl();
void InitDefaultsJunctionOverlapInfo();
void InitDefaultsYieldOverlapInfoImpl();
void InitDefaultsYieldOverlapInfo();
void InitDefaultsClearAreaOverlapInfoImpl();
void InitDefaultsClearAreaOverlapInfo();
void InitDefaultsSpeedBumpOverlapInfoImpl();
void InitDefaultsSpeedBumpOverlapInfo();
void InitDefaultsParkingSpaceOverlapInfoImpl();
void InitDefaultsParkingSpaceOverlapInfo();
void InitDefaultsObjectOverlapInfoImpl();
void InitDefaultsObjectOverlapInfo();
void InitDefaultsOverlapImpl();
void InitDefaultsOverlap();
inline void InitDefaults() {
  InitDefaultsLaneOverlapInfo();
  InitDefaultsSignalOverlapInfo();
  InitDefaultsStopSignOverlapInfo();
  InitDefaultsCrosswalkOverlapInfo();
  InitDefaultsJunctionOverlapInfo();
  InitDefaultsYieldOverlapInfo();
  InitDefaultsClearAreaOverlapInfo();
  InitDefaultsSpeedBumpOverlapInfo();
  InitDefaultsParkingSpaceOverlapInfo();
  InitDefaultsObjectOverlapInfo();
  InitDefaultsOverlap();
}
}  // namespace protobuf_map_5foverlap_2eproto
namespace acu {
namespace hdmap {
class ClearAreaOverlapInfo;
class ClearAreaOverlapInfoDefaultTypeInternal;
extern ClearAreaOverlapInfoDefaultTypeInternal _ClearAreaOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class JunctionOverlapInfo;
class JunctionOverlapInfoDefaultTypeInternal;
extern JunctionOverlapInfoDefaultTypeInternal _JunctionOverlapInfo_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class ObjectOverlapInfo;
class ObjectOverlapInfoDefaultTypeInternal;
extern ObjectOverlapInfoDefaultTypeInternal _ObjectOverlapInfo_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class ParkingSpaceOverlapInfo;
class ParkingSpaceOverlapInfoDefaultTypeInternal;
extern ParkingSpaceOverlapInfoDefaultTypeInternal _ParkingSpaceOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class SpeedBumpOverlapInfo;
class SpeedBumpOverlapInfoDefaultTypeInternal;
extern SpeedBumpOverlapInfoDefaultTypeInternal _SpeedBumpOverlapInfo_default_instance_;
class StopSignOverlapInfo;
class StopSignOverlapInfoDefaultTypeInternal;
extern StopSignOverlapInfoDefaultTypeInternal _StopSignOverlapInfo_default_instance_;
class YieldOverlapInfo;
class YieldOverlapInfoDefaultTypeInternal;
extern YieldOverlapInfoDefaultTypeInternal _YieldOverlapInfo_default_instance_;
}  // namespace hdmap
}  // namespace acu
namespace acu {
namespace hdmap {

// ===================================================================

class LaneOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.LaneOverlapInfo) */ {
 public:
  LaneOverlapInfo();
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneOverlapInfo(LaneOverlapInfo&& from) noexcept
    : LaneOverlapInfo() {
    *this = ::std::move(from);
  }

  inline LaneOverlapInfo& operator=(LaneOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const LaneOverlapInfo*>(
               &_LaneOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LaneOverlapInfo* other);
  friend void swap(LaneOverlapInfo& a, LaneOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  double end_s() const;
  void set_end_s(double value);

  // optional bool is_merge = 3;
  bool has_is_merge() const;
  void clear_is_merge();
  static const int kIsMergeFieldNumber = 3;
  bool is_merge() const;
  void set_is_merge(bool value);

  // @@protoc_insertion_point(class_scope:acu.hdmap.LaneOverlapInfo)
 private:
  void set_has_start_s();
  void clear_has_start_s();
  void set_has_end_s();
  void clear_has_end_s();
  void set_has_is_merge();
  void clear_has_is_merge();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double start_s_;
  double end_s_;
  bool is_merge_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsLaneOverlapInfoImpl();
};
// -------------------------------------------------------------------

class SignalOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.SignalOverlapInfo) */ {
 public:
  SignalOverlapInfo();
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalOverlapInfo(SignalOverlapInfo&& from) noexcept
    : SignalOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SignalOverlapInfo& operator=(SignalOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SignalOverlapInfo*>(
               &_SignalOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SignalOverlapInfo* other);
  friend void swap(SignalOverlapInfo& a, SignalOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SignalOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignalOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.SignalOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsSignalOverlapInfoImpl();
};
// -------------------------------------------------------------------

class StopSignOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.StopSignOverlapInfo) */ {
 public:
  StopSignOverlapInfo();
  virtual ~StopSignOverlapInfo();

  StopSignOverlapInfo(const StopSignOverlapInfo& from);

  inline StopSignOverlapInfo& operator=(const StopSignOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopSignOverlapInfo(StopSignOverlapInfo&& from) noexcept
    : StopSignOverlapInfo() {
    *this = ::std::move(from);
  }

  inline StopSignOverlapInfo& operator=(StopSignOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSignOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const StopSignOverlapInfo*>(
               &_StopSignOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StopSignOverlapInfo* other);
  friend void swap(StopSignOverlapInfo& a, StopSignOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopSignOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  StopSignOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopSignOverlapInfo& from);
  void MergeFrom(const StopSignOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopSignOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.StopSignOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsStopSignOverlapInfoImpl();
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.CrosswalkOverlapInfo) */ {
 public:
  CrosswalkOverlapInfo();
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrosswalkOverlapInfo(CrosswalkOverlapInfo&& from) noexcept
    : CrosswalkOverlapInfo() {
    *this = ::std::move(from);
  }

  inline CrosswalkOverlapInfo& operator=(CrosswalkOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrosswalkOverlapInfo*>(
               &_CrosswalkOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CrosswalkOverlapInfo* other);
  friend void swap(CrosswalkOverlapInfo& a, CrosswalkOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CrosswalkOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrosswalkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.CrosswalkOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsCrosswalkOverlapInfoImpl();
};
// -------------------------------------------------------------------

class JunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.JunctionOverlapInfo) */ {
 public:
  JunctionOverlapInfo();
  virtual ~JunctionOverlapInfo();

  JunctionOverlapInfo(const JunctionOverlapInfo& from);

  inline JunctionOverlapInfo& operator=(const JunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JunctionOverlapInfo(JunctionOverlapInfo&& from) noexcept
    : JunctionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline JunctionOverlapInfo& operator=(JunctionOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JunctionOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const JunctionOverlapInfo*>(
               &_JunctionOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(JunctionOverlapInfo* other);
  friend void swap(JunctionOverlapInfo& a, JunctionOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JunctionOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  JunctionOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JunctionOverlapInfo& from);
  void MergeFrom(const JunctionOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.JunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsJunctionOverlapInfoImpl();
};
// -------------------------------------------------------------------

class YieldOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.YieldOverlapInfo) */ {
 public:
  YieldOverlapInfo();
  virtual ~YieldOverlapInfo();

  YieldOverlapInfo(const YieldOverlapInfo& from);

  inline YieldOverlapInfo& operator=(const YieldOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YieldOverlapInfo(YieldOverlapInfo&& from) noexcept
    : YieldOverlapInfo() {
    *this = ::std::move(from);
  }

  inline YieldOverlapInfo& operator=(YieldOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YieldOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const YieldOverlapInfo*>(
               &_YieldOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(YieldOverlapInfo* other);
  friend void swap(YieldOverlapInfo& a, YieldOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YieldOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  YieldOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YieldOverlapInfo& from);
  void MergeFrom(const YieldOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YieldOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.YieldOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsYieldOverlapInfoImpl();
};
// -------------------------------------------------------------------

class ClearAreaOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.ClearAreaOverlapInfo) */ {
 public:
  ClearAreaOverlapInfo();
  virtual ~ClearAreaOverlapInfo();

  ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from);

  inline ClearAreaOverlapInfo& operator=(const ClearAreaOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClearAreaOverlapInfo(ClearAreaOverlapInfo&& from) noexcept
    : ClearAreaOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ClearAreaOverlapInfo& operator=(ClearAreaOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearAreaOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearAreaOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ClearAreaOverlapInfo*>(
               &_ClearAreaOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ClearAreaOverlapInfo* other);
  friend void swap(ClearAreaOverlapInfo& a, ClearAreaOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClearAreaOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ClearAreaOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClearAreaOverlapInfo& from);
  void MergeFrom(const ClearAreaOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClearAreaOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.ClearAreaOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsClearAreaOverlapInfoImpl();
};
// -------------------------------------------------------------------

class SpeedBumpOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.SpeedBumpOverlapInfo) */ {
 public:
  SpeedBumpOverlapInfo();
  virtual ~SpeedBumpOverlapInfo();

  SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from);

  inline SpeedBumpOverlapInfo& operator=(const SpeedBumpOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedBumpOverlapInfo(SpeedBumpOverlapInfo&& from) noexcept
    : SpeedBumpOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SpeedBumpOverlapInfo& operator=(SpeedBumpOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedBumpOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedBumpOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SpeedBumpOverlapInfo*>(
               &_SpeedBumpOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SpeedBumpOverlapInfo* other);
  friend void swap(SpeedBumpOverlapInfo& a, SpeedBumpOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedBumpOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SpeedBumpOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpeedBumpOverlapInfo& from);
  void MergeFrom(const SpeedBumpOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpeedBumpOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.SpeedBumpOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsSpeedBumpOverlapInfoImpl();
};
// -------------------------------------------------------------------

class ParkingSpaceOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.ParkingSpaceOverlapInfo) */ {
 public:
  ParkingSpaceOverlapInfo();
  virtual ~ParkingSpaceOverlapInfo();

  ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from);

  inline ParkingSpaceOverlapInfo& operator=(const ParkingSpaceOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSpaceOverlapInfo(ParkingSpaceOverlapInfo&& from) noexcept
    : ParkingSpaceOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceOverlapInfo& operator=(ParkingSpaceOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceOverlapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSpaceOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceOverlapInfo*>(
               &_ParkingSpaceOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ParkingSpaceOverlapInfo* other);
  friend void swap(ParkingSpaceOverlapInfo& a, ParkingSpaceOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpaceOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpaceOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpaceOverlapInfo& from);
  void MergeFrom(const ParkingSpaceOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpaceOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:acu.hdmap.ParkingSpaceOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsParkingSpaceOverlapInfoImpl();
};
// -------------------------------------------------------------------

class ObjectOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.ObjectOverlapInfo) */ {
 public:
  ObjectOverlapInfo();
  virtual ~ObjectOverlapInfo();

  ObjectOverlapInfo(const ObjectOverlapInfo& from);

  inline ObjectOverlapInfo& operator=(const ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectOverlapInfo(ObjectOverlapInfo&& from) noexcept
    : ObjectOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ObjectOverlapInfo& operator=(ObjectOverlapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLaneOverlapInfo = 3,
    kSignalOverlapInfo = 4,
    kStopSignOverlapInfo = 5,
    kCrosswalkOverlapInfo = 6,
    kJunctionOverlapInfo = 7,
    kYieldSignOverlapInfo = 8,
    kClearAreaOverlapInfo = 9,
    kSpeedBumpOverlapInfo = 10,
    kParkingSpaceOverlapInfo = 11,
    OVERLAP_INFO_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapInfo*>(
               &_ObjectOverlapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ObjectOverlapInfo* other);
  friend void swap(ObjectOverlapInfo& a, ObjectOverlapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectOverlapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectOverlapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObjectOverlapInfo& from);
  void MergeFrom(const ObjectOverlapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObjectOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::acu::hdmap::Id& id() const;
  ::acu::hdmap::Id* release_id();
  ::acu::hdmap::Id* mutable_id();
  void set_allocated_id(::acu::hdmap::Id* id);

  // optional .acu.hdmap.LaneOverlapInfo lane_overlap_info = 3;
  bool has_lane_overlap_info() const;
  void clear_lane_overlap_info();
  static const int kLaneOverlapInfoFieldNumber = 3;
  const ::acu::hdmap::LaneOverlapInfo& lane_overlap_info() const;
  ::acu::hdmap::LaneOverlapInfo* release_lane_overlap_info();
  ::acu::hdmap::LaneOverlapInfo* mutable_lane_overlap_info();
  void set_allocated_lane_overlap_info(::acu::hdmap::LaneOverlapInfo* lane_overlap_info);

  // optional .acu.hdmap.SignalOverlapInfo signal_overlap_info = 4;
  bool has_signal_overlap_info() const;
  void clear_signal_overlap_info();
  static const int kSignalOverlapInfoFieldNumber = 4;
  const ::acu::hdmap::SignalOverlapInfo& signal_overlap_info() const;
  ::acu::hdmap::SignalOverlapInfo* release_signal_overlap_info();
  ::acu::hdmap::SignalOverlapInfo* mutable_signal_overlap_info();
  void set_allocated_signal_overlap_info(::acu::hdmap::SignalOverlapInfo* signal_overlap_info);

  // optional .acu.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
  bool has_stop_sign_overlap_info() const;
  void clear_stop_sign_overlap_info();
  static const int kStopSignOverlapInfoFieldNumber = 5;
  const ::acu::hdmap::StopSignOverlapInfo& stop_sign_overlap_info() const;
  ::acu::hdmap::StopSignOverlapInfo* release_stop_sign_overlap_info();
  ::acu::hdmap::StopSignOverlapInfo* mutable_stop_sign_overlap_info();
  void set_allocated_stop_sign_overlap_info(::acu::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);

  // optional .acu.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
  bool has_crosswalk_overlap_info() const;
  void clear_crosswalk_overlap_info();
  static const int kCrosswalkOverlapInfoFieldNumber = 6;
  const ::acu::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info() const;
  ::acu::hdmap::CrosswalkOverlapInfo* release_crosswalk_overlap_info();
  ::acu::hdmap::CrosswalkOverlapInfo* mutable_crosswalk_overlap_info();
  void set_allocated_crosswalk_overlap_info(::acu::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);

  // optional .acu.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
  bool has_junction_overlap_info() const;
  void clear_junction_overlap_info();
  static const int kJunctionOverlapInfoFieldNumber = 7;
  const ::acu::hdmap::JunctionOverlapInfo& junction_overlap_info() const;
  ::acu::hdmap::JunctionOverlapInfo* release_junction_overlap_info();
  ::acu::hdmap::JunctionOverlapInfo* mutable_junction_overlap_info();
  void set_allocated_junction_overlap_info(::acu::hdmap::JunctionOverlapInfo* junction_overlap_info);

  // optional .acu.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
  bool has_yield_sign_overlap_info() const;
  void clear_yield_sign_overlap_info();
  static const int kYieldSignOverlapInfoFieldNumber = 8;
  const ::acu::hdmap::YieldOverlapInfo& yield_sign_overlap_info() const;
  ::acu::hdmap::YieldOverlapInfo* release_yield_sign_overlap_info();
  ::acu::hdmap::YieldOverlapInfo* mutable_yield_sign_overlap_info();
  void set_allocated_yield_sign_overlap_info(::acu::hdmap::YieldOverlapInfo* yield_sign_overlap_info);

  // optional .acu.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
  bool has_clear_area_overlap_info() const;
  void clear_clear_area_overlap_info();
  static const int kClearAreaOverlapInfoFieldNumber = 9;
  const ::acu::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info() const;
  ::acu::hdmap::ClearAreaOverlapInfo* release_clear_area_overlap_info();
  ::acu::hdmap::ClearAreaOverlapInfo* mutable_clear_area_overlap_info();
  void set_allocated_clear_area_overlap_info(::acu::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);

  // optional .acu.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
  bool has_speed_bump_overlap_info() const;
  void clear_speed_bump_overlap_info();
  static const int kSpeedBumpOverlapInfoFieldNumber = 10;
  const ::acu::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info() const;
  ::acu::hdmap::SpeedBumpOverlapInfo* release_speed_bump_overlap_info();
  ::acu::hdmap::SpeedBumpOverlapInfo* mutable_speed_bump_overlap_info();
  void set_allocated_speed_bump_overlap_info(::acu::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);

  // optional .acu.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
  bool has_parking_space_overlap_info() const;
  void clear_parking_space_overlap_info();
  static const int kParkingSpaceOverlapInfoFieldNumber = 11;
  const ::acu::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info() const;
  ::acu::hdmap::ParkingSpaceOverlapInfo* release_parking_space_overlap_info();
  ::acu::hdmap::ParkingSpaceOverlapInfo* mutable_parking_space_overlap_info();
  void set_allocated_parking_space_overlap_info(::acu::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);

  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:acu.hdmap.ObjectOverlapInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_lane_overlap_info();
  void set_has_signal_overlap_info();
  void set_has_stop_sign_overlap_info();
  void set_has_crosswalk_overlap_info();
  void set_has_junction_overlap_info();
  void set_has_yield_sign_overlap_info();
  void set_has_clear_area_overlap_info();
  void set_has_speed_bump_overlap_info();
  void set_has_parking_space_overlap_info();

  inline bool has_overlap_info() const;
  void clear_overlap_info();
  inline void clear_has_overlap_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::hdmap::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::acu::hdmap::LaneOverlapInfo* lane_overlap_info_;
    ::acu::hdmap::SignalOverlapInfo* signal_overlap_info_;
    ::acu::hdmap::StopSignOverlapInfo* stop_sign_overlap_info_;
    ::acu::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info_;
    ::acu::hdmap::JunctionOverlapInfo* junction_overlap_info_;
    ::acu::hdmap::YieldOverlapInfo* yield_sign_overlap_info_;
    ::acu::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info_;
    ::acu::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info_;
    ::acu::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info_;
  } overlap_info_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsObjectOverlapInfoImpl();
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.hdmap.Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Overlap(Overlap&& from) noexcept
    : Overlap() {
    *this = ::std::move(from);
  }

  inline Overlap& operator=(Overlap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Overlap* other);
  friend void swap(Overlap& a, Overlap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Overlap* New() const PROTOBUF_FINAL { return New(NULL); }

  Overlap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .acu.hdmap.ObjectOverlapInfo object = 2;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::acu::hdmap::ObjectOverlapInfo& object(int index) const;
  ::acu::hdmap::ObjectOverlapInfo* mutable_object(int index);
  ::acu::hdmap::ObjectOverlapInfo* add_object();
  ::google::protobuf::RepeatedPtrField< ::acu::hdmap::ObjectOverlapInfo >*
      mutable_object();
  const ::google::protobuf::RepeatedPtrField< ::acu::hdmap::ObjectOverlapInfo >&
      object() const;

  // optional .acu.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::acu::hdmap::Id& id() const;
  ::acu::hdmap::Id* release_id();
  ::acu::hdmap::Id* mutable_id();
  void set_allocated_id(::acu::hdmap::Id* id);

  // @@protoc_insertion_point(class_scope:acu.hdmap.Overlap)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::acu::hdmap::ObjectOverlapInfo > object_;
  ::acu::hdmap::Id* id_;
  friend struct ::protobuf_map_5foverlap_2eproto::TableStruct;
  friend void ::protobuf_map_5foverlap_2eproto::InitDefaultsOverlapImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.LaneOverlapInfo.start_s)
  return start_s_;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:acu.hdmap.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.LaneOverlapInfo.end_s)
  return end_s_;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:acu.hdmap.LaneOverlapInfo.end_s)
}

// optional bool is_merge = 3;
inline bool LaneOverlapInfo::has_is_merge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneOverlapInfo::set_has_is_merge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneOverlapInfo::clear_has_is_merge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneOverlapInfo::clear_is_merge() {
  is_merge_ = false;
  clear_has_is_merge();
}
inline bool LaneOverlapInfo::is_merge() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.LaneOverlapInfo.is_merge)
  return is_merge_;
}
inline void LaneOverlapInfo::set_is_merge(bool value) {
  set_has_is_merge();
  is_merge_ = value;
  // @@protoc_insertion_point(field_set:acu.hdmap.LaneOverlapInfo.is_merge)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// -------------------------------------------------------------------

// StopSignOverlapInfo

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// -------------------------------------------------------------------

// JunctionOverlapInfo

// -------------------------------------------------------------------

// YieldOverlapInfo

// -------------------------------------------------------------------

// ClearAreaOverlapInfo

// -------------------------------------------------------------------

// SpeedBumpOverlapInfo

// -------------------------------------------------------------------

// ParkingSpaceOverlapInfo

// -------------------------------------------------------------------

// ObjectOverlapInfo

// optional .acu.hdmap.Id id = 1;
inline bool ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::acu::hdmap::Id& ObjectOverlapInfo::id() const {
  const ::acu::hdmap::Id* p = id_;
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.id)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::hdmap::Id*>(
      &::acu::hdmap::_Id_default_instance_);
}
inline ::acu::hdmap::Id* ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.id)
  clear_has_id();
  ::acu::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::acu::hdmap::Id* ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::acu::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.id)
  return id_;
}
inline void ObjectOverlapInfo::set_allocated_id(::acu::hdmap::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:acu.hdmap.ObjectOverlapInfo.id)
}

// optional .acu.hdmap.LaneOverlapInfo lane_overlap_info = 3;
inline bool ObjectOverlapInfo::has_lane_overlap_info() const {
  return overlap_info_case() == kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_lane_overlap_info() {
  _oneof_case_[0] = kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::clear_lane_overlap_info() {
  if (has_lane_overlap_info()) {
    delete overlap_info_.lane_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::LaneOverlapInfo* ObjectOverlapInfo::release_lane_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (has_lane_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    overlap_info_.lane_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::LaneOverlapInfo& ObjectOverlapInfo::lane_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return has_lane_overlap_info()
      ? *overlap_info_.lane_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::LaneOverlapInfo*>(&::acu::hdmap::_LaneOverlapInfo_default_instance_);
}
inline ::acu::hdmap::LaneOverlapInfo* ObjectOverlapInfo::mutable_lane_overlap_info() {
  if (!has_lane_overlap_info()) {
    clear_overlap_info();
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = new ::acu::hdmap::LaneOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return overlap_info_.lane_overlap_info_;
}

// optional .acu.hdmap.SignalOverlapInfo signal_overlap_info = 4;
inline bool ObjectOverlapInfo::has_signal_overlap_info() const {
  return overlap_info_case() == kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_signal_overlap_info() {
  _oneof_case_[0] = kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::clear_signal_overlap_info() {
  if (has_signal_overlap_info()) {
    delete overlap_info_.signal_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::SignalOverlapInfo* ObjectOverlapInfo::release_signal_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (has_signal_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    overlap_info_.signal_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::SignalOverlapInfo& ObjectOverlapInfo::signal_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return has_signal_overlap_info()
      ? *overlap_info_.signal_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::SignalOverlapInfo*>(&::acu::hdmap::_SignalOverlapInfo_default_instance_);
}
inline ::acu::hdmap::SignalOverlapInfo* ObjectOverlapInfo::mutable_signal_overlap_info() {
  if (!has_signal_overlap_info()) {
    clear_overlap_info();
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = new ::acu::hdmap::SignalOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return overlap_info_.signal_overlap_info_;
}

// optional .acu.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
inline bool ObjectOverlapInfo::has_stop_sign_overlap_info() const {
  return overlap_info_case() == kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_stop_sign_overlap_info() {
  _oneof_case_[0] = kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_stop_sign_overlap_info() {
  if (has_stop_sign_overlap_info()) {
    delete overlap_info_.stop_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    overlap_info_.stop_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::stop_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return has_stop_sign_overlap_info()
      ? *overlap_info_.stop_sign_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::StopSignOverlapInfo*>(&::acu::hdmap::_StopSignOverlapInfo_default_instance_);
}
inline ::acu::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::mutable_stop_sign_overlap_info() {
  if (!has_stop_sign_overlap_info()) {
    clear_overlap_info();
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = new ::acu::hdmap::StopSignOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return overlap_info_.stop_sign_overlap_info_;
}

// optional .acu.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
inline bool ObjectOverlapInfo::has_crosswalk_overlap_info() const {
  return overlap_info_case() == kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_crosswalk_overlap_info() {
  _oneof_case_[0] = kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::clear_crosswalk_overlap_info() {
  if (has_crosswalk_overlap_info()) {
    delete overlap_info_.crosswalk_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    overlap_info_.crosswalk_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::crosswalk_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return has_crosswalk_overlap_info()
      ? *overlap_info_.crosswalk_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::CrosswalkOverlapInfo*>(&::acu::hdmap::_CrosswalkOverlapInfo_default_instance_);
}
inline ::acu::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::mutable_crosswalk_overlap_info() {
  if (!has_crosswalk_overlap_info()) {
    clear_overlap_info();
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = new ::acu::hdmap::CrosswalkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return overlap_info_.crosswalk_overlap_info_;
}

// optional .acu.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
inline bool ObjectOverlapInfo::has_junction_overlap_info() const {
  return overlap_info_case() == kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_junction_overlap_info() {
  _oneof_case_[0] = kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_junction_overlap_info() {
  if (has_junction_overlap_info()) {
    delete overlap_info_.junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::release_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (has_junction_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    overlap_info_.junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return has_junction_overlap_info()
      ? *overlap_info_.junction_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::JunctionOverlapInfo*>(&::acu::hdmap::_JunctionOverlapInfo_default_instance_);
}
inline ::acu::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::mutable_junction_overlap_info() {
  if (!has_junction_overlap_info()) {
    clear_overlap_info();
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = new ::acu::hdmap::JunctionOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return overlap_info_.junction_overlap_info_;
}

// optional .acu.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
inline bool ObjectOverlapInfo::has_yield_sign_overlap_info() const {
  return overlap_info_case() == kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_yield_sign_overlap_info() {
  _oneof_case_[0] = kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_yield_sign_overlap_info() {
  if (has_yield_sign_overlap_info()) {
    delete overlap_info_.yield_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::YieldOverlapInfo* ObjectOverlapInfo::release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    overlap_info_.yield_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::YieldOverlapInfo& ObjectOverlapInfo::yield_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return has_yield_sign_overlap_info()
      ? *overlap_info_.yield_sign_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::YieldOverlapInfo*>(&::acu::hdmap::_YieldOverlapInfo_default_instance_);
}
inline ::acu::hdmap::YieldOverlapInfo* ObjectOverlapInfo::mutable_yield_sign_overlap_info() {
  if (!has_yield_sign_overlap_info()) {
    clear_overlap_info();
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = new ::acu::hdmap::YieldOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return overlap_info_.yield_sign_overlap_info_;
}

// optional .acu.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
inline bool ObjectOverlapInfo::has_clear_area_overlap_info() const {
  return overlap_info_case() == kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_clear_area_overlap_info() {
  _oneof_case_[0] = kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::clear_clear_area_overlap_info() {
  if (has_clear_area_overlap_info()) {
    delete overlap_info_.clear_area_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (has_clear_area_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    overlap_info_.clear_area_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::clear_area_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return has_clear_area_overlap_info()
      ? *overlap_info_.clear_area_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::ClearAreaOverlapInfo*>(&::acu::hdmap::_ClearAreaOverlapInfo_default_instance_);
}
inline ::acu::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::mutable_clear_area_overlap_info() {
  if (!has_clear_area_overlap_info()) {
    clear_overlap_info();
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = new ::acu::hdmap::ClearAreaOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return overlap_info_.clear_area_overlap_info_;
}

// optional .acu.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
inline bool ObjectOverlapInfo::has_speed_bump_overlap_info() const {
  return overlap_info_case() == kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_speed_bump_overlap_info() {
  _oneof_case_[0] = kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::clear_speed_bump_overlap_info() {
  if (has_speed_bump_overlap_info()) {
    delete overlap_info_.speed_bump_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    overlap_info_.speed_bump_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::speed_bump_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return has_speed_bump_overlap_info()
      ? *overlap_info_.speed_bump_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::SpeedBumpOverlapInfo*>(&::acu::hdmap::_SpeedBumpOverlapInfo_default_instance_);
}
inline ::acu::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::mutable_speed_bump_overlap_info() {
  if (!has_speed_bump_overlap_info()) {
    clear_overlap_info();
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = new ::acu::hdmap::SpeedBumpOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return overlap_info_.speed_bump_overlap_info_;
}

// optional .acu.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
inline bool ObjectOverlapInfo::has_parking_space_overlap_info() const {
  return overlap_info_case() == kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_parking_space_overlap_info() {
  _oneof_case_[0] = kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::clear_parking_space_overlap_info() {
  if (has_parking_space_overlap_info()) {
    delete overlap_info_.parking_space_overlap_info_;
    clear_has_overlap_info();
  }
}
inline ::acu::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_release:acu.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (has_parking_space_overlap_info()) {
    clear_has_overlap_info();
      ::acu::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    overlap_info_.parking_space_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::acu::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::parking_space_overlap_info() const {
  // @@protoc_insertion_point(field_get:acu.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return has_parking_space_overlap_info()
      ? *overlap_info_.parking_space_overlap_info_
      : *reinterpret_cast< ::acu::hdmap::ParkingSpaceOverlapInfo*>(&::acu::hdmap::_ParkingSpaceOverlapInfo_default_instance_);
}
inline ::acu::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::mutable_parking_space_overlap_info() {
  if (!has_parking_space_overlap_info()) {
    clear_overlap_info();
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = new ::acu::hdmap::ParkingSpaceOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return overlap_info_.parking_space_overlap_info_;
}

inline bool ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline ObjectOverlapInfo::OverlapInfoCase ObjectOverlapInfo::overlap_info_case() const {
  return ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Overlap

// optional .acu.hdmap.Id id = 1;
inline bool Overlap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::acu::hdmap::Id& Overlap::id() const {
  const ::acu::hdmap::Id* p = id_;
  // @@protoc_insertion_point(field_get:acu.hdmap.Overlap.id)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::hdmap::Id*>(
      &::acu::hdmap::_Id_default_instance_);
}
inline ::acu::hdmap::Id* Overlap::release_id() {
  // @@protoc_insertion_point(field_release:acu.hdmap.Overlap.id)
  clear_has_id();
  ::acu::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::acu::hdmap::Id* Overlap::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::acu::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:acu.hdmap.Overlap.id)
  return id_;
}
inline void Overlap::set_allocated_id(::acu::hdmap::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:acu.hdmap.Overlap.id)
}

// repeated .acu.hdmap.ObjectOverlapInfo object = 2;
inline int Overlap::object_size() const {
  return object_.size();
}
inline void Overlap::clear_object() {
  object_.Clear();
}
inline const ::acu::hdmap::ObjectOverlapInfo& Overlap::object(int index) const {
  // @@protoc_insertion_point(field_get:acu.hdmap.Overlap.object)
  return object_.Get(index);
}
inline ::acu::hdmap::ObjectOverlapInfo* Overlap::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:acu.hdmap.Overlap.object)
  return object_.Mutable(index);
}
inline ::acu::hdmap::ObjectOverlapInfo* Overlap::add_object() {
  // @@protoc_insertion_point(field_add:acu.hdmap.Overlap.object)
  return object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::acu::hdmap::ObjectOverlapInfo >*
Overlap::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:acu.hdmap.Overlap.object)
  return &object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::acu::hdmap::ObjectOverlapInfo >&
Overlap::object() const {
  // @@protoc_insertion_point(field_list:acu.hdmap.Overlap.object)
  return object_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace acu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_5foverlap_2eproto__INCLUDED
