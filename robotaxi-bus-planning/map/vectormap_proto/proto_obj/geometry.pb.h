// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef PROTOBUF_geometry_2eproto__INCLUDED
#define PROTOBUF_geometry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_geometry_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPointENUImpl();
void InitDefaultsPointENU();
void InitDefaultsPoint2DImpl();
void InitDefaultsPoint2D();
void InitDefaultsPoint3DImpl();
void InitDefaultsPoint3D();
void InitDefaultsUnsureVarImpl();
void InitDefaultsUnsureVar();
void InitDefaultsUnsurePointsImpl();
void InitDefaultsUnsurePoints();
void InitDefaultsUnsurePositionImpl();
void InitDefaultsUnsurePosition();
void InitDefaultsVector3Impl();
void InitDefaultsVector3();
void InitDefaultsQuaternionImpl();
void InitDefaultsQuaternion();
void InitDefaultsVector3WithCovarianceImpl();
void InitDefaultsVector3WithCovariance();
void InitDefaultsEulerWithCovarianceImpl();
void InitDefaultsEulerWithCovariance();
void InitDefaultsWheelSpeedImpl();
void InitDefaultsWheelSpeed();
void InitDefaultsPoseEulerImpl();
void InitDefaultsPoseEuler();
void InitDefaultsPoseQuaternionImpl();
void InitDefaultsPoseQuaternion();
void InitDefaultsTwistImpl();
void InitDefaultsTwist();
void InitDefaultsPoseImpl();
void InitDefaultsPose();
void InitDefaultsLLHImpl();
void InitDefaultsLLH();
void InitDefaultsNavStatusImpl();
void InitDefaultsNavStatus();
inline void InitDefaults() {
  InitDefaultsPointENU();
  InitDefaultsPoint2D();
  InitDefaultsPoint3D();
  InitDefaultsUnsureVar();
  InitDefaultsUnsurePoints();
  InitDefaultsUnsurePosition();
  InitDefaultsVector3();
  InitDefaultsQuaternion();
  InitDefaultsVector3WithCovariance();
  InitDefaultsEulerWithCovariance();
  InitDefaultsWheelSpeed();
  InitDefaultsPoseEuler();
  InitDefaultsPoseQuaternion();
  InitDefaultsTwist();
  InitDefaultsPose();
  InitDefaultsLLH();
  InitDefaultsNavStatus();
}
}  // namespace protobuf_geometry_2eproto
namespace acu {
namespace common {
class EulerWithCovariance;
class EulerWithCovarianceDefaultTypeInternal;
extern EulerWithCovarianceDefaultTypeInternal _EulerWithCovariance_default_instance_;
class LLH;
class LLHDefaultTypeInternal;
extern LLHDefaultTypeInternal _LLH_default_instance_;
class NavStatus;
class NavStatusDefaultTypeInternal;
extern NavStatusDefaultTypeInternal _NavStatus_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointENU;
class PointENUDefaultTypeInternal;
extern PointENUDefaultTypeInternal _PointENU_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class PoseEuler;
class PoseEulerDefaultTypeInternal;
extern PoseEulerDefaultTypeInternal _PoseEuler_default_instance_;
class PoseQuaternion;
class PoseQuaternionDefaultTypeInternal;
extern PoseQuaternionDefaultTypeInternal _PoseQuaternion_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Twist;
class TwistDefaultTypeInternal;
extern TwistDefaultTypeInternal _Twist_default_instance_;
class UnsurePoints;
class UnsurePointsDefaultTypeInternal;
extern UnsurePointsDefaultTypeInternal _UnsurePoints_default_instance_;
class UnsurePosition;
class UnsurePositionDefaultTypeInternal;
extern UnsurePositionDefaultTypeInternal _UnsurePosition_default_instance_;
class UnsureVar;
class UnsureVarDefaultTypeInternal;
extern UnsureVarDefaultTypeInternal _UnsureVar_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vector3WithCovariance;
class Vector3WithCovarianceDefaultTypeInternal;
extern Vector3WithCovarianceDefaultTypeInternal _Vector3WithCovariance_default_instance_;
class WheelSpeed;
class WheelSpeedDefaultTypeInternal;
extern WheelSpeedDefaultTypeInternal _WheelSpeed_default_instance_;
}  // namespace common
}  // namespace acu
namespace acu {
namespace common {

enum PoseStatus {
  NORMAL = 0,
  ERROR = 1
};
bool PoseStatus_IsValid(int value);
const PoseStatus PoseStatus_MIN = NORMAL;
const PoseStatus PoseStatus_MAX = ERROR;
const int PoseStatus_ARRAYSIZE = PoseStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoseStatus_descriptor();
inline const ::std::string& PoseStatus_Name(PoseStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoseStatus_descriptor(), value);
}
inline bool PoseStatus_Parse(
    const ::std::string& name, PoseStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoseStatus>(
    PoseStatus_descriptor(), name, value);
}
enum GpsStatus {
  NOFIX = 0,
  SINGLE = 1,
  PSRDIFF = 2,
  CODE_DIFF = 3,
  NARROW_INT = 4,
  NARROW_FLOAT = 5
};
bool GpsStatus_IsValid(int value);
const GpsStatus GpsStatus_MIN = NOFIX;
const GpsStatus GpsStatus_MAX = NARROW_FLOAT;
const int GpsStatus_ARRAYSIZE = GpsStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpsStatus_descriptor();
inline const ::std::string& GpsStatus_Name(GpsStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpsStatus_descriptor(), value);
}
inline bool GpsStatus_Parse(
    const ::std::string& name, GpsStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpsStatus>(
    GpsStatus_descriptor(), name, value);
}
// ===================================================================

class PointENU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.PointENU) */ {
 public:
  PointENU();
  virtual ~PointENU();

  PointENU(const PointENU& from);

  inline PointENU& operator=(const PointENU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointENU(PointENU&& from) noexcept
    : PointENU() {
    *this = ::std::move(from);
  }

  inline PointENU& operator=(PointENU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointENU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointENU* internal_default_instance() {
    return reinterpret_cast<const PointENU*>(
               &_PointENU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PointENU* other);
  friend void swap(PointENU& a, PointENU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointENU* New() const PROTOBUF_FINAL { return New(NULL); }

  PointENU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointENU& from);
  void MergeFrom(const PointENU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointENU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double x = 1 [default = nan];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2 [default = nan];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:acu.common.PointENU)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double z_;
  double x_;
  double y_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPointENUImpl();
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(Point2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Point2D* other);
  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const PROTOBUF_FINAL { return New(NULL); }

  Point2D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1 [default = nan];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2 [default = nan];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:acu.common.Point2D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPoint2DImpl();
};
// -------------------------------------------------------------------

class Point3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Point3D) */ {
 public:
  Point3D();
  virtual ~Point3D();

  Point3D(const Point3D& from);

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(Point3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Point3D* other);
  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3D* New() const PROTOBUF_FINAL { return New(NULL); }

  Point3D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point3D& from);
  void MergeFrom(const Point3D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1 [default = nan];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2 [default = nan];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3 [default = nan];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:acu.common.Point3D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPoint3DImpl();
};
// -------------------------------------------------------------------

class UnsureVar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.UnsureVar) */ {
 public:
  UnsureVar();
  virtual ~UnsureVar();

  UnsureVar(const UnsureVar& from);

  inline UnsureVar& operator=(const UnsureVar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnsureVar(UnsureVar&& from) noexcept
    : UnsureVar() {
    *this = ::std::move(from);
  }

  inline UnsureVar& operator=(UnsureVar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsureVar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnsureVar* internal_default_instance() {
    return reinterpret_cast<const UnsureVar*>(
               &_UnsureVar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(UnsureVar* other);
  friend void swap(UnsureVar& a, UnsureVar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnsureVar* New() const PROTOBUF_FINAL { return New(NULL); }

  UnsureVar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnsureVar& from);
  void MergeFrom(const UnsureVar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnsureVar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double variable = 1;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  double variable() const;
  void set_variable(double value);

  // optional double var_std = 2;
  bool has_var_std() const;
  void clear_var_std();
  static const int kVarStdFieldNumber = 2;
  double var_std() const;
  void set_var_std(double value);

  // @@protoc_insertion_point(class_scope:acu.common.UnsureVar)
 private:
  void set_has_variable();
  void clear_has_variable();
  void set_has_var_std();
  void clear_has_var_std();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double variable_;
  double var_std_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsUnsureVarImpl();
};
// -------------------------------------------------------------------

class UnsurePoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.UnsurePoints) */ {
 public:
  UnsurePoints();
  virtual ~UnsurePoints();

  UnsurePoints(const UnsurePoints& from);

  inline UnsurePoints& operator=(const UnsurePoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnsurePoints(UnsurePoints&& from) noexcept
    : UnsurePoints() {
    *this = ::std::move(from);
  }

  inline UnsurePoints& operator=(UnsurePoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsurePoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnsurePoints* internal_default_instance() {
    return reinterpret_cast<const UnsurePoints*>(
               &_UnsurePoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UnsurePoints* other);
  friend void swap(UnsurePoints& a, UnsurePoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnsurePoints* New() const PROTOBUF_FINAL { return New(NULL); }

  UnsurePoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnsurePoints& from);
  void MergeFrom(const UnsurePoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnsurePoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsureVar x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  const ::acu::common::UnsureVar& x() const;
  ::acu::common::UnsureVar* release_x();
  ::acu::common::UnsureVar* mutable_x();
  void set_allocated_x(::acu::common::UnsureVar* x);

  // optional .acu.common.UnsureVar y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  const ::acu::common::UnsureVar& y() const;
  ::acu::common::UnsureVar* release_y();
  ::acu::common::UnsureVar* mutable_y();
  void set_allocated_y(::acu::common::UnsureVar* y);

  // optional .acu.common.UnsureVar heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  const ::acu::common::UnsureVar& heading() const;
  ::acu::common::UnsureVar* release_heading();
  ::acu::common::UnsureVar* mutable_heading();
  void set_allocated_heading(::acu::common::UnsureVar* heading);

  // optional double rho = 4;
  bool has_rho() const;
  void clear_rho();
  static const int kRhoFieldNumber = 4;
  double rho() const;
  void set_rho(double value);

  // @@protoc_insertion_point(class_scope:acu.common.UnsurePoints)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_heading();
  void clear_has_heading();
  void set_has_rho();
  void clear_has_rho();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsureVar* x_;
  ::acu::common::UnsureVar* y_;
  ::acu::common::UnsureVar* heading_;
  double rho_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsUnsurePointsImpl();
};
// -------------------------------------------------------------------

class UnsurePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.UnsurePosition) */ {
 public:
  UnsurePosition();
  virtual ~UnsurePosition();

  UnsurePosition(const UnsurePosition& from);

  inline UnsurePosition& operator=(const UnsurePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnsurePosition(UnsurePosition&& from) noexcept
    : UnsurePosition() {
    *this = ::std::move(from);
  }

  inline UnsurePosition& operator=(UnsurePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnsurePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnsurePosition* internal_default_instance() {
    return reinterpret_cast<const UnsurePosition*>(
               &_UnsurePosition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UnsurePosition* other);
  friend void swap(UnsurePosition& a, UnsurePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnsurePosition* New() const PROTOBUF_FINAL { return New(NULL); }

  UnsurePosition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnsurePosition& from);
  void MergeFrom(const UnsurePosition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnsurePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsurePoints point = 2;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  const ::acu::common::UnsurePoints& point() const;
  ::acu::common::UnsurePoints* release_point();
  ::acu::common::UnsurePoints* mutable_point();
  void set_allocated_point(::acu::common::UnsurePoints* point);

  // optional int32 parking_id = 1;
  bool has_parking_id() const;
  void clear_parking_id();
  static const int kParkingIdFieldNumber = 1;
  ::google::protobuf::int32 parking_id() const;
  void set_parking_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:acu.common.UnsurePosition)
 private:
  void set_has_parking_id();
  void clear_has_parking_id();
  void set_has_point();
  void clear_has_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsurePoints* point_;
  ::google::protobuf::int32 parking_id_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsUnsurePositionImpl();
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Vector3* other);
  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:acu.common.Vector3)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsVector3Impl();
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:acu.common.Quaternion)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsQuaternionImpl();
};
// -------------------------------------------------------------------

class Vector3WithCovariance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Vector3WithCovariance) */ {
 public:
  Vector3WithCovariance();
  virtual ~Vector3WithCovariance();

  Vector3WithCovariance(const Vector3WithCovariance& from);

  inline Vector3WithCovariance& operator=(const Vector3WithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3WithCovariance(Vector3WithCovariance&& from) noexcept
    : Vector3WithCovariance() {
    *this = ::std::move(from);
  }

  inline Vector3WithCovariance& operator=(Vector3WithCovariance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3WithCovariance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3WithCovariance* internal_default_instance() {
    return reinterpret_cast<const Vector3WithCovariance*>(
               &_Vector3WithCovariance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Vector3WithCovariance* other);
  friend void swap(Vector3WithCovariance& a, Vector3WithCovariance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3WithCovariance* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3WithCovariance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3WithCovariance& from);
  void MergeFrom(const Vector3WithCovariance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3WithCovariance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsureVar x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  const ::acu::common::UnsureVar& x() const;
  ::acu::common::UnsureVar* release_x();
  ::acu::common::UnsureVar* mutable_x();
  void set_allocated_x(::acu::common::UnsureVar* x);

  // optional .acu.common.UnsureVar y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  const ::acu::common::UnsureVar& y() const;
  ::acu::common::UnsureVar* release_y();
  ::acu::common::UnsureVar* mutable_y();
  void set_allocated_y(::acu::common::UnsureVar* y);

  // optional .acu.common.UnsureVar z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  const ::acu::common::UnsureVar& z() const;
  ::acu::common::UnsureVar* release_z();
  ::acu::common::UnsureVar* mutable_z();
  void set_allocated_z(::acu::common::UnsureVar* z);

  // @@protoc_insertion_point(class_scope:acu.common.Vector3WithCovariance)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsureVar* x_;
  ::acu::common::UnsureVar* y_;
  ::acu::common::UnsureVar* z_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsVector3WithCovarianceImpl();
};
// -------------------------------------------------------------------

class EulerWithCovariance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.EulerWithCovariance) */ {
 public:
  EulerWithCovariance();
  virtual ~EulerWithCovariance();

  EulerWithCovariance(const EulerWithCovariance& from);

  inline EulerWithCovariance& operator=(const EulerWithCovariance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EulerWithCovariance(EulerWithCovariance&& from) noexcept
    : EulerWithCovariance() {
    *this = ::std::move(from);
  }

  inline EulerWithCovariance& operator=(EulerWithCovariance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EulerWithCovariance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EulerWithCovariance* internal_default_instance() {
    return reinterpret_cast<const EulerWithCovariance*>(
               &_EulerWithCovariance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(EulerWithCovariance* other);
  friend void swap(EulerWithCovariance& a, EulerWithCovariance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EulerWithCovariance* New() const PROTOBUF_FINAL { return New(NULL); }

  EulerWithCovariance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EulerWithCovariance& from);
  void MergeFrom(const EulerWithCovariance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EulerWithCovariance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsureVar roll = 1;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  const ::acu::common::UnsureVar& roll() const;
  ::acu::common::UnsureVar* release_roll();
  ::acu::common::UnsureVar* mutable_roll();
  void set_allocated_roll(::acu::common::UnsureVar* roll);

  // optional .acu.common.UnsureVar pitch = 2;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  const ::acu::common::UnsureVar& pitch() const;
  ::acu::common::UnsureVar* release_pitch();
  ::acu::common::UnsureVar* mutable_pitch();
  void set_allocated_pitch(::acu::common::UnsureVar* pitch);

  // optional .acu.common.UnsureVar yaw = 3;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  const ::acu::common::UnsureVar& yaw() const;
  ::acu::common::UnsureVar* release_yaw();
  ::acu::common::UnsureVar* mutable_yaw();
  void set_allocated_yaw(::acu::common::UnsureVar* yaw);

  // @@protoc_insertion_point(class_scope:acu.common.EulerWithCovariance)
 private:
  void set_has_roll();
  void clear_has_roll();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_yaw();
  void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsureVar* roll_;
  ::acu::common::UnsureVar* pitch_;
  ::acu::common::UnsureVar* yaw_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsEulerWithCovarianceImpl();
};
// -------------------------------------------------------------------

class WheelSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.WheelSpeed) */ {
 public:
  WheelSpeed();
  virtual ~WheelSpeed();

  WheelSpeed(const WheelSpeed& from);

  inline WheelSpeed& operator=(const WheelSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WheelSpeed(WheelSpeed&& from) noexcept
    : WheelSpeed() {
    *this = ::std::move(from);
  }

  inline WheelSpeed& operator=(WheelSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WheelSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WheelSpeed* internal_default_instance() {
    return reinterpret_cast<const WheelSpeed*>(
               &_WheelSpeed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(WheelSpeed* other);
  friend void swap(WheelSpeed& a, WheelSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WheelSpeed* New() const PROTOBUF_FINAL { return New(NULL); }

  WheelSpeed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WheelSpeed& from);
  void MergeFrom(const WheelSpeed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WheelSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsureVar front_left = 1;
  bool has_front_left() const;
  void clear_front_left();
  static const int kFrontLeftFieldNumber = 1;
  const ::acu::common::UnsureVar& front_left() const;
  ::acu::common::UnsureVar* release_front_left();
  ::acu::common::UnsureVar* mutable_front_left();
  void set_allocated_front_left(::acu::common::UnsureVar* front_left);

  // optional .acu.common.UnsureVar front_right = 2;
  bool has_front_right() const;
  void clear_front_right();
  static const int kFrontRightFieldNumber = 2;
  const ::acu::common::UnsureVar& front_right() const;
  ::acu::common::UnsureVar* release_front_right();
  ::acu::common::UnsureVar* mutable_front_right();
  void set_allocated_front_right(::acu::common::UnsureVar* front_right);

  // optional .acu.common.UnsureVar rear_left = 3;
  bool has_rear_left() const;
  void clear_rear_left();
  static const int kRearLeftFieldNumber = 3;
  const ::acu::common::UnsureVar& rear_left() const;
  ::acu::common::UnsureVar* release_rear_left();
  ::acu::common::UnsureVar* mutable_rear_left();
  void set_allocated_rear_left(::acu::common::UnsureVar* rear_left);

  // optional .acu.common.UnsureVar rear_right = 4;
  bool has_rear_right() const;
  void clear_rear_right();
  static const int kRearRightFieldNumber = 4;
  const ::acu::common::UnsureVar& rear_right() const;
  ::acu::common::UnsureVar* release_rear_right();
  ::acu::common::UnsureVar* mutable_rear_right();
  void set_allocated_rear_right(::acu::common::UnsureVar* rear_right);

  // @@protoc_insertion_point(class_scope:acu.common.WheelSpeed)
 private:
  void set_has_front_left();
  void clear_has_front_left();
  void set_has_front_right();
  void clear_has_front_right();
  void set_has_rear_left();
  void clear_has_rear_left();
  void set_has_rear_right();
  void clear_has_rear_right();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsureVar* front_left_;
  ::acu::common::UnsureVar* front_right_;
  ::acu::common::UnsureVar* rear_left_;
  ::acu::common::UnsureVar* rear_right_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsWheelSpeedImpl();
};
// -------------------------------------------------------------------

class PoseEuler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.PoseEuler) */ {
 public:
  PoseEuler();
  virtual ~PoseEuler();

  PoseEuler(const PoseEuler& from);

  inline PoseEuler& operator=(const PoseEuler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseEuler(PoseEuler&& from) noexcept
    : PoseEuler() {
    *this = ::std::move(from);
  }

  inline PoseEuler& operator=(PoseEuler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseEuler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseEuler* internal_default_instance() {
    return reinterpret_cast<const PoseEuler*>(
               &_PoseEuler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PoseEuler* other);
  friend void swap(PoseEuler& a, PoseEuler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseEuler* New() const PROTOBUF_FINAL { return New(NULL); }

  PoseEuler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PoseEuler& from);
  void MergeFrom(const PoseEuler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PoseEuler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.Vector3WithCovariance position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::acu::common::Vector3WithCovariance& position() const;
  ::acu::common::Vector3WithCovariance* release_position();
  ::acu::common::Vector3WithCovariance* mutable_position();
  void set_allocated_position(::acu::common::Vector3WithCovariance* position);

  // optional .acu.common.EulerWithCovariance rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::acu::common::EulerWithCovariance& rotation() const;
  ::acu::common::EulerWithCovariance* release_rotation();
  ::acu::common::EulerWithCovariance* mutable_rotation();
  void set_allocated_rotation(::acu::common::EulerWithCovariance* rotation);

  // @@protoc_insertion_point(class_scope:acu.common.PoseEuler)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_rotation();
  void clear_has_rotation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::Vector3WithCovariance* position_;
  ::acu::common::EulerWithCovariance* rotation_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPoseEulerImpl();
};
// -------------------------------------------------------------------

class PoseQuaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.PoseQuaternion) */ {
 public:
  PoseQuaternion();
  virtual ~PoseQuaternion();

  PoseQuaternion(const PoseQuaternion& from);

  inline PoseQuaternion& operator=(const PoseQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseQuaternion(PoseQuaternion&& from) noexcept
    : PoseQuaternion() {
    *this = ::std::move(from);
  }

  inline PoseQuaternion& operator=(PoseQuaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseQuaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseQuaternion* internal_default_instance() {
    return reinterpret_cast<const PoseQuaternion*>(
               &_PoseQuaternion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(PoseQuaternion* other);
  friend void swap(PoseQuaternion& a, PoseQuaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseQuaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  PoseQuaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PoseQuaternion& from);
  void MergeFrom(const PoseQuaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PoseQuaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.Vector3WithCovariance position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::acu::common::Vector3WithCovariance& position() const;
  ::acu::common::Vector3WithCovariance* release_position();
  ::acu::common::Vector3WithCovariance* mutable_position();
  void set_allocated_position(::acu::common::Vector3WithCovariance* position);

  // optional .acu.common.Quaternion quaternion = 2;
  bool has_quaternion() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 2;
  const ::acu::common::Quaternion& quaternion() const;
  ::acu::common::Quaternion* release_quaternion();
  ::acu::common::Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::acu::common::Quaternion* quaternion);

  // optional .acu.common.Vector3 rpy_covariance = 3;
  bool has_rpy_covariance() const;
  void clear_rpy_covariance();
  static const int kRpyCovarianceFieldNumber = 3;
  const ::acu::common::Vector3& rpy_covariance() const;
  ::acu::common::Vector3* release_rpy_covariance();
  ::acu::common::Vector3* mutable_rpy_covariance();
  void set_allocated_rpy_covariance(::acu::common::Vector3* rpy_covariance);

  // @@protoc_insertion_point(class_scope:acu.common.PoseQuaternion)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_quaternion();
  void clear_has_quaternion();
  void set_has_rpy_covariance();
  void clear_has_rpy_covariance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::Vector3WithCovariance* position_;
  ::acu::common::Quaternion* quaternion_;
  ::acu::common::Vector3* rpy_covariance_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPoseQuaternionImpl();
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Twist) */ {
 public:
  Twist();
  virtual ~Twist();

  Twist(const Twist& from);

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Twist(Twist&& from) noexcept
    : Twist() {
    *this = ::std::move(from);
  }

  inline Twist& operator=(Twist&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Twist& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Twist* internal_default_instance() {
    return reinterpret_cast<const Twist*>(
               &_Twist_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Twist* other);
  friend void swap(Twist& a, Twist& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Twist* New() const PROTOBUF_FINAL { return New(NULL); }

  Twist* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Twist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.Vector3WithCovariance velocity = 1;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 1;
  const ::acu::common::Vector3WithCovariance& velocity() const;
  ::acu::common::Vector3WithCovariance* release_velocity();
  ::acu::common::Vector3WithCovariance* mutable_velocity();
  void set_allocated_velocity(::acu::common::Vector3WithCovariance* velocity);

  // optional .acu.common.Vector3WithCovariance angular_velocity = 2;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 2;
  const ::acu::common::Vector3WithCovariance& angular_velocity() const;
  ::acu::common::Vector3WithCovariance* release_angular_velocity();
  ::acu::common::Vector3WithCovariance* mutable_angular_velocity();
  void set_allocated_angular_velocity(::acu::common::Vector3WithCovariance* angular_velocity);

  // @@protoc_insertion_point(class_scope:acu.common.Twist)
 private:
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::Vector3WithCovariance* velocity_;
  ::acu::common::Vector3WithCovariance* angular_velocity_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsTwistImpl();
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.PoseEuler pose_euler = 1;
  bool has_pose_euler() const;
  void clear_pose_euler();
  static const int kPoseEulerFieldNumber = 1;
  const ::acu::common::PoseEuler& pose_euler() const;
  ::acu::common::PoseEuler* release_pose_euler();
  ::acu::common::PoseEuler* mutable_pose_euler();
  void set_allocated_pose_euler(::acu::common::PoseEuler* pose_euler);

  // optional .acu.common.PoseQuaternion pose_quaternion = 2;
  bool has_pose_quaternion() const;
  void clear_pose_quaternion();
  static const int kPoseQuaternionFieldNumber = 2;
  const ::acu::common::PoseQuaternion& pose_quaternion() const;
  ::acu::common::PoseQuaternion* release_pose_quaternion();
  ::acu::common::PoseQuaternion* mutable_pose_quaternion();
  void set_allocated_pose_quaternion(::acu::common::PoseQuaternion* pose_quaternion);

  // optional .acu.common.PoseStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::acu::common::PoseStatus status() const;
  void set_status(::acu::common::PoseStatus value);

  // @@protoc_insertion_point(class_scope:acu.common.Pose)
 private:
  void set_has_pose_euler();
  void clear_has_pose_euler();
  void set_has_pose_quaternion();
  void clear_has_pose_quaternion();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::PoseEuler* pose_euler_;
  ::acu::common::PoseQuaternion* pose_quaternion_;
  int status_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsPoseImpl();
};
// -------------------------------------------------------------------

class LLH : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.LLH) */ {
 public:
  LLH();
  virtual ~LLH();

  LLH(const LLH& from);

  inline LLH& operator=(const LLH& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LLH(LLH&& from) noexcept
    : LLH() {
    *this = ::std::move(from);
  }

  inline LLH& operator=(LLH&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LLH& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LLH* internal_default_instance() {
    return reinterpret_cast<const LLH*>(
               &_LLH_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(LLH* other);
  friend void swap(LLH& a, LLH& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LLH* New() const PROTOBUF_FINAL { return New(NULL); }

  LLH* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LLH& from);
  void MergeFrom(const LLH& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LLH* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .acu.common.UnsureVar lat = 1;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  const ::acu::common::UnsureVar& lat() const;
  ::acu::common::UnsureVar* release_lat();
  ::acu::common::UnsureVar* mutable_lat();
  void set_allocated_lat(::acu::common::UnsureVar* lat);

  // optional .acu.common.UnsureVar lon = 2;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 2;
  const ::acu::common::UnsureVar& lon() const;
  ::acu::common::UnsureVar* release_lon();
  ::acu::common::UnsureVar* mutable_lon();
  void set_allocated_lon(::acu::common::UnsureVar* lon);

  // optional .acu.common.UnsureVar height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  const ::acu::common::UnsureVar& height() const;
  ::acu::common::UnsureVar* release_height();
  ::acu::common::UnsureVar* mutable_height();
  void set_allocated_height(::acu::common::UnsureVar* height);

  // @@protoc_insertion_point(class_scope:acu.common.LLH)
 private:
  void set_has_lat();
  void clear_has_lat();
  void set_has_lon();
  void clear_has_lon();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::acu::common::UnsureVar* lat_;
  ::acu::common::UnsureVar* lon_;
  ::acu::common::UnsureVar* height_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsLLHImpl();
};
// -------------------------------------------------------------------

class NavStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:acu.common.NavStatus) */ {
 public:
  NavStatus();
  virtual ~NavStatus();

  NavStatus(const NavStatus& from);

  inline NavStatus& operator=(const NavStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NavStatus(NavStatus&& from) noexcept
    : NavStatus() {
    *this = ::std::move(from);
  }

  inline NavStatus& operator=(NavStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavStatus* internal_default_instance() {
    return reinterpret_cast<const NavStatus*>(
               &_NavStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(NavStatus* other);
  friend void swap(NavStatus& a, NavStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  NavStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavStatus& from);
  void MergeFrom(const NavStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double utc_time = 1;
  bool has_utc_time() const;
  void clear_utc_time();
  static const int kUtcTimeFieldNumber = 1;
  double utc_time() const;
  void set_utc_time(double value);

  // optional .acu.common.GpsStatus gps_status = 2;
  bool has_gps_status() const;
  void clear_gps_status();
  static const int kGpsStatusFieldNumber = 2;
  ::acu::common::GpsStatus gps_status() const;
  void set_gps_status(::acu::common::GpsStatus value);

  // optional int32 pos_status = 3;
  bool has_pos_status() const;
  void clear_pos_status();
  static const int kPosStatusFieldNumber = 3;
  ::google::protobuf::int32 pos_status() const;
  void set_pos_status(::google::protobuf::int32 value);

  // optional int32 att_status = 4;
  bool has_att_status() const;
  void clear_att_status();
  static const int kAttStatusFieldNumber = 4;
  ::google::protobuf::int32 att_status() const;
  void set_att_status(::google::protobuf::int32 value);

  // optional int32 init_status = 5;
  bool has_init_status() const;
  void clear_init_status();
  static const int kInitStatusFieldNumber = 5;
  ::google::protobuf::int32 init_status() const;
  void set_init_status(::google::protobuf::int32 value);

  // optional int32 sate_num = 6;
  bool has_sate_num() const;
  void clear_sate_num();
  static const int kSateNumFieldNumber = 6;
  ::google::protobuf::int32 sate_num() const;
  void set_sate_num(::google::protobuf::int32 value);

  // optional float hdop = 7;
  bool has_hdop() const;
  void clear_hdop();
  static const int kHdopFieldNumber = 7;
  float hdop() const;
  void set_hdop(float value);

  // optional float pdop = 8;
  bool has_pdop() const;
  void clear_pdop();
  static const int kPdopFieldNumber = 8;
  float pdop() const;
  void set_pdop(float value);

  // optional float diff_age = 9;
  bool has_diff_age() const;
  void clear_diff_age();
  static const int kDiffAgeFieldNumber = 9;
  float diff_age() const;
  void set_diff_age(float value);

  // @@protoc_insertion_point(class_scope:acu.common.NavStatus)
 private:
  void set_has_utc_time();
  void clear_has_utc_time();
  void set_has_gps_status();
  void clear_has_gps_status();
  void set_has_pos_status();
  void clear_has_pos_status();
  void set_has_att_status();
  void clear_has_att_status();
  void set_has_init_status();
  void clear_has_init_status();
  void set_has_sate_num();
  void clear_has_sate_num();
  void set_has_hdop();
  void clear_has_hdop();
  void set_has_pdop();
  void clear_has_pdop();
  void set_has_diff_age();
  void clear_has_diff_age();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double utc_time_;
  int gps_status_;
  ::google::protobuf::int32 pos_status_;
  ::google::protobuf::int32 att_status_;
  ::google::protobuf::int32 init_status_;
  ::google::protobuf::int32 sate_num_;
  float hdop_;
  float pdop_;
  float diff_age_;
  friend struct ::protobuf_geometry_2eproto::TableStruct;
  friend void ::protobuf_geometry_2eproto::InitDefaultsNavStatusImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PointENU

// optional double x = 1 [default = nan];
inline bool PointENU::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointENU::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointENU::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointENU::clear_x() {
  x_ = ::google::protobuf::internal::NaN();
  clear_has_x();
}
inline double PointENU::x() const {
  // @@protoc_insertion_point(field_get:acu.common.PointENU.x)
  return x_;
}
inline void PointENU::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:acu.common.PointENU.x)
}

// optional double y = 2 [default = nan];
inline bool PointENU::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PointENU::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PointENU::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PointENU::clear_y() {
  y_ = ::google::protobuf::internal::NaN();
  clear_has_y();
}
inline double PointENU::y() const {
  // @@protoc_insertion_point(field_get:acu.common.PointENU.y)
  return y_;
}
inline void PointENU::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:acu.common.PointENU.y)
}

// optional double z = 3 [default = 0];
inline bool PointENU::has_z() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointENU::set_has_z() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointENU::clear_has_z() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointENU::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double PointENU::z() const {
  // @@protoc_insertion_point(field_get:acu.common.PointENU.z)
  return z_;
}
inline void PointENU::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:acu.common.PointENU.z)
}

// -------------------------------------------------------------------

// Point2D

// optional double x = 1 [default = nan];
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = ::google::protobuf::internal::NaN();
  clear_has_x();
}
inline double Point2D::x() const {
  // @@protoc_insertion_point(field_get:acu.common.Point2D.x)
  return x_;
}
inline void Point2D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Point2D.x)
}

// optional double y = 2 [default = nan];
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = ::google::protobuf::internal::NaN();
  clear_has_y();
}
inline double Point2D::y() const {
  // @@protoc_insertion_point(field_get:acu.common.Point2D.y)
  return y_;
}
inline void Point2D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Point2D.y)
}

// -------------------------------------------------------------------

// Point3D

// optional double x = 1 [default = nan];
inline bool Point3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3D::clear_x() {
  x_ = ::google::protobuf::internal::NaN();
  clear_has_x();
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:acu.common.Point3D.x)
  return x_;
}
inline void Point3D::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Point3D.x)
}

// optional double y = 2 [default = nan];
inline bool Point3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3D::clear_y() {
  y_ = ::google::protobuf::internal::NaN();
  clear_has_y();
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:acu.common.Point3D.y)
  return y_;
}
inline void Point3D::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Point3D.y)
}

// optional double z = 3 [default = nan];
inline bool Point3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3D::clear_z() {
  z_ = ::google::protobuf::internal::NaN();
  clear_has_z();
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:acu.common.Point3D.z)
  return z_;
}
inline void Point3D::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Point3D.z)
}

// -------------------------------------------------------------------

// UnsureVar

// optional double variable = 1;
inline bool UnsureVar::has_variable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsureVar::set_has_variable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsureVar::clear_has_variable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsureVar::clear_variable() {
  variable_ = 0;
  clear_has_variable();
}
inline double UnsureVar::variable() const {
  // @@protoc_insertion_point(field_get:acu.common.UnsureVar.variable)
  return variable_;
}
inline void UnsureVar::set_variable(double value) {
  set_has_variable();
  variable_ = value;
  // @@protoc_insertion_point(field_set:acu.common.UnsureVar.variable)
}

// optional double var_std = 2;
inline bool UnsureVar::has_var_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsureVar::set_has_var_std() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsureVar::clear_has_var_std() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsureVar::clear_var_std() {
  var_std_ = 0;
  clear_has_var_std();
}
inline double UnsureVar::var_std() const {
  // @@protoc_insertion_point(field_get:acu.common.UnsureVar.var_std)
  return var_std_;
}
inline void UnsureVar::set_var_std(double value) {
  set_has_var_std();
  var_std_ = value;
  // @@protoc_insertion_point(field_set:acu.common.UnsureVar.var_std)
}

// -------------------------------------------------------------------

// UnsurePoints

// optional .acu.common.UnsureVar x = 1;
inline bool UnsurePoints::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsurePoints::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsurePoints::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsurePoints::clear_x() {
  if (x_ != NULL) x_->Clear();
  clear_has_x();
}
inline const ::acu::common::UnsureVar& UnsurePoints::x() const {
  const ::acu::common::UnsureVar* p = x_;
  // @@protoc_insertion_point(field_get:acu.common.UnsurePoints.x)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* UnsurePoints::release_x() {
  // @@protoc_insertion_point(field_release:acu.common.UnsurePoints.x)
  clear_has_x();
  ::acu::common::UnsureVar* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* UnsurePoints::mutable_x() {
  set_has_x();
  if (x_ == NULL) {
    x_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.UnsurePoints.x)
  return x_;
}
inline void UnsurePoints::set_allocated_x(::acu::common::UnsureVar* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete x_;
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    set_has_x();
  } else {
    clear_has_x();
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:acu.common.UnsurePoints.x)
}

// optional .acu.common.UnsureVar y = 2;
inline bool UnsurePoints::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsurePoints::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsurePoints::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsurePoints::clear_y() {
  if (y_ != NULL) y_->Clear();
  clear_has_y();
}
inline const ::acu::common::UnsureVar& UnsurePoints::y() const {
  const ::acu::common::UnsureVar* p = y_;
  // @@protoc_insertion_point(field_get:acu.common.UnsurePoints.y)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* UnsurePoints::release_y() {
  // @@protoc_insertion_point(field_release:acu.common.UnsurePoints.y)
  clear_has_y();
  ::acu::common::UnsureVar* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* UnsurePoints::mutable_y() {
  set_has_y();
  if (y_ == NULL) {
    y_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.UnsurePoints.y)
  return y_;
}
inline void UnsurePoints::set_allocated_y(::acu::common::UnsureVar* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete y_;
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    set_has_y();
  } else {
    clear_has_y();
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:acu.common.UnsurePoints.y)
}

// optional .acu.common.UnsureVar heading = 3;
inline bool UnsurePoints::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnsurePoints::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnsurePoints::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnsurePoints::clear_heading() {
  if (heading_ != NULL) heading_->Clear();
  clear_has_heading();
}
inline const ::acu::common::UnsureVar& UnsurePoints::heading() const {
  const ::acu::common::UnsureVar* p = heading_;
  // @@protoc_insertion_point(field_get:acu.common.UnsurePoints.heading)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* UnsurePoints::release_heading() {
  // @@protoc_insertion_point(field_release:acu.common.UnsurePoints.heading)
  clear_has_heading();
  ::acu::common::UnsureVar* temp = heading_;
  heading_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* UnsurePoints::mutable_heading() {
  set_has_heading();
  if (heading_ == NULL) {
    heading_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.UnsurePoints.heading)
  return heading_;
}
inline void UnsurePoints::set_allocated_heading(::acu::common::UnsureVar* heading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heading_;
  }
  if (heading) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heading, submessage_arena);
    }
    set_has_heading();
  } else {
    clear_has_heading();
  }
  heading_ = heading;
  // @@protoc_insertion_point(field_set_allocated:acu.common.UnsurePoints.heading)
}

// optional double rho = 4;
inline bool UnsurePoints::has_rho() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnsurePoints::set_has_rho() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnsurePoints::clear_has_rho() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnsurePoints::clear_rho() {
  rho_ = 0;
  clear_has_rho();
}
inline double UnsurePoints::rho() const {
  // @@protoc_insertion_point(field_get:acu.common.UnsurePoints.rho)
  return rho_;
}
inline void UnsurePoints::set_rho(double value) {
  set_has_rho();
  rho_ = value;
  // @@protoc_insertion_point(field_set:acu.common.UnsurePoints.rho)
}

// -------------------------------------------------------------------

// UnsurePosition

// optional int32 parking_id = 1;
inline bool UnsurePosition::has_parking_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnsurePosition::set_has_parking_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnsurePosition::clear_has_parking_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnsurePosition::clear_parking_id() {
  parking_id_ = 0;
  clear_has_parking_id();
}
inline ::google::protobuf::int32 UnsurePosition::parking_id() const {
  // @@protoc_insertion_point(field_get:acu.common.UnsurePosition.parking_id)
  return parking_id_;
}
inline void UnsurePosition::set_parking_id(::google::protobuf::int32 value) {
  set_has_parking_id();
  parking_id_ = value;
  // @@protoc_insertion_point(field_set:acu.common.UnsurePosition.parking_id)
}

// optional .acu.common.UnsurePoints point = 2;
inline bool UnsurePosition::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnsurePosition::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnsurePosition::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnsurePosition::clear_point() {
  if (point_ != NULL) point_->Clear();
  clear_has_point();
}
inline const ::acu::common::UnsurePoints& UnsurePosition::point() const {
  const ::acu::common::UnsurePoints* p = point_;
  // @@protoc_insertion_point(field_get:acu.common.UnsurePosition.point)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsurePoints*>(
      &::acu::common::_UnsurePoints_default_instance_);
}
inline ::acu::common::UnsurePoints* UnsurePosition::release_point() {
  // @@protoc_insertion_point(field_release:acu.common.UnsurePosition.point)
  clear_has_point();
  ::acu::common::UnsurePoints* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::acu::common::UnsurePoints* UnsurePosition::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::acu::common::UnsurePoints;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.UnsurePosition.point)
  return point_;
}
inline void UnsurePosition::set_allocated_point(::acu::common::UnsurePoints* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete point_;
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    set_has_point();
  } else {
    clear_has_point();
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:acu.common.UnsurePosition.point)
}

// -------------------------------------------------------------------

// Vector3

// optional double x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:acu.common.Vector3.x)
  return x_;
}
inline void Vector3::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Vector3.x)
}

// optional double y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:acu.common.Vector3.y)
  return y_;
}
inline void Vector3::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Vector3.y)
}

// optional double z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:acu.common.Vector3.z)
  return z_;
}
inline void Vector3::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Vector3.z)
}

// -------------------------------------------------------------------

// Quaternion

// optional double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:acu.common.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Quaternion.x)
}

// optional double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:acu.common.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Quaternion.y)
}

// optional double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:acu.common.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Quaternion.z)
}

// optional double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:acu.common.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Quaternion.w)
}

// -------------------------------------------------------------------

// Vector3WithCovariance

// optional .acu.common.UnsureVar x = 1;
inline bool Vector3WithCovariance::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3WithCovariance::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3WithCovariance::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3WithCovariance::clear_x() {
  if (x_ != NULL) x_->Clear();
  clear_has_x();
}
inline const ::acu::common::UnsureVar& Vector3WithCovariance::x() const {
  const ::acu::common::UnsureVar* p = x_;
  // @@protoc_insertion_point(field_get:acu.common.Vector3WithCovariance.x)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::release_x() {
  // @@protoc_insertion_point(field_release:acu.common.Vector3WithCovariance.x)
  clear_has_x();
  ::acu::common::UnsureVar* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::mutable_x() {
  set_has_x();
  if (x_ == NULL) {
    x_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Vector3WithCovariance.x)
  return x_;
}
inline void Vector3WithCovariance::set_allocated_x(::acu::common::UnsureVar* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete x_;
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    set_has_x();
  } else {
    clear_has_x();
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Vector3WithCovariance.x)
}

// optional .acu.common.UnsureVar y = 2;
inline bool Vector3WithCovariance::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3WithCovariance::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3WithCovariance::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3WithCovariance::clear_y() {
  if (y_ != NULL) y_->Clear();
  clear_has_y();
}
inline const ::acu::common::UnsureVar& Vector3WithCovariance::y() const {
  const ::acu::common::UnsureVar* p = y_;
  // @@protoc_insertion_point(field_get:acu.common.Vector3WithCovariance.y)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::release_y() {
  // @@protoc_insertion_point(field_release:acu.common.Vector3WithCovariance.y)
  clear_has_y();
  ::acu::common::UnsureVar* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::mutable_y() {
  set_has_y();
  if (y_ == NULL) {
    y_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Vector3WithCovariance.y)
  return y_;
}
inline void Vector3WithCovariance::set_allocated_y(::acu::common::UnsureVar* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete y_;
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    set_has_y();
  } else {
    clear_has_y();
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Vector3WithCovariance.y)
}

// optional .acu.common.UnsureVar z = 3;
inline bool Vector3WithCovariance::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3WithCovariance::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3WithCovariance::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3WithCovariance::clear_z() {
  if (z_ != NULL) z_->Clear();
  clear_has_z();
}
inline const ::acu::common::UnsureVar& Vector3WithCovariance::z() const {
  const ::acu::common::UnsureVar* p = z_;
  // @@protoc_insertion_point(field_get:acu.common.Vector3WithCovariance.z)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::release_z() {
  // @@protoc_insertion_point(field_release:acu.common.Vector3WithCovariance.z)
  clear_has_z();
  ::acu::common::UnsureVar* temp = z_;
  z_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* Vector3WithCovariance::mutable_z() {
  set_has_z();
  if (z_ == NULL) {
    z_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Vector3WithCovariance.z)
  return z_;
}
inline void Vector3WithCovariance::set_allocated_z(::acu::common::UnsureVar* z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete z_;
  }
  if (z) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    set_has_z();
  } else {
    clear_has_z();
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Vector3WithCovariance.z)
}

// -------------------------------------------------------------------

// EulerWithCovariance

// optional .acu.common.UnsureVar roll = 1;
inline bool EulerWithCovariance::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EulerWithCovariance::set_has_roll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EulerWithCovariance::clear_has_roll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EulerWithCovariance::clear_roll() {
  if (roll_ != NULL) roll_->Clear();
  clear_has_roll();
}
inline const ::acu::common::UnsureVar& EulerWithCovariance::roll() const {
  const ::acu::common::UnsureVar* p = roll_;
  // @@protoc_insertion_point(field_get:acu.common.EulerWithCovariance.roll)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* EulerWithCovariance::release_roll() {
  // @@protoc_insertion_point(field_release:acu.common.EulerWithCovariance.roll)
  clear_has_roll();
  ::acu::common::UnsureVar* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* EulerWithCovariance::mutable_roll() {
  set_has_roll();
  if (roll_ == NULL) {
    roll_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.EulerWithCovariance.roll)
  return roll_;
}
inline void EulerWithCovariance::set_allocated_roll(::acu::common::UnsureVar* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roll_;
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    set_has_roll();
  } else {
    clear_has_roll();
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:acu.common.EulerWithCovariance.roll)
}

// optional .acu.common.UnsureVar pitch = 2;
inline bool EulerWithCovariance::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EulerWithCovariance::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EulerWithCovariance::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EulerWithCovariance::clear_pitch() {
  if (pitch_ != NULL) pitch_->Clear();
  clear_has_pitch();
}
inline const ::acu::common::UnsureVar& EulerWithCovariance::pitch() const {
  const ::acu::common::UnsureVar* p = pitch_;
  // @@protoc_insertion_point(field_get:acu.common.EulerWithCovariance.pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* EulerWithCovariance::release_pitch() {
  // @@protoc_insertion_point(field_release:acu.common.EulerWithCovariance.pitch)
  clear_has_pitch();
  ::acu::common::UnsureVar* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* EulerWithCovariance::mutable_pitch() {
  set_has_pitch();
  if (pitch_ == NULL) {
    pitch_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.EulerWithCovariance.pitch)
  return pitch_;
}
inline void EulerWithCovariance::set_allocated_pitch(::acu::common::UnsureVar* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pitch_;
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    set_has_pitch();
  } else {
    clear_has_pitch();
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:acu.common.EulerWithCovariance.pitch)
}

// optional .acu.common.UnsureVar yaw = 3;
inline bool EulerWithCovariance::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EulerWithCovariance::set_has_yaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EulerWithCovariance::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EulerWithCovariance::clear_yaw() {
  if (yaw_ != NULL) yaw_->Clear();
  clear_has_yaw();
}
inline const ::acu::common::UnsureVar& EulerWithCovariance::yaw() const {
  const ::acu::common::UnsureVar* p = yaw_;
  // @@protoc_insertion_point(field_get:acu.common.EulerWithCovariance.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* EulerWithCovariance::release_yaw() {
  // @@protoc_insertion_point(field_release:acu.common.EulerWithCovariance.yaw)
  clear_has_yaw();
  ::acu::common::UnsureVar* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* EulerWithCovariance::mutable_yaw() {
  set_has_yaw();
  if (yaw_ == NULL) {
    yaw_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.EulerWithCovariance.yaw)
  return yaw_;
}
inline void EulerWithCovariance::set_allocated_yaw(::acu::common::UnsureVar* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yaw_;
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    set_has_yaw();
  } else {
    clear_has_yaw();
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:acu.common.EulerWithCovariance.yaw)
}

// -------------------------------------------------------------------

// WheelSpeed

// optional .acu.common.UnsureVar front_left = 1;
inline bool WheelSpeed::has_front_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WheelSpeed::set_has_front_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WheelSpeed::clear_has_front_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WheelSpeed::clear_front_left() {
  if (front_left_ != NULL) front_left_->Clear();
  clear_has_front_left();
}
inline const ::acu::common::UnsureVar& WheelSpeed::front_left() const {
  const ::acu::common::UnsureVar* p = front_left_;
  // @@protoc_insertion_point(field_get:acu.common.WheelSpeed.front_left)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* WheelSpeed::release_front_left() {
  // @@protoc_insertion_point(field_release:acu.common.WheelSpeed.front_left)
  clear_has_front_left();
  ::acu::common::UnsureVar* temp = front_left_;
  front_left_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* WheelSpeed::mutable_front_left() {
  set_has_front_left();
  if (front_left_ == NULL) {
    front_left_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.WheelSpeed.front_left)
  return front_left_;
}
inline void WheelSpeed::set_allocated_front_left(::acu::common::UnsureVar* front_left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete front_left_;
  }
  if (front_left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      front_left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, front_left, submessage_arena);
    }
    set_has_front_left();
  } else {
    clear_has_front_left();
  }
  front_left_ = front_left;
  // @@protoc_insertion_point(field_set_allocated:acu.common.WheelSpeed.front_left)
}

// optional .acu.common.UnsureVar front_right = 2;
inline bool WheelSpeed::has_front_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WheelSpeed::set_has_front_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WheelSpeed::clear_has_front_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WheelSpeed::clear_front_right() {
  if (front_right_ != NULL) front_right_->Clear();
  clear_has_front_right();
}
inline const ::acu::common::UnsureVar& WheelSpeed::front_right() const {
  const ::acu::common::UnsureVar* p = front_right_;
  // @@protoc_insertion_point(field_get:acu.common.WheelSpeed.front_right)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* WheelSpeed::release_front_right() {
  // @@protoc_insertion_point(field_release:acu.common.WheelSpeed.front_right)
  clear_has_front_right();
  ::acu::common::UnsureVar* temp = front_right_;
  front_right_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* WheelSpeed::mutable_front_right() {
  set_has_front_right();
  if (front_right_ == NULL) {
    front_right_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.WheelSpeed.front_right)
  return front_right_;
}
inline void WheelSpeed::set_allocated_front_right(::acu::common::UnsureVar* front_right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete front_right_;
  }
  if (front_right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      front_right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, front_right, submessage_arena);
    }
    set_has_front_right();
  } else {
    clear_has_front_right();
  }
  front_right_ = front_right;
  // @@protoc_insertion_point(field_set_allocated:acu.common.WheelSpeed.front_right)
}

// optional .acu.common.UnsureVar rear_left = 3;
inline bool WheelSpeed::has_rear_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WheelSpeed::set_has_rear_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WheelSpeed::clear_has_rear_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WheelSpeed::clear_rear_left() {
  if (rear_left_ != NULL) rear_left_->Clear();
  clear_has_rear_left();
}
inline const ::acu::common::UnsureVar& WheelSpeed::rear_left() const {
  const ::acu::common::UnsureVar* p = rear_left_;
  // @@protoc_insertion_point(field_get:acu.common.WheelSpeed.rear_left)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* WheelSpeed::release_rear_left() {
  // @@protoc_insertion_point(field_release:acu.common.WheelSpeed.rear_left)
  clear_has_rear_left();
  ::acu::common::UnsureVar* temp = rear_left_;
  rear_left_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* WheelSpeed::mutable_rear_left() {
  set_has_rear_left();
  if (rear_left_ == NULL) {
    rear_left_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.WheelSpeed.rear_left)
  return rear_left_;
}
inline void WheelSpeed::set_allocated_rear_left(::acu::common::UnsureVar* rear_left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rear_left_;
  }
  if (rear_left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rear_left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rear_left, submessage_arena);
    }
    set_has_rear_left();
  } else {
    clear_has_rear_left();
  }
  rear_left_ = rear_left;
  // @@protoc_insertion_point(field_set_allocated:acu.common.WheelSpeed.rear_left)
}

// optional .acu.common.UnsureVar rear_right = 4;
inline bool WheelSpeed::has_rear_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WheelSpeed::set_has_rear_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WheelSpeed::clear_has_rear_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WheelSpeed::clear_rear_right() {
  if (rear_right_ != NULL) rear_right_->Clear();
  clear_has_rear_right();
}
inline const ::acu::common::UnsureVar& WheelSpeed::rear_right() const {
  const ::acu::common::UnsureVar* p = rear_right_;
  // @@protoc_insertion_point(field_get:acu.common.WheelSpeed.rear_right)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* WheelSpeed::release_rear_right() {
  // @@protoc_insertion_point(field_release:acu.common.WheelSpeed.rear_right)
  clear_has_rear_right();
  ::acu::common::UnsureVar* temp = rear_right_;
  rear_right_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* WheelSpeed::mutable_rear_right() {
  set_has_rear_right();
  if (rear_right_ == NULL) {
    rear_right_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.WheelSpeed.rear_right)
  return rear_right_;
}
inline void WheelSpeed::set_allocated_rear_right(::acu::common::UnsureVar* rear_right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rear_right_;
  }
  if (rear_right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rear_right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rear_right, submessage_arena);
    }
    set_has_rear_right();
  } else {
    clear_has_rear_right();
  }
  rear_right_ = rear_right;
  // @@protoc_insertion_point(field_set_allocated:acu.common.WheelSpeed.rear_right)
}

// -------------------------------------------------------------------

// PoseEuler

// optional .acu.common.Vector3WithCovariance position = 1;
inline bool PoseEuler::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseEuler::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseEuler::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseEuler::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::acu::common::Vector3WithCovariance& PoseEuler::position() const {
  const ::acu::common::Vector3WithCovariance* p = position_;
  // @@protoc_insertion_point(field_get:acu.common.PoseEuler.position)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Vector3WithCovariance*>(
      &::acu::common::_Vector3WithCovariance_default_instance_);
}
inline ::acu::common::Vector3WithCovariance* PoseEuler::release_position() {
  // @@protoc_insertion_point(field_release:acu.common.PoseEuler.position)
  clear_has_position();
  ::acu::common::Vector3WithCovariance* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::acu::common::Vector3WithCovariance* PoseEuler::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::acu::common::Vector3WithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.PoseEuler.position)
  return position_;
}
inline void PoseEuler::set_allocated_position(::acu::common::Vector3WithCovariance* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:acu.common.PoseEuler.position)
}

// optional .acu.common.EulerWithCovariance rotation = 2;
inline bool PoseEuler::has_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseEuler::set_has_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseEuler::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseEuler::clear_rotation() {
  if (rotation_ != NULL) rotation_->Clear();
  clear_has_rotation();
}
inline const ::acu::common::EulerWithCovariance& PoseEuler::rotation() const {
  const ::acu::common::EulerWithCovariance* p = rotation_;
  // @@protoc_insertion_point(field_get:acu.common.PoseEuler.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::EulerWithCovariance*>(
      &::acu::common::_EulerWithCovariance_default_instance_);
}
inline ::acu::common::EulerWithCovariance* PoseEuler::release_rotation() {
  // @@protoc_insertion_point(field_release:acu.common.PoseEuler.rotation)
  clear_has_rotation();
  ::acu::common::EulerWithCovariance* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::acu::common::EulerWithCovariance* PoseEuler::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::acu::common::EulerWithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.PoseEuler.rotation)
  return rotation_;
}
inline void PoseEuler::set_allocated_rotation(::acu::common::EulerWithCovariance* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:acu.common.PoseEuler.rotation)
}

// -------------------------------------------------------------------

// PoseQuaternion

// optional .acu.common.Vector3WithCovariance position = 1;
inline bool PoseQuaternion::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseQuaternion::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseQuaternion::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseQuaternion::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::acu::common::Vector3WithCovariance& PoseQuaternion::position() const {
  const ::acu::common::Vector3WithCovariance* p = position_;
  // @@protoc_insertion_point(field_get:acu.common.PoseQuaternion.position)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Vector3WithCovariance*>(
      &::acu::common::_Vector3WithCovariance_default_instance_);
}
inline ::acu::common::Vector3WithCovariance* PoseQuaternion::release_position() {
  // @@protoc_insertion_point(field_release:acu.common.PoseQuaternion.position)
  clear_has_position();
  ::acu::common::Vector3WithCovariance* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::acu::common::Vector3WithCovariance* PoseQuaternion::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::acu::common::Vector3WithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.PoseQuaternion.position)
  return position_;
}
inline void PoseQuaternion::set_allocated_position(::acu::common::Vector3WithCovariance* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:acu.common.PoseQuaternion.position)
}

// optional .acu.common.Quaternion quaternion = 2;
inline bool PoseQuaternion::has_quaternion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseQuaternion::set_has_quaternion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseQuaternion::clear_has_quaternion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseQuaternion::clear_quaternion() {
  if (quaternion_ != NULL) quaternion_->Clear();
  clear_has_quaternion();
}
inline const ::acu::common::Quaternion& PoseQuaternion::quaternion() const {
  const ::acu::common::Quaternion* p = quaternion_;
  // @@protoc_insertion_point(field_get:acu.common.PoseQuaternion.quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Quaternion*>(
      &::acu::common::_Quaternion_default_instance_);
}
inline ::acu::common::Quaternion* PoseQuaternion::release_quaternion() {
  // @@protoc_insertion_point(field_release:acu.common.PoseQuaternion.quaternion)
  clear_has_quaternion();
  ::acu::common::Quaternion* temp = quaternion_;
  quaternion_ = NULL;
  return temp;
}
inline ::acu::common::Quaternion* PoseQuaternion::mutable_quaternion() {
  set_has_quaternion();
  if (quaternion_ == NULL) {
    quaternion_ = new ::acu::common::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.PoseQuaternion.quaternion)
  return quaternion_;
}
inline void PoseQuaternion::set_allocated_quaternion(::acu::common::Quaternion* quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quaternion_;
  }
  if (quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    set_has_quaternion();
  } else {
    clear_has_quaternion();
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:acu.common.PoseQuaternion.quaternion)
}

// optional .acu.common.Vector3 rpy_covariance = 3;
inline bool PoseQuaternion::has_rpy_covariance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoseQuaternion::set_has_rpy_covariance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoseQuaternion::clear_has_rpy_covariance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoseQuaternion::clear_rpy_covariance() {
  if (rpy_covariance_ != NULL) rpy_covariance_->Clear();
  clear_has_rpy_covariance();
}
inline const ::acu::common::Vector3& PoseQuaternion::rpy_covariance() const {
  const ::acu::common::Vector3* p = rpy_covariance_;
  // @@protoc_insertion_point(field_get:acu.common.PoseQuaternion.rpy_covariance)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Vector3*>(
      &::acu::common::_Vector3_default_instance_);
}
inline ::acu::common::Vector3* PoseQuaternion::release_rpy_covariance() {
  // @@protoc_insertion_point(field_release:acu.common.PoseQuaternion.rpy_covariance)
  clear_has_rpy_covariance();
  ::acu::common::Vector3* temp = rpy_covariance_;
  rpy_covariance_ = NULL;
  return temp;
}
inline ::acu::common::Vector3* PoseQuaternion::mutable_rpy_covariance() {
  set_has_rpy_covariance();
  if (rpy_covariance_ == NULL) {
    rpy_covariance_ = new ::acu::common::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.PoseQuaternion.rpy_covariance)
  return rpy_covariance_;
}
inline void PoseQuaternion::set_allocated_rpy_covariance(::acu::common::Vector3* rpy_covariance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rpy_covariance_;
  }
  if (rpy_covariance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rpy_covariance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rpy_covariance, submessage_arena);
    }
    set_has_rpy_covariance();
  } else {
    clear_has_rpy_covariance();
  }
  rpy_covariance_ = rpy_covariance;
  // @@protoc_insertion_point(field_set_allocated:acu.common.PoseQuaternion.rpy_covariance)
}

// -------------------------------------------------------------------

// Twist

// optional .acu.common.Vector3WithCovariance velocity = 1;
inline bool Twist::has_velocity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Twist::set_has_velocity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Twist::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Twist::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::acu::common::Vector3WithCovariance& Twist::velocity() const {
  const ::acu::common::Vector3WithCovariance* p = velocity_;
  // @@protoc_insertion_point(field_get:acu.common.Twist.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Vector3WithCovariance*>(
      &::acu::common::_Vector3WithCovariance_default_instance_);
}
inline ::acu::common::Vector3WithCovariance* Twist::release_velocity() {
  // @@protoc_insertion_point(field_release:acu.common.Twist.velocity)
  clear_has_velocity();
  ::acu::common::Vector3WithCovariance* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::acu::common::Vector3WithCovariance* Twist::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::acu::common::Vector3WithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Twist.velocity)
  return velocity_;
}
inline void Twist::set_allocated_velocity(::acu::common::Vector3WithCovariance* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Twist.velocity)
}

// optional .acu.common.Vector3WithCovariance angular_velocity = 2;
inline bool Twist::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Twist::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Twist::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Twist::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->Clear();
  clear_has_angular_velocity();
}
inline const ::acu::common::Vector3WithCovariance& Twist::angular_velocity() const {
  const ::acu::common::Vector3WithCovariance* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:acu.common.Twist.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::Vector3WithCovariance*>(
      &::acu::common::_Vector3WithCovariance_default_instance_);
}
inline ::acu::common::Vector3WithCovariance* Twist::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:acu.common.Twist.angular_velocity)
  clear_has_angular_velocity();
  ::acu::common::Vector3WithCovariance* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::acu::common::Vector3WithCovariance* Twist::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::acu::common::Vector3WithCovariance;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Twist.angular_velocity)
  return angular_velocity_;
}
inline void Twist::set_allocated_angular_velocity(::acu::common::Vector3WithCovariance* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Twist.angular_velocity)
}

// -------------------------------------------------------------------

// Pose

// optional .acu.common.PoseEuler pose_euler = 1;
inline bool Pose::has_pose_euler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_pose_euler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_pose_euler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_pose_euler() {
  if (pose_euler_ != NULL) pose_euler_->Clear();
  clear_has_pose_euler();
}
inline const ::acu::common::PoseEuler& Pose::pose_euler() const {
  const ::acu::common::PoseEuler* p = pose_euler_;
  // @@protoc_insertion_point(field_get:acu.common.Pose.pose_euler)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::PoseEuler*>(
      &::acu::common::_PoseEuler_default_instance_);
}
inline ::acu::common::PoseEuler* Pose::release_pose_euler() {
  // @@protoc_insertion_point(field_release:acu.common.Pose.pose_euler)
  clear_has_pose_euler();
  ::acu::common::PoseEuler* temp = pose_euler_;
  pose_euler_ = NULL;
  return temp;
}
inline ::acu::common::PoseEuler* Pose::mutable_pose_euler() {
  set_has_pose_euler();
  if (pose_euler_ == NULL) {
    pose_euler_ = new ::acu::common::PoseEuler;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Pose.pose_euler)
  return pose_euler_;
}
inline void Pose::set_allocated_pose_euler(::acu::common::PoseEuler* pose_euler) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_euler_;
  }
  if (pose_euler) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose_euler = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose_euler, submessage_arena);
    }
    set_has_pose_euler();
  } else {
    clear_has_pose_euler();
  }
  pose_euler_ = pose_euler;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Pose.pose_euler)
}

// optional .acu.common.PoseQuaternion pose_quaternion = 2;
inline bool Pose::has_pose_quaternion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_pose_quaternion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_pose_quaternion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_pose_quaternion() {
  if (pose_quaternion_ != NULL) pose_quaternion_->Clear();
  clear_has_pose_quaternion();
}
inline const ::acu::common::PoseQuaternion& Pose::pose_quaternion() const {
  const ::acu::common::PoseQuaternion* p = pose_quaternion_;
  // @@protoc_insertion_point(field_get:acu.common.Pose.pose_quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::PoseQuaternion*>(
      &::acu::common::_PoseQuaternion_default_instance_);
}
inline ::acu::common::PoseQuaternion* Pose::release_pose_quaternion() {
  // @@protoc_insertion_point(field_release:acu.common.Pose.pose_quaternion)
  clear_has_pose_quaternion();
  ::acu::common::PoseQuaternion* temp = pose_quaternion_;
  pose_quaternion_ = NULL;
  return temp;
}
inline ::acu::common::PoseQuaternion* Pose::mutable_pose_quaternion() {
  set_has_pose_quaternion();
  if (pose_quaternion_ == NULL) {
    pose_quaternion_ = new ::acu::common::PoseQuaternion;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.Pose.pose_quaternion)
  return pose_quaternion_;
}
inline void Pose::set_allocated_pose_quaternion(::acu::common::PoseQuaternion* pose_quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_quaternion_;
  }
  if (pose_quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose_quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose_quaternion, submessage_arena);
    }
    set_has_pose_quaternion();
  } else {
    clear_has_pose_quaternion();
  }
  pose_quaternion_ = pose_quaternion;
  // @@protoc_insertion_point(field_set_allocated:acu.common.Pose.pose_quaternion)
}

// optional .acu.common.PoseStatus status = 3;
inline bool Pose::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pose::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pose::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pose::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::acu::common::PoseStatus Pose::status() const {
  // @@protoc_insertion_point(field_get:acu.common.Pose.status)
  return static_cast< ::acu::common::PoseStatus >(status_);
}
inline void Pose::set_status(::acu::common::PoseStatus value) {
  assert(::acu::common::PoseStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:acu.common.Pose.status)
}

// -------------------------------------------------------------------

// LLH

// optional .acu.common.UnsureVar lat = 1;
inline bool LLH::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LLH::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LLH::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LLH::clear_lat() {
  if (lat_ != NULL) lat_->Clear();
  clear_has_lat();
}
inline const ::acu::common::UnsureVar& LLH::lat() const {
  const ::acu::common::UnsureVar* p = lat_;
  // @@protoc_insertion_point(field_get:acu.common.LLH.lat)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* LLH::release_lat() {
  // @@protoc_insertion_point(field_release:acu.common.LLH.lat)
  clear_has_lat();
  ::acu::common::UnsureVar* temp = lat_;
  lat_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* LLH::mutable_lat() {
  set_has_lat();
  if (lat_ == NULL) {
    lat_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.LLH.lat)
  return lat_;
}
inline void LLH::set_allocated_lat(::acu::common::UnsureVar* lat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lat_;
  }
  if (lat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lat, submessage_arena);
    }
    set_has_lat();
  } else {
    clear_has_lat();
  }
  lat_ = lat;
  // @@protoc_insertion_point(field_set_allocated:acu.common.LLH.lat)
}

// optional .acu.common.UnsureVar lon = 2;
inline bool LLH::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LLH::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LLH::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LLH::clear_lon() {
  if (lon_ != NULL) lon_->Clear();
  clear_has_lon();
}
inline const ::acu::common::UnsureVar& LLH::lon() const {
  const ::acu::common::UnsureVar* p = lon_;
  // @@protoc_insertion_point(field_get:acu.common.LLH.lon)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* LLH::release_lon() {
  // @@protoc_insertion_point(field_release:acu.common.LLH.lon)
  clear_has_lon();
  ::acu::common::UnsureVar* temp = lon_;
  lon_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* LLH::mutable_lon() {
  set_has_lon();
  if (lon_ == NULL) {
    lon_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.LLH.lon)
  return lon_;
}
inline void LLH::set_allocated_lon(::acu::common::UnsureVar* lon) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lon_;
  }
  if (lon) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lon = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lon, submessage_arena);
    }
    set_has_lon();
  } else {
    clear_has_lon();
  }
  lon_ = lon;
  // @@protoc_insertion_point(field_set_allocated:acu.common.LLH.lon)
}

// optional .acu.common.UnsureVar height = 3;
inline bool LLH::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LLH::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LLH::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LLH::clear_height() {
  if (height_ != NULL) height_->Clear();
  clear_has_height();
}
inline const ::acu::common::UnsureVar& LLH::height() const {
  const ::acu::common::UnsureVar* p = height_;
  // @@protoc_insertion_point(field_get:acu.common.LLH.height)
  return p != NULL ? *p : *reinterpret_cast<const ::acu::common::UnsureVar*>(
      &::acu::common::_UnsureVar_default_instance_);
}
inline ::acu::common::UnsureVar* LLH::release_height() {
  // @@protoc_insertion_point(field_release:acu.common.LLH.height)
  clear_has_height();
  ::acu::common::UnsureVar* temp = height_;
  height_ = NULL;
  return temp;
}
inline ::acu::common::UnsureVar* LLH::mutable_height() {
  set_has_height();
  if (height_ == NULL) {
    height_ = new ::acu::common::UnsureVar;
  }
  // @@protoc_insertion_point(field_mutable:acu.common.LLH.height)
  return height_;
}
inline void LLH::set_allocated_height(::acu::common::UnsureVar* height) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete height_;
  }
  if (height) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      height = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height, submessage_arena);
    }
    set_has_height();
  } else {
    clear_has_height();
  }
  height_ = height;
  // @@protoc_insertion_point(field_set_allocated:acu.common.LLH.height)
}

// -------------------------------------------------------------------

// NavStatus

// optional double utc_time = 1;
inline bool NavStatus::has_utc_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavStatus::set_has_utc_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavStatus::clear_has_utc_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavStatus::clear_utc_time() {
  utc_time_ = 0;
  clear_has_utc_time();
}
inline double NavStatus::utc_time() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.utc_time)
  return utc_time_;
}
inline void NavStatus::set_utc_time(double value) {
  set_has_utc_time();
  utc_time_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.utc_time)
}

// optional .acu.common.GpsStatus gps_status = 2;
inline bool NavStatus::has_gps_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavStatus::set_has_gps_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavStatus::clear_has_gps_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavStatus::clear_gps_status() {
  gps_status_ = 0;
  clear_has_gps_status();
}
inline ::acu::common::GpsStatus NavStatus::gps_status() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.gps_status)
  return static_cast< ::acu::common::GpsStatus >(gps_status_);
}
inline void NavStatus::set_gps_status(::acu::common::GpsStatus value) {
  assert(::acu::common::GpsStatus_IsValid(value));
  set_has_gps_status();
  gps_status_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.gps_status)
}

// optional int32 pos_status = 3;
inline bool NavStatus::has_pos_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NavStatus::set_has_pos_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NavStatus::clear_has_pos_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NavStatus::clear_pos_status() {
  pos_status_ = 0;
  clear_has_pos_status();
}
inline ::google::protobuf::int32 NavStatus::pos_status() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.pos_status)
  return pos_status_;
}
inline void NavStatus::set_pos_status(::google::protobuf::int32 value) {
  set_has_pos_status();
  pos_status_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.pos_status)
}

// optional int32 att_status = 4;
inline bool NavStatus::has_att_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NavStatus::set_has_att_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NavStatus::clear_has_att_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NavStatus::clear_att_status() {
  att_status_ = 0;
  clear_has_att_status();
}
inline ::google::protobuf::int32 NavStatus::att_status() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.att_status)
  return att_status_;
}
inline void NavStatus::set_att_status(::google::protobuf::int32 value) {
  set_has_att_status();
  att_status_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.att_status)
}

// optional int32 init_status = 5;
inline bool NavStatus::has_init_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NavStatus::set_has_init_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NavStatus::clear_has_init_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NavStatus::clear_init_status() {
  init_status_ = 0;
  clear_has_init_status();
}
inline ::google::protobuf::int32 NavStatus::init_status() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.init_status)
  return init_status_;
}
inline void NavStatus::set_init_status(::google::protobuf::int32 value) {
  set_has_init_status();
  init_status_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.init_status)
}

// optional int32 sate_num = 6;
inline bool NavStatus::has_sate_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NavStatus::set_has_sate_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NavStatus::clear_has_sate_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NavStatus::clear_sate_num() {
  sate_num_ = 0;
  clear_has_sate_num();
}
inline ::google::protobuf::int32 NavStatus::sate_num() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.sate_num)
  return sate_num_;
}
inline void NavStatus::set_sate_num(::google::protobuf::int32 value) {
  set_has_sate_num();
  sate_num_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.sate_num)
}

// optional float hdop = 7;
inline bool NavStatus::has_hdop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NavStatus::set_has_hdop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NavStatus::clear_has_hdop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NavStatus::clear_hdop() {
  hdop_ = 0;
  clear_has_hdop();
}
inline float NavStatus::hdop() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.hdop)
  return hdop_;
}
inline void NavStatus::set_hdop(float value) {
  set_has_hdop();
  hdop_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.hdop)
}

// optional float pdop = 8;
inline bool NavStatus::has_pdop() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NavStatus::set_has_pdop() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NavStatus::clear_has_pdop() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NavStatus::clear_pdop() {
  pdop_ = 0;
  clear_has_pdop();
}
inline float NavStatus::pdop() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.pdop)
  return pdop_;
}
inline void NavStatus::set_pdop(float value) {
  set_has_pdop();
  pdop_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.pdop)
}

// optional float diff_age = 9;
inline bool NavStatus::has_diff_age() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NavStatus::set_has_diff_age() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NavStatus::clear_has_diff_age() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NavStatus::clear_diff_age() {
  diff_age_ = 0;
  clear_has_diff_age();
}
inline float NavStatus::diff_age() const {
  // @@protoc_insertion_point(field_get:acu.common.NavStatus.diff_age)
  return diff_age_;
}
inline void NavStatus::set_diff_age(float value) {
  set_has_diff_age();
  diff_age_ = value;
  // @@protoc_insertion_point(field_set:acu.common.NavStatus.diff_age)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace acu

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::acu::common::PoseStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::common::PoseStatus>() {
  return ::acu::common::PoseStatus_descriptor();
}
template <> struct is_proto_enum< ::acu::common::GpsStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::acu::common::GpsStatus>() {
  return ::acu::common::GpsStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_geometry_2eproto__INCLUDED
